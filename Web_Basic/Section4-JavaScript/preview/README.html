<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:README</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="javascript">JavaScript</h1>
<h2 id="-1-javascript-">第1章 JavaScript介绍</h2>
<h3 id="1-1-">1.1 计算机编程基础</h3>
<ol>
<li><p>编程语言：</p>
<p>1）汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。</p>
<p>2）高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。</p>
</li>
<li><p>翻译器：高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此我们需要一个翻译器。翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。记住1和0。</p>
</li>
<li><p>编程语言和标记语言区别：</p>
<p>1）编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多<code>if else 、for 、while</code>等具有逻辑性和行为能力的指令，这是主动的。</p>
<p>2）标记语言（<code>html</code>）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 是被动的。</p>
</li>
</ol>
<h3 id="1-2-javascript">1.2 初识JavaScript</h3>
<ol>
<li><p>发明者：Brendan Eich，1995年10天完成。最初叫LiveScript由网景公司所有，后来被Sun收购改名为JavaCript。</p>
</li>
<li><p>JavaScript 是什么：JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言（Script 是脚本的意思）</p>
<ul>
<li>脚本语言：不需要编译，运行过程中由 js 解释器(js 引擎）逐行来进行解释并执行</li>
<li>现在也可以基于 Node.js 技术进行服务器端编程</li>
</ul>
</li>
<li><p>JavaScript 的作用：</p>
<ul>
<li>表单动态校验（密码强度检测）（JS产生最初的目的）</li>
<li>网页特效</li>
<li>服务端开发(Node.js)</li>
<li>桌面程序(Electron)</li>
<li>App(Cordova) </li>
<li>控制硬件-物联网(Ruff)</li>
<li>游戏开发(cocos2d-js)</li>
</ul>
</li>
<li><p>语言区别：</p>
<p>1）解释型语言：JavaScript，解释器是在运行时进行及时解释，并立即执行</p>
<p>2）编译型语言：Java，编译器在代码执行之前进行编译，生成中间代码文件</p>
</li>
<li><p>浏览器执行JS流程：</p>
<p>1）浏览器分成两部分：渲染引擎、JS引擎</p>
<ul>
<li>渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit</li>
<li>JS引擎：也称为 JS 解释器。用来读取网页中的JavaScript代码，对其处理后运行:<ul>
<li>Chrome：V8（性能最好）</li>
<li>Firefox：OdinMonkey 奥丁猴</li>
<li>Safari：JSCore</li>
<li>IE浏览器：Chakra 查克拉</li>
</ul>
</li>
</ul>
<p>2)浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码</p>
<ul>
<li>V8引擎：负责解析和执行 JavaScript 代码</li>
<li>内置API：由运行环境提供的特殊接口，只能在所属的运行环境中被调用（如DOM、BOM、Canvas、XHR等）</li>
</ul>
</li>
<li><p>JS 的组成：</p>
<p>1）<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview"><code>ECMAScript</code></a>：JavaScript语法：由ECMA国际（原欧洲计算机制造商协会）标准化的语言，分为JavaScript（网景）、JScript（微软）</p>
<p>2）<code>DOM</code>：页面文档对象类型：Document Object Model，标准编程接口，对页面上各种元素进行操作（大小、位置、颜色等）</p>
<p>3）<code>BOM</code>：浏览器对象类型：Browser Object Model，提供独立于内容的、可与浏览器窗口进行互动的对象结构，如弹出框、跳转、获取分辨率等</p>
</li>
<li><p>JS的书写位置</p>
<p>1）行内式：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#39;Hello World&#39;)&quot; /&gt;
</code></pre>
<ul>
<li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li>
<li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li>
<li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li>
<li>特殊情况下使用</li>
</ul>
<p>2）内嵌式：可以将多行JS代码写到<code>&lt;script&gt;</code>标签中，内嵌 JS 是学习时常用的方式</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;script&gt;
  alert(&#39;Hello World~!&#39;);
&lt;/script&gt;
</code></pre>
<p>3)外部式：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>
<li>引用外部 JS文件的 script 标签中间不可以写代码</li>
<li>适合于JS 代码量比较大的情况</li>
</ul>
</li>
<li><p>JS注释</p>
<p>1）单行注释：<code>ctrl + /</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 我是一行文字，不想被 JS引擎 执行，所以 注释起来
</code></pre>
<p>2）多行注释：<code>shift + ctrl + a</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">/*
 获取用户年龄和姓名
 并通过提示框显示出来
*/
</code></pre>
</li>
<li><p>JS输入输出语句</p>
<ul>
<li>浏览器弹出警示框：<code>alert(msg)</code></li>
<li>浏览器控制台打印输出信息：<code>console.log(msg)</code></li>
<li>浏览器弹出输入框，用户可以输入：<code>prompt(info)</code></li>
</ul>
</li>
</ol>
<h3 id="1-3-">1.3 面向对象编程</h3>
<ol>
<li><p>面向过程编程（POP）</p>
<p>1）定义：Process-Oriented Progtamming，用函数一步步实现步骤，依次调用</p>
<p>2）优点：性能比OOP高，合适跟硬件联系紧密的东西，如单片机</p>
<p>3）缺点：没有面向对象易维护、易复用、易扩展</p>
</li>
<li><p>面向对象编程（OOP）</p>
<p>1）定义：Object-Oriented Progamming：把事务分解成一个个对象，由对象之间分工与合作</p>
<p>2）特性：封装性、继承性、多态性</p>
<p>3）优点：易维护、易复用、易扩展，可以设计出低耦合系统，使系统更加灵活、更易于维护</p>
<p>4）缺点：性能比POP低</p>
</li>
</ol>
<h3 id="1-4-js-">1.4 JS历史版本</h3>
<ol>
<li>ECMA（European Computer Manufacturers Association）：欧洲计算机制造商协会</li>
<li>ECMAScript ：由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言</li>
<li><a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ES历史版本</a>：<ul>
<li>ES1：1997年，制定了语言的基本语法</li>
<li>ES2：1998年，较小改动</li>
<li>ES3：1999年，引入正则、异常处理、格式化输出等。IE 开始支持</li>
<li>ES4：2007年，过于激进，未发布</li>
<li>ES5：2009年，引入严格模式、JSON，扩展对象、数组、原型、字符串、日期方法</li>
<li>ES6：2015年，模块化、面向对象语法、Promise、箭头函数、let、const、数组解构赋值等</li>
<li>ES7：2016年，幂运算符、数组扩展、Async/await 关键字</li>
<li>ES8：2017年，Async/await、字符串扩展</li>
<li>ES9：2018年，对象解构赋值、正则扩展</li>
<li>ES10：2019年，扩展对象、数组方法</li>
<li>ES11：2020年</li>
</ul>
</li>
</ol>
<h2 id="-2-javascript-">第2章 JavaScript基础</h2>
<h3 id="2-1-js-">2.1 JS变量</h3>
<h4 id="2-1-1-var-">2.1.1 var 关键字</h4>
<ol>
<li><p>变量的使用：</p>
<p>1）方法1：声明变量：var age，计算机自动分配内存空间，给变量赋值：age = 18;</p>
<p>2）方法2：变量初始化，例：var age=18;</p>
<p>3）方法3：不声明直接赋值使用，age = 18;</p>
<p>4）多变量赋值：可以直接赋值多个变量，用逗号隔开</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var age = 18,
    address = &#39;火影村&#39;,
    gz = 2000;
</code></pre>
</li>
<li><p>变量命名规范：</p>
<p>1）由字母、数字、下换线<code>_</code>、美元符号<code>$</code>构成，下划线和美元符号都可以开头</p>
<p>2）严格区分大小写、不能以数字开头</p>
<p>3）不能是关键字、保留字，如：var、for、while</p>
<p>4）驼峰命名法，首字母小写，后面单词首字母大写</p>
</li>
<li><p>变量命名规范的拓展知识：</p>
<p>1）标识符：开发人员为变量、属性、函数、参数取的名字，不能是关键字、保留字</p>
<p>2）关键字：JS本身已经使用了的字，不能再用它们充当变量名、方法名</p>
<pre class="prettyprint linenums:0"><code class="lang-js">break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with
</code></pre>
<p>3）保留字：是预留的“关键字”，现在虽然还不是关键字，但是未来可能会成为关键字</p>
<pre class="prettyprint linenums:0"><code class="lang-js">boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile
</code></pre>
</li>
<li><p>交换两个变量的值：使用一个临时变量用来做中间存储</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 两个变量
var a = &#39;青苹果&#39;;
var b = &#39;红苹果&#39;;
// 声明一个临时变量
var temp
// 三次交换,可以使得a变为b
temp = a; a = b; b = temp;
</code></pre>
</li>
</ol>
<h4 id="2-1-2-let-">2.1.2 let 关键字</h4>
<ol>
<li><p>作用：声明非对象类型</p>
</li>
<li><p>特点：</p>
<p>1）不允许重复声明</p>
<p>2）块级作用域：块级作用域包括：if else、while、for、花括号{}等</p>
<p>3）不存在变量提升：不允许在声明变量之前调用它，直接报错，但如果是var会返回undefinded</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(song);
let song = &#39;恋爱达人&#39;;

// 对比
console.log(song);
var song = &#39;恋爱达人&#39;;
</code></pre>
<ul>
<li>不影响作用域链</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">{
  let school = &#39;尚硅谷&#39;
  function fn() {
    console.log(school)
  }
  fn()
}
</code></pre>
</li>
<li><p>可以同时声明多个变量</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let b, c, d
let f = 521, g = &#39;iloveyou&#39;, h = []
</code></pre>
</li>
<li><p>经典案例：for循环中的i</p>
<p>1）使用var，i会成为全局变量，直接跳到最终遍历结果</p>
<pre class="prettyprint linenums:0"><code class="lang-js">  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;h2 class=&quot;page-header&quot;&gt;点击切换颜色&lt;/h2&gt;
      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
      //获取div元素对象
      let items = document.getElementsByClassName(&#39;item&#39;)

      //遍历并绑定事件
      for (let i = 0; i &lt; items.length; i++) {
        items[i].onclick = function () {
          //修改当前元素的背景颜色
          // var只能用这一种方法：this
          this.style.background = &#39;pink&#39;;
        }
      }
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>2）使用let，i会成为函数变量，可以跟随遍历动态变化</p>
<pre class="prettyprint linenums:0"><code class="lang-js">  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;h2 class=&quot;page-header&quot;&gt;点击切换颜色&lt;/h2&gt;
      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
      //获取div元素对象
      let items = document.getElementsByClassName(&#39;item&#39;)

      //遍历并绑定事件
      for (let i = 0; i &lt; items.length; i++) {
        items[i].onclick = function () {
          //修改当前元素的背景颜色
          //let可以用这两种方法：this、items[i]
          items[i].style.background = &#39;pink&#39;
        }
      }
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-1-3-const-">2.1.3 const 关键字</h4>
<ol>
<li><p>作用：声明常量、对象</p>
</li>
<li><p>特点：</p>
<p>1）声明必须赋初始值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 正确方法
const SCHOOL = &#39;尚硅谷&#39;

// 错误方法
const A;
</code></pre>
<p>2）一般常量使用大写(潜规则)，不用也不会报错</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const a = 100;
</code></pre>
<p>3）常量的值不能修改</p>
<pre class="prettyprint linenums:0"><code class="lang-js">SCHOOL = &#39;ATGUIGU&#39;; // 报错
</code></pre>
<p>4）块级作用域</p>
<pre class="prettyprint linenums:0"><code class="lang-js">{
  const PLAYER = &#39;UZI&#39;;
}
console.log(PLAYER);
</code></pre>
<p>5）对于数组和对象的元素修改, 不算做对常量的修改, 不会报错</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const TEAM = [&#39;UZI&#39;, &#39;MXLG&#39;, &#39;Ming&#39;, &#39;Letme&#39;]
TEAM.push(&#39;Meiko&#39;);
</code></pre>
</li>
</ol>
<h4 id="2-1-4-">2.1.4 解构赋值</h4>
<ol>
<li><p>定义：从数组和对象中提取值，对变量进行赋值</p>
</li>
<li><p>数组的解构</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const F4 = [&#39;小沈阳&#39;, &#39;刘能&#39;, &#39;赵四&#39;, &#39;宋小宝&#39;]
let [xiao, liu, zhao, song] = F4
</code></pre>
</li>
<li><p>对象的解构</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const zhao = {
  name: &#39;赵本山&#39;,
  age: &#39;不详&#39;,
  xiaopin: function () {
    console.log(&#39;我可以演小品&#39;)
  },
}
let { name, age, xiaopin } = zhao
console.log(name)
console.log(age)
console.log(xiaopin)
xiaopin()
</code></pre>
</li>
</ol>
<h4 id="2-1-5-globalthis">2.1.5 globalThis</h4>
<ol>
<li><p>定义：无论执行环境是什么（浏览器、nodejs等），始终指向全局对象。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(globalThis)
// 浏览器结果：Window
// nodejs结果：Object [global] {...}
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-2-">2.2 数据类型</h3>
<blockquote>
<p>JavaScript是一种弱类型（动态语言）。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。使用<code>typeof</code>获取变量类型。</p>
</blockquote>
<h4 id="2-2-1-">2.2.1 简单数据类型</h4>
<ul>
<li>基本数据类型，又称值类型，储存的是值本身。栈：由操作系统自动分配释放存放函数的参数值、局部变量的值等，简单数据类型存放到栈中。</li>
</ul>
<h5 id="2-2-1-1-number-">2.2.1.1 Number：数字型</h5>
<ul>
<li><p>默认为0</p>
</li>
<li><p>八进制（0-7）：数字前加0，例：010，代表8</p>
</li>
<li><p>十六进制（0-9、a-f）：数字前加0x，例：0x9，代表9；0xa，代表10</p>
</li>
<li><p>数字型最大值：<code>Number.MAX_VALUE</code></p>
</li>
<li><p>数字型最小值：<code>Number.MIN_VALUE</code></p>
</li>
<li><p>无穷大Infinity：<code>Number.MAX_VALUE * 2</code></p>
</li>
<li><p>无穷小-Infinity：<code>- Number.MAX_VALUE * 2</code></p>
</li>
<li><p>非数值：<code>NaN</code>，用<code>isNaN()</code>判断，如果是数字返回false，否则为true</p>
</li>
<li><p><code>Number.EPSILON</code>：是 JavaScript 表示的最小精度，EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function equal(a, b) {
  if (Math.abs(a - b) &lt; Number.EPSILON) {
    return true
  } else {
    return false
  }
}
console.log(0.1 + 0.2 === 0.3)      // false
console.log(equal(0.1 + 0.2, 0.3))  // true
</code></pre>
</li>
<li><p>二进制和八进制：ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>和<code>0o</code>表示。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let b = 0b1010
let o = 0o777
let d = 100
let x = 0xff
console.log(x)  // 255
</code></pre>
</li>
<li><p><code>Number.isFinite</code>：检测一个数值是否为有限数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Number.isFinite(100))      // true
console.log(Number.isFinite(100 / 0))  // false
console.log(Number.isFinite(Infinity)) // false
</code></pre>
</li>
<li><p><code>Number.isNaN</code>：检测一个数值是否为NaN</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Number.isNaN(123))    // false
</code></pre>
</li>
<li><p><code>Number.parseInt</code>、<code>Number.parseFloat</code>：字符串转整数、小数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Number.parseInt(&#39;5211314love&#39;))        // 5211314
console.log(Number.parseFloat(&#39;3.1415926神奇&#39;))  // 3.1415926
</code></pre>
</li>
<li><p><code>Number.isInteger</code>：判断一个数是否为整数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Number.isInteger(5))    // true
console.log(Number.isInteger(2.5))  // false
</code></pre>
</li>
<li><p>BigInt：大整数，用于进行更大的数值运算。语法：整数后加<code>n</code>。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//大整数
let n = 521n
console.log(n, typeof n) // 521n, &#39;bigint&#39;

//函数
let m = 123
console.log(BigInt(m))  // 123n
console.log(BigInt(12)) // 12n
// console.log(BigInt(1.2)) // 报错：1.2是小数，无法转换为大整数

//大数值运算
let max = Number.MAX_SAFE_INTEGER  // 最大安全整数
console.log(max)      // 9007199254740991
console.log(max + 1)  // 9007199254740992
console.log(max + 2)  // 9007199254740992（不能进一步相加了）

// BigInt不能直接和普通整数运算，需要转换为BigInt才行
console.log(BigInt(max))              // 9007199254740991n
console.log(BigInt(max) + BigInt(1))  // 9007199254740992n
console.log(BigInt(max) + BigInt(2))  // 9007199254740993n
</code></pre>
</li>
</ul>
<h5 id="2-2-1-2-boolean-">2.2.1.2 Boolean：布尔值</h5>
<ul>
<li>默认为<code>false</code></li>
</ul>
<h5 id="2-2-1-3-string-">2.2.1.3 String：字符串</h5>
<ul>
<li><p>默认为<code>&quot;&quot;</code></p>
</li>
<li><p>用法：单引号（推荐）、双引号</p>
</li>
<li><p>引号嵌套：单引号内放双引号，反之亦然</p>
</li>
<li><p>转义符：</p>
<ul>
<li>换行：<code>\n</code></li>
<li>斜杠：<code>\\</code></li>
<li>单引号：<code>\&#39;</code></li>
<li>双引号：<code>\&quot;</code></li>
<li>tab缩进：<code>\t</code></li>
<li>空格：<code>\b</code></li>
</ul>
</li>
<li><p>属性：<code>length</code>：长度，例：str.length</p>
</li>
<li><p>拼接：只要有字符串和其他类型相拼接，最终结果都为字符串</p>
<pre class="prettyprint linenums:0"><code class="lang-js">  &quot;pink&quot;+true // pinkture
  &quot;pink&quot; + 18 // pink18
  &quot;12&quot; + 12   // 1212
</code></pre>
</li>
</ul>
<h5 id="2-2-1-4-undefined-">2.2.1.4 Undefined：未赋值</h5>
<ul>
<li>声明变量但未赋值，和数字相加结果是：NaN</li>
</ul>
<h5 id="2-2-1-5-null-">2.2.1.5 Null：空值</h5>
<ol>
<li>JS有个历史遗留问题，如果var x = null;  typeof x 输出的是 Object，而不是 Null</li>
<li>如果有个变量以后打算存储为对象，暂时没想好放啥，这个时候就给 null</li>
</ol>
<hr>
<h4 id="2-2-2-">2.2.2 简单数据类型转换</h4>
<h5 id="-">转为字符串</h5>
<ol>
<li><code>.toString()</code>：例：var num=1; num.toString()</li>
<li><code>String()</code>：强制转换，例：var num=1; String(num)</li>
<li>加号拼接字符串（隐式转换）：例：var num=1; num + &#39;&#39;</li>
</ol>
<h5 id="-">转为数字型</h5>
<ol>
<li><p><code>parseInt(string)</code>：字符串转整数</p>
<p>1）只截取整数部分，不做四舍五入</p>
<p>2）简单自动提取数字部分，如输入&quot;120px”，输出为120</p>
<p>3）如果开头不是数字，则无法提取，如&quot;rem120px&quot;，输出为NaN</p>
</li>
<li><p><code>parseFloat(string)</code>：字符串转小数</p>
</li>
<li><code>Number()</code>：强制转换</li>
<li>减乘除运算（隐式转换)：例：&quot;12&quot; - 0、&quot;123&quot;-&quot;120&quot;</li>
</ol>
<h5 id="-">转为布尔型</h5>
<ol>
<li><p>Boolean()</p>
<p>1）代表空、否定的值都会被转为false：<code>&#39;&#39;、0、NaN、null、undefined</code></p>
<p>2）其余值都被转为true</p>
</li>
</ol>
<hr>
<h4 id="2-2-3-">2.2.3 复杂数据类型</h4>
<ol>
<li><p>定义：又称引用类型，使用new关键字创建的对象（系统对象、自定义对象），如<code>Object、Array、Date</code>等</p>
</li>
<li><p>JS中的7种数据类型（USONB）:</p>
<ul>
<li>u：undefined</li>
<li>s：string 、symbol</li>
<li>o：object</li>
<li>n：null、number</li>
<li>b：boolean</li>
</ul>
</li>
<li><p>堆：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收，复杂数据类型存放到堆中</p>
</li>
<li><p>过程：首先在栈里面存放地址，十六进制表示，然后这个地址指向堆里面的数据</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 复杂数据类型传参
function Person(name) {
  this.name = name
}
function f1(x) {
  console.log(x.name) // 刘德华
  x.name = &#39;张学友&#39;
  console.log(x.name) // 张学友
}
var p = new Person(&#39;刘德华&#39;)
console.log(p.name) // 刘德华
f1(p)
console.log(p.name) // 张学友
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-3-">2.3 运算符</h3>
<h4 id="2-3-1-">2.3.1 算术运算符</h4>
<ol>
<li><p>包括：加+、减-、乘*、除/、取模（取余数）%、幂**</p>
</li>
<li><p>注意：</p>
<p>1）浮点数的运算里面会有问题，尽量避免用小数运算</p>
<p>2）不能直接用浮点数进行比较是否相等</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var num = 0.1 + 0.2;
console.log(num == 0.3); // false
</code></pre>
</li>
</ol>
<h4 id="2-3-2-">2.3.2 递增运算符</h4>
<ol>
<li><p>前提：必须和变量配合使用</p>
</li>
<li><p>前置递增运算符：<code>++num</code>，等价于 num = num + 1</p>
</li>
<li><p>后置递增运算符：<code>num++</code></p>
<p>1）单独使用：和前置递增效果相同</p>
<p>2）配合运算：先返回原值，再自加1</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var age = 10
console.log(age++ + 10)  // 20
console.log(age)         // 11
</code></pre>
</li>
<li><p>综合案例：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var a = 10
++a // 11
var b = ++a + 2 // 12+2
console.log(b) // 14

var c = 10
c++ // 11

var d = c++ + 2 //  先返回原值，再自加1：此时c=12，但是c++返回的是11，故此运算为：11+2
console.log(d)  // 13

var e = 10
var f = e++ + ++e // 1. e++ =  10  e = 11  2. e = 12  ++e = 12
console.log(f) // 22
</code></pre>
</li>
</ol>
<h4 id="2-3-3-">2.3.3 递减运算符</h4>
<ul>
<li>原理同递增运算符</li>
</ul>
<h4 id="2-3-4-">2.3.4 比较运算符</h4>
<ul>
<li>小于:<code>&lt;</code></li>
<li>大于:<code>&gt;</code></li>
<li>大于等于:<code>&gt;=</code></li>
<li>小于等于:<code>&lt;=</code></li>
<li>判等号:<code>==</code>（注意：判等号会自动转换类型，如：18==&#39;18&#39; --&gt; true）</li>
<li>4 不等号:<code>!=</code></li>
<li>全等号（值、数据类型全等）：<code>===</code></li>
<li>全不等号:<code>!==</code></li>
</ul>
<h4 id="2-3-5-">2.3.5 逻辑运算符</h4>
<ol>
<li><p>基础符号：与（<code>&amp;&amp;</code>）、或（<code>||</code>）、非（<code>!</code>）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 编写一个函数，带一个参数n，在页面上输出1～n（n&gt;1）之间所有能同时被3和5整除的偶数，并要求每行只输出6个
function fn(n) {
  var count = 0
  for (var i = 1; i &lt;= n; i++) {
    if (i % 3 == 0 &amp;&amp; i % 5 == 0 &amp;&amp; i % 2 == 0) {
      document.write(i + &#39; &#39;)
      count++
      if (count % 6 == 0) {
        document.write(&#39;&lt;br /&gt;&#39;)
      }
    }
  }
}
fn(1000)
</code></pre>
</li>
<li><p>短路运算：当有多个表达式（值）时，左边的表达式可以确定结果时，就不在继续运算右边的表达式的值</p>
<p>1）与：a &amp;&amp; b，若a为真，返回b；若a为假，返回a</p>
<p>2）或：a || b，若a为真，返回a；若a为假，返回b</p>
<p>3）注意：如果左侧被短路，右侧前置/后置递增/减运算就不会进行了</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(123 &amp;&amp; 456) // 456
console.log(0 &amp;&amp; 456) //  0
console.log(0 &amp;&amp; 1 + 2 &amp;&amp; 456 * 56789) // 0
console.log(&#39;&#39; &amp;&amp; 1 + 2 &amp;&amp; 456 * 56789) // &#39;&#39;
console.log(123 || 456) // 123
console.log(123 || 456 || 456 + 123) // 123
console.log(0 || 456 || 456 + 123) // 456
var num = 0
console.log(123 || num++)
console.log(num) // 0
</code></pre>
</li>
</ol>
<h4 id="2-3-6-">2.3.6 赋值运算符</h4>
<ol>
<li>直接赋值：<code>=</code></li>
<li>加减一个数后再赋值：<code>+=</code>、<code>-=</code></li>
<li>乘除取模后再赋值：<code>*=</code>、<code>/=</code>、<code>%=</code></li>
</ol>
<h4 id="2-3-7-">2.3.7 运算符优先级</h4>
<ul>
<li>1级：小括号（）</li>
<li>2级：一元运算符：<code>++、--、！</code></li>
<li>3级：算数运算符：先<code>*、/、%</code>，后<code>+、-</code></li>
<li>4级：关系运算符：<code>&gt;、&gt;=、&lt;、&lt;=</code></li>
<li>5级：相等运算符：<code>==、!=、===、!==</code></li>
<li>6级：逻辑运算符：先 <code>&amp;&amp;</code>、后<code>||</code></li>
<li>7级：赋值运算符：<code>=</code></li>
<li>8级：逗号运算符：<code>，</code></li>
</ul>
<h4 id="2-3-7-spread">2.3.7 扩展运算符 Spread</h4>
<ol>
<li><p>形式：三个点（<code>...</code>）</p>
</li>
<li><p>作用：好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const tfboys = [&#39;易烊千玺&#39;, &#39;王源&#39;, &#39;王俊凯&#39;]
// 声明一个函数
function chunwan() {
  console.log(arguments)
}
chunwan(...tfboys) // chunwan(&#39;易烊千玺&#39;,&#39;王源&#39;,&#39;王俊凯&#39;)
</code></pre>
</li>
<li><p>应用：</p>
<p>1）数组的合并</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 传统方法
arr1.concat(arr2)

// 扩展运算符
[...arr1, ...arr2]
</code></pre>
<p>2）数组的克隆</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 将arr2克隆成arr1
const arr2 = [...arr1]
</code></pre>
<p>3）将伪数组转为真正的数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const divs = document.querySelectorAll(&#39;div&#39;)
const divArr = [...divs]
</code></pre>
<p>4）展开对象（ES9新特性）：<code>let newObj = {...obj1, ...obj2, ...obj3}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">let skillOne = {
 q: &#39;致命打击&#39;,
};
let skillTwo = {
 w: &#39;勇气&#39;
};
let skillThree = {
 e: &#39;审判&#39;
};
let skillFour = {
 r: &#39;德玛西亚正义&#39;
};
let gailun = {...skillOne, ...skillTwo,...skillThree,...skillFour}
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-4-">2.4 流程控制</h3>
<h4 id="2-4-1-">2.4.1 顺序结构</h4>
<blockquote>
<p>常规从上到下执行语句。</p>
</blockquote>
<h4 id="2-4-2-">2.4.2 分支结构</h4>
<blockquote>
<p>从上到下执行代码时，根据不同条件执行不同的路径代码，得到不同的结果。</p>
</blockquote>
<h5 id="2-4-2-1-if-">2.4.2.1 if语句</h5>
<ol>
<li><p>if分支语句：<code>if（条件表达式）{执行语句}</code></p>
</li>
<li><p>if else双分支语句：<code>if（条件表达式）{执行语句1} else {执行语句2}</code></p>
</li>
<li><p>if else if多分支语句：<code>if（条件表达式1）{执行语句1} else if（条件表达式2）{执行语句2} else {执行语句3}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">//if分支语句
if (3 &lt; 5) {
    alert(&#39;沙漠骆驼&#39;);
}

// if else双分支语句
var age = prompt(&#39;请输入您的年龄:&#39;);
if (age &gt;= 18) {
    alert(&#39;我想带你去网吧偷耳机&#39;);
} else {
    alert(&#39;滚， 回家做作业去&#39;);
}

// if else if多分支语句
var score = prompt(&#39;请您输入分数:&#39;);
if (score &gt;= 90) {
    alert(&#39;宝贝，你是我的骄傲&#39;);
} else if (score &gt;= 80) {
    alert(&#39;宝贝，你已经很出色了&#39;);
} else if (score &gt;= 70) {
    alert(&#39;你要继续加油喽&#39;);
} else if (score &gt;= 60) {
    alert(&#39;孩子，你很危险&#39;);
} else {
    alert(&#39;熊孩子，我不想和你说话，我只想用鞭子和你说话&#39;);
}
</code></pre>
</li>
</ol>
<h5 id="2-4-2-2-">2.4.2.2 三元表达式</h5>
<ol>
<li><p>语法：<code>条件表达式 ？表达式1 ：表达式2</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 数字补0案例
var time = prompt(&#39;请您输入一个 0 ~ 59 之间的一个数字&#39;)
var result = time &lt; 10 ? &#39;0&#39; + time : time
alert(result)
</code></pre>
</li>
</ol>
<h5 id="2-4-2-3-switch-">2.4.2.3 switch语句</h5>
<ol>
<li><p>定义：针对变量设置一系列特定值的选项，若表达式值与case后面的value相匹配，则执行条件语句。</p>
</li>
<li><p>语法：<code>switch (表达式) {case value1: 执行语句1; break; case value2: 执行语句2; break; ...default: 执行最后的语句; }</code></p>
</li>
<li><p>注意：</p>
<p>1）表达式的值和 case 里面的值相匹配的时候是全等（<code>===</code>），值和数据类型全都相同才可以</p>
<p>2）如果当前的case里面没有break 则不会退出switch，而是继续执行下一个case</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var num = prompt(&#39;请输入数值：&#39;)
switch (parseFloat(num)) {
  case 1:
    console.log(&#39;这是1&#39;)
    alert(&#39;这是1&#39;)
    break
  case 2:
    console.log(&#39;这是2&#39;)
    alert(&#39;这是2&#39;)
    break
  case 3:
    console.log(&#39;这是3&#39;)
    alert(&#39;这是3&#39;)
    break
  default:
    console.log(&#39;没有匹配结果&#39;)
    alert(&#39;没有匹配结果&#39;)
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-4-3-">2.4.3 循环结构</h4>
<h5 id="2-4-3-1-for-">2.4.3.1 for循环</h5>
<ol>
<li><p>语法：<code>for (初始化变量; 条件表达式; 操作表达式) {循环体}</code></p>
</li>
<li><p>执行顺序：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">for (var i = 1; i &lt;= 100; i++) {
  console.log(&#39;你好吗&#39;)
}
</code></pre>
<p>1）var i=1：初始化执行一次</p>
<p>2）i &lt;= 100：判断</p>
<p>3）console.log(&#39;你好吗&#39;)：打印</p>
<p>4）i++：自增+1</p>
</li>
<li><p>for案例：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 打印n行n列的星星
var rows = prompt(&#39;请您输入行数:&#39;);
var cols = prompt(&#39;请您输入列数:&#39;);
var str = &#39;&#39;;
for (var i = 1; i &lt;= rows; i++) {
    for (var j = 1; j &lt;= cols; j++) {
        str = str + &#39;★&#39;;
    }
    str += &#39;\n&#39;;
}
console.log(str);
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 打印倒三角形案例
var str = &#39;&#39;
for (var i = 1; i &lt;= 10; i++) {
  // 外层循环控制行数
  for (var j = i; j &lt;= 10; j++) {
    // 里层循环打印的个数不一样  j = i
    str = str + &#39;★&#39;
  }
  str += &#39;\n&#39;
}
console.log(str)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 九九乘法表
var str = &#39;&#39;
for (var i = 1; i &lt;= 9; i++) {
  // 外层循环控制行数
  for (var j = 1; j &lt;= i; j++) {
    // 里层循环控制每一行的个数  j &lt;= i
    // 1 × 2 = 2
    // str = str + &#39;★&#39;;
    str += j + &#39;×&#39; + i + &#39;=&#39; + i * j + &#39;\t&#39;
  }
  str += &#39;\n&#39;
}
console.log(str)
</code></pre>
</li>
</ol>
<h5 id="2-4-3-2-while-">2.4.3.2 while循环</h5>
<ol>
<li><p>语法：<code>while (条件表达式) {循环体}</code></p>
</li>
<li><p>区别：相比for循环，可以判断更复杂的条件</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 1. 打印人的一生，从1岁到100岁
var i = 1
while (i &lt;= 100) {
  console.log(&#39;这个人今年&#39; + i + &#39;岁了&#39;)
  i++
}
// 2. 计算 1 ~ 100 之间所有整数的和
var sum = 0
var j = 1
while (j &lt;= 100) {
  sum += j
  j++
}
console.log(sum)
// 3. 弹出一个提示框，你爱我吗？如果输入我爱你，就提示结束，否则一直询问
var message = prompt(&#39;你爱我吗?&#39;)
while (message !== &#39;我爱你&#39;) {
  message = prompt(&#39;你爱我吗?&#39;)
}
alert(&#39;我也爱你啊！&#39;)
</code></pre>
</li>
</ol>
<h5 id="2-4-3-3-do-while-">2.4.3.3 do while循环</h5>
<ol>
<li><p>语法：<code>do{循环体} while (条件表达式)</code></p>
</li>
<li><p>区别：先执行一次循环体，再判断条件，如果表达式为真则继续执行循环体</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 1. 打印人的一生，从1岁到100岁
var i = 1
do {
  console.log(&#39;这个人今年&#39; + i + &#39;岁了&#39;)
  i++
} while (i &lt;= 100)
// 2. 计算 1 ~ 100 之间所有整数的和
var sum = 0
var j = 1
do {
  sum += j
  j++
} while (j &lt;= 100)
console.log(sum)
// 3. 弹出一个提示框，你爱我吗？如果输入我爱你，就提示结束，否则一直询问
do {
  var message = prompt(&#39;你爱我吗?&#39;)
} while (message !== &#39;我爱你&#39;)
alert(&#39;我也爱你啊&#39;)
</code></pre>
</li>
</ol>
<h5 id="2-4-3-4-continue-">2.4.3.4 continue关键字</h5>
<ol>
<li><p>作用：立即跳出本次循环，继续下一个循环</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// continue 关键字：退出本次（当前次的循环），继续执行剩余次数循环
for (var i = 1; i &lt;= 5; i++) {
  if (i == 3) {
    continue // 只要遇见 continue就退出本次循环 直接跳到 i++
  }
  console.log(&#39;我正在吃第&#39; + i + &#39;个包子&#39;)
}

// 求1~100 之间，除了能被7整除之外的整数和
var sum = 0
for (var i = 1; i &lt;= 100; i++) {
  if (i % 7 == 0) {
    continue
  }
  sum += i
}
console.log(sum)
</code></pre>
</li>
</ol>
<h5 id="2-4-3-5-break-">2.4.3.5 break关键字</h5>
<ol>
<li><p>作用：退出整个循环</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// break 退出整个循环
for (var i = 1; i &lt;= 5; i++) {
  if (i == 3) {
    break
  }
  console.log(&#39;我正在吃第&#39; + i + &#39;个包子&#39;)
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-4-4-">2.4.4 迭代器</h4>
<ol>
<li><p>定义：遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口（可以理解为对象中的属性），就可以完成遍历操作。</p>
</li>
<li><p>ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费</p>
</li>
<li><p>原生具备 iterator 接口的数据(可用<code>for of</code>遍历)</p>
<ul>
<li>Array</li>
<li>Arguments</li>
<li>Set</li>
<li>Map</li>
<li>String</li>
<li>TypedArray</li>
<li>NodeList</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">//声明一个数组
const xiyou = [&#39;唐僧&#39;, &#39;孙悟空&#39;, &#39;猪八戒&#39;, &#39;沙僧&#39;]

// 使用 for...of 遍历数组：键值
for (let v of xiyou) {
  console.log(v)
}

// 【对比】使用 for...of 遍历数组：键名：0、1、2、3
for (let v in xiyou) {
  console.log(v)
}
</code></pre>
</li>
<li><p>工作原理:</p>
<p>1）创建一个指针对象，指向当前数据结构的起始位置</p>
<p>2）第一次调用对象的 <code>next</code> 方法，指针自动指向数据结构的第一个成员</p>
<p>3）接下来不断调用 <code>next</code> 方法，指针一直往后移动，直到指向最后一个成员</p>
<p>4）每调用 <code>next</code> 方法返回一个包含 <code>value</code> 和 <code>done</code> 属性的对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//声明一个数组
const xiyou = [&#39;唐僧&#39;, &#39;孙悟空&#39;, &#39;猪八戒&#39;, &#39;沙僧&#39;]

// 创建迭代器
let iterator = xiyou[Symbol.iterator]()

//调用对象的next方法
console.log(iterator.next()) //{value: &#39;唐僧&#39;, done: false}
console.log(iterator.next()) //{value: &#39;孙悟空&#39;, done: false}
console.log(iterator.next()) //{value: &#39;猪八戒&#39;, done: false}
console.log(iterator.next()) //{value: &#39;沙僧&#39;, done: false}
console.log(iterator.next()) //{value: undefined, done: true}
</code></pre>
</li>
<li><p>需要自定义遍历数据的时候，要想到迭代器</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//声明一个对象
const banji = {
  name: &#39;终极一班&#39;,
  stus: [&#39;xiaoming&#39;, &#39;xiaoning&#39;, &#39;xiaotian&#39;, &#39;knight&#39;],
  [Symbol.iterator]() {
    //索引变量
    let index = 0
    //保存this，指向banji对象
    let _this = this
    return {
      next: function () {
        if (index &lt; _this.stus.length) {
          const result = { value: _this.stus[index], done: false }
          //下标自增
          index++
          //返回结果
          return result
        } else {
          return { value: undefined, done: true }
        }
      },
    }
  },
}

//遍历对象：如果不用迭代器，会报错：is not iterable
//遍历这个对象中的stus：
for (let v of banji) {
  console.log(v)
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-4-5-">2.4.5 生成器</h4>
<ol>
<li><p>定义：生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
</li>
<li><p>常见的异步编程：文件操作（<code>fs</code>）、网络操作（<code>ajax</code>、<code>request</code>）、数据库操作（<code>mongodb</code>）等</p>
</li>
<li><p>特点：</p>
<p>1）*的位置没有限制</p>
<p>2）生成器函数返回的结果是迭代器对象，调用迭代器对象的<code>next</code>方法可以得到<code>yield</code>语句后的值</p>
<p>3）<code>yield</code>相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次<code>next</code>方法，执行一段代码</p>
<p>4）<code>next</code>方法可以传递实参，作为<code>yield</code>语句的返回值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function* gen() {
  console.log(111)
  yield &#39;一只没有耳朵&#39;
  console.log(222)
  yield &#39;一只没有尾部&#39;
  console.log(333)
  yield &#39;真奇怪&#39;
  console.log(444)
}

let iterator = gen()
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())

//遍历
for (let v of gen()) {
  console.log(v)
}
</code></pre>
</li>
<li><p>参数：</p>
<p>1）在实例化迭代器时，可以传递参数：<code>let iterator = gen(&#39;args&#39;)</code></p>
<p>2）next方法可以传入实参，作为上一个yield语句的返回结果</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function* gen(arg) {
  console.log(arg)       // AAA
  let one = yield 111 // {value: 111, done: false}，这里的one，承接next中传入的参数 BBB

  console.log(one)       // BBB
  let two = yield 222 // {value: 222, done: false}，这里的two，承接next中传入的参数 CCC

  console.log(two)         // CCC
  let three = yield 333 // {value: 333, done: false}，这里的three，承接next中传入的参数 DDD

  console.log(three) // DDD
                       // {value: undefined, done: true}
}
//执行获取迭代器对象
let iterator = gen(&#39;AAA&#39;)
console.log(iterator.next())

//next方法可以传入实参
console.log(iterator.next(&#39;BBB&#39;))
console.log(iterator.next(&#39;CCC&#39;))
console.log(iterator.next(&#39;DDD&#39;))
</code></pre>
</li>
<li><p>案例1：定时器——1s后控制台输出111、2s后输出222、3s后输出333</p>
<p>1）普通做法：层级嵌套太多，非常麻烦（回调地狱）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">setTimeout(() =&gt; {
  console.log(111)
  setTimeout(() =&gt; {
    console.log(222)
    setTimeout(() =&gt; {
      console.log(333)
    }, 3000)
  }, 2000)
}, 1000)
</code></pre>
<p>2）生成器函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function one() {
  setTimeout(() =&gt; {
    console.log(111)
    // 内部直接调用next，自动执行下一个函数
    iterator.next()
  }, 1000)
}
function two() {
  setTimeout(() =&gt; {
    console.log(222)
    iterator.next()
  }, 2000)
}
function three() {
  setTimeout(() =&gt; {
    console.log(333)
    iterator.next()
  }, 3000)
}
function* gen() {
  yield one()
  yield two()
  yield three()
}
//调用生成器函数
let iterator = gen()
iterator.next()
</code></pre>
</li>
<li><p>案例2：模拟获取——用户数据、订单数据、商品数据（逻辑：必须先调用用户数据，才有订单数据，然后才有商品数据）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function getUsers() {
  setTimeout(() =&gt; {
    let data = &#39;用户数据&#39;
    //调用 next 方法，传入实参【作为上一个yield语句的返回结果】
    iterator.next(data)
  }, 1000)
}
function getOrders() {
  setTimeout(() =&gt; {
    let data = &#39;订单数据&#39;
    iterator.next(data)
  }, 1000)
}
function getGoods() {
  setTimeout(() =&gt; {
    let data = &#39;商品数据&#39;
    iterator.next(data)
  }, 1000)
}
function* gen() {
  let users = yield getUsers()
  let orders = yield getOrders()
  let goods = yield getGoods()
}
//调用生成器函数
let iterator = gen()
iterator.next()
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-5-array">2.5 数组 Array</h3>
<blockquote>
<p>数组(Array)：就是一组数据的集合，存储在单个变量下的优雅方式</p>
</blockquote>
<h4 id="2-5-1-">2.5.1 创建数组</h4>
<ol>
<li><p>new方法创建：<code>var 数组名 = new Array()</code></p>
<p>1）new Array(2)：表示数组的长度为 2，里面有2个空的数组元素 </p>
<p>2）new Array(2, 3)：等价于 [2,3]</p>
</li>
<li><p>数组字面量创建：<code>var 数组名 = [ ]</code></p>
</li>
<li><p>获取数组元素：<code>array[index]</code>，如果index超出数组长度，返回undefined</p>
</li>
</ol>
<h4 id="2-5-2-">2.5.2 检测数组</h4>
<ol>
<li><code>instanceof</code>：检测对象 instanceof Array</li>
<li><p><code>.isArray</code>：Array.isArray(检测对象)</p>
</li>
<li><p><code>.includes</code>：includes 方法用来检测数组中是否包含某个元素，返回布尔类型值（对比 indexOf，返回的是索引数值，不存在返回-1）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// includes
const mingzhu = [&#39;西游记&#39;, &#39;红楼梦&#39;, &#39;三国演义&#39;, &#39;水浒传&#39;]

//判断
console.log(mingzhu.includes(&#39;西游记&#39;))
console.log(mingzhu.includes(&#39;金瓶梅&#39;))

//对比indexOf
console.log(mingzhu.indexOf(&#39;三国演义&#39;))
console.log(mingzhu.indexOf(&#39;葫芦娃&#39;))
</code></pre>
</li>
</ol>
<h4 id="2-5-3-">2.5.3 数组长度</h4>
<ol>
<li><p>显示长度：<code>arr.length</code></p>
</li>
<li><p>修改长度：<code>arr.length=X</code>，新增的元素未赋值前为undefined</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 数组求和、平均值
var arr = [2, 6, 1, 7, 4]
var sum = 0
var average = 0
for (var i = 0; i &lt; arr.length; i++) {
  sum += arr[i] // 我们加的是数组元素 arr[i] 不是计数器 i
}
average = sum / arr.length
console.log(sum, average) // 想要输出多个变量，用逗号分隔即可

// 数组求最大值
var arr = [2, 6, 1, 77, 52, 25, 7, 99]
var max = arr[0]
for (var i = 1; i &lt; arr.length; i++) {
  if (arr[i] &gt; max) {
    max = arr[i]
  }
}
console.log(&#39;该数组里面的最大值是：&#39; + max)
</code></pre>
</li>
</ol>
<h4 id="2-5-4-">2.5.4 新增元素</h4>
<ol>
<li><p>直接赋值：<code>arr[i]=X</code></p>
</li>
<li><p><code>arr.push(...)</code>：在数组末尾添加一个或多个元素</p>
<p>1）返回结果：新数组长度</p>
<p>2）直接修改原数组</p>
</li>
<li><p><code>arr.unshift(...)</code>：在数组前面添加一个或多个元素</p>
<p>1）返回结果：新数组长度</p>
<p>2）直接修改原数组</p>
</li>
</ol>
<h4 id="2-5-5-">2.5.5 删除元素</h4>
<ol>
<li><p><code>arr.pop()</code>：删除数组的最后一个元素</p>
<p>1）返回结果：被删除的元素</p>
<p>2）直接修改原数组</p>
</li>
<li><p><code>arr.shift()</code>：删除数组的第一个元素</p>
<p>1）返回结果：被删除的元素</p>
<p>2）直接修改原数组</p>
</li>
</ol>
<h4 id="2-5-6-">2.5.6 修改元素</h4>
<ol>
<li><p>直接修改：<code>arr[i]=X</code></p>
</li>
<li><p><code>arr.splice(开始位置，删除元素数量，插入元素...)</code></p>
<p>1）返回值：由被删除的元素组成的一个数组；只删除了一个元素，返回只包含一个元素的数组；如果没有删除元素，则返回空数组</p>
<p>2）直接修改原数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 从索引 2 的位置开始删除 0 个元素，插入“drum”
arr.splice(2, 0, &quot;drum&quot;)
// 从索引 3 的位置开始删除 1 个元素
arr.splice(3, 1)
// 从索引 2 的位置开始删除所有元素
arr.splice(2)
</code></pre>
</li>
</ol>
<h4 id="2-5-7-">2.5.7 数组排序</h4>
<ol>
<li><p><code>arr.reverse()</code>：颠倒数组元素顺序</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 普通方法翻转数组
var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;, &#39;purple&#39;, &#39;hotpink&#39;]
var newArr = []
for (var i = arr.length - 1; i &gt;= 0; i--) {
  newArr[newArr.length] = arr[i]
}
console.log(newArr)

// reverse方法
console.log(arr.reverse())
</code></pre>
</li>
<li><p><code>arr.sort()</code>：对数组元素排序</p>
<p>1）直接使用：升序排列，但是遇到位数不同的数字，先看个位数、十位数、...进行排序</p>
<p>2）升序排列：<code>arr.sort(function(a, b) {return a - b;}</code></p>
<p>3）降序排列：<code>arr.sort(function(a, b) {return b - a;}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 重新随机排序得到一个新数组
var arr = [&#39;鹿晗&#39;, &#39;王俊凯&#39;, &#39;蔡徐坤&#39;, &#39;彭于晏&#39;, &#39;周杰伦&#39;, &#39;刘德华&#39;, &#39;赵本山&#39;]
arr.sort(function () {
  // Math.random 结果是：0-1之间的数字，减去0.5，这样的最后的结果是不准确的（丢失精度问题）
  return Math.random() - 0.5
})
document.write(arr)
</code></pre>
</li>
<li><p>冒泡排序</p>
<p>1）原理：一次比较两个元素，如果他们的顺序错误就把他们交换过来，一直循环比较并交换，直到没有元素需要交换为止</p>
<p>2）外层循环：次数=arr.length -1</p>
<p>3）内层循环：次数=arr.length - i - 1</p>
<p>4）内部交换：借助临时变量，交换元素数值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [4, 1, 2, 3, 5]
for (var i = 0; i &lt;= arr.length - 1; i++) {
  // 外层循环管趟数
  for (var j = 0; j &lt;= arr.length - i - 1; j++) {
    // 里面的循环管 每一趟的交换次数
    // 内部交换2个变量的值 前一个和后面一个数组元素相比较
    if (arr[j] &lt; arr[j + 1]) {
      var temp = arr[j]
      arr[j] = arr[j + 1]
      arr[j + 1] = temp
    }
  }
}
</code></pre>
</li>
</ol>
<h4 id="2-5-8-">2.5.8 数组索引</h4>
<ol>
<li><code>arr.indexOf(...)</code>：从前开始查找，返回第一个满足条件的索引号，如果没有该元素，返回-1</li>
<li><code>arr.lastIndexOf(...)</code>：从后开始查找，返回第一个满足条件的索引号，如果没有该元素，返回-1</li>
</ol>
<h4 id="2-5-9-">2.5.9 数组截取</h4>
<ol>
<li><code>arr.slice(开始位置, 结束位置)</code>：返回被截取的新数组</li>
</ol>
<h4 id="2-5-10-">2.5.10 转字符串</h4>
<ol>
<li><p>普通方法：遍历数组+字符串拼接</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]
var str = &#39;&#39;
var sep = &#39;*&#39;
for (var i = 0; i &lt; arr.length; i++) {
  str += arr[i] + sep
}
console.log(str)
</code></pre>
</li>
<li><p><code>arr.toString()</code>：默认用逗号分隔</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [1, 2, 3]
console.log(arr.toString()) // 1,2,3
</code></pre>
</li>
<li><p><code>arr.join(分隔符)</code>：自定义分隔符</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr1 = [&#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]
console.log(arr1.join()) // green,blue,pink
console.log(arr1.join(&#39;-&#39;)) // green-blue-pink
console.log(arr1.join(&#39;&amp;&#39;)) // green&amp;blue&amp;pink
</code></pre>
</li>
</ol>
<h4 id="2-5-11-">2.5.11 数组拼接</h4>
<ol>
<li><code>arr1.concat(arr2,arr3,...)</code>：返回一个新数组，不影响原数组，</li>
</ol>
<h4 id="2-5-12-">2.5.12 数组遍历</h4>
<ol>
<li><p>普通索引方法：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
for (var i = 0; i &lt; arr.length; i++) {
  console.log(arr[i])
  document.write(arr[i], &#39;,&#39;)
}
</code></pre>
</li>
<li><p><code>arr.forEach(function(value[,index][,array]){})</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [1, 2, 3]
var sum = 0
arr.forEach(function (value, index, array) {
  console.log(&#39;每个数组元素&#39; + value)
  console.log(&#39;每个数组元素的索引号&#39; + index)
  console.log(&#39;数组本身&#39; + array)
  sum += value
})
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 动态生成表格
setDate(data)
function setDate(mydata) {
  // 先清空原来tbody 里面的数据
  tbody.innerHTML = &#39;&#39;
  mydata.forEach(function (value) {
    var tr = document.createElement(&#39;tr&#39;)
    tr.innerHTML = &#39;&lt;td&gt;&#39; + value.id + &#39;&lt;/td&gt;&lt;td&gt;&#39; + value.pname + &#39;&lt;/td&gt;&lt;td&gt;&#39; + value.price + &#39;&lt;/td&gt;&#39;
    tbody.appendChild(tr)
  })
}
var data = [
  {
    id: 1,
    pname: &#39;小米&#39;,
    price: 3999,
  },
  {
    id: 2,
    pname: &#39;oppo&#39;,
    price: 999,
  },
  {
    id: 3,
    pname: &#39;荣耀&#39;,
    price: 1299,
  },
  {
    id: 4,
    pname: &#39;华为&#39;,
    price: 1999,
  },
]
</code></pre>
</li>
<li><p><code>arr.reduce(function(accumulator,currentValue[,index[,array]])[,initialValue])</code></p>
<p>1）参数：</p>
<ul>
<li>累计器：accumulator</li>
<li>当前值：currentValue</li>
<li>当前索引：index</li>
<li>源数组：array</li>
</ul>
<p>2）案例：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) =&gt; {
  accumulator + currentValue
})
</code></pre>
<p><img src="D:\MyProjects\Website\Tutoring\Web_Basic\Section4-JavaScript\src\遍历数组-reduce.png" alt="遍历数组-reduce"></p>
</li>
<li><p>案例：找出两个数组之间的补集（在currentArr但不在arr中的元素）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 方法一：
function arrMath(arr, currentArr) {
  var flag = false // 表示在arr数组中去匹配，匹配到就false，没有找到就是true
  var newArr = new Array() //存放筛选出来的元素
  for (var i = 0; i &lt; arr.length; i++) {
    for (var j = 0; j &lt; currentArr.length; j++) {
      if (arr[i] === currentArr[j]) {
        flag = false
        break //找到匹配的之后就不必继续匹配了
      } else {
        flag = true
      }
    }
    if (flag === true) {
      newArr[newArr.length] = arr[i]
    }
  }
  return newArr
}

// 方法二：
function arrMath(arr, currentArr) {
  for (var i = 0; i &lt; arr.length; i++) {
    for (var j = 0; j &lt; currentArr.length; j++) {
      if (arr[i] === currentArr[j]) {
        // 删除i位置的元素
        arr.splice(i, 1)
      }
    }
  }
  return arr
}
</code></pre>
</li>
</ol>
<h4 id="2-5-13-">2.5.13 数组筛选</h4>
<ol>
<li><p><code>arr.filter(function(value[,index][,array]){})</code></p>
<p>1）创建一个新数组，元素是通过检查指定数组中符合条件的所有元素，用于筛选数组，返回新数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [12, 66, 4, 88, 3, 7]
var newArr = arr.filter(function (value, index) {
  return value % 2 === 0
})
</code></pre>
<p>2）如果数组里面装的是一个个对象，可以按对象属性值筛选，返回数组中装的元素依然是符合条件的对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var newData = data.filter(function (value) {
  return value.price &gt;= 1000 &amp;&amp; value.price &lt;= 1500
})
var data = [
  {
    id: 1,
    pname: &#39;小米&#39;,
    price: 3999,
  },
  {
    id: 2,
    pname: &#39;oppo&#39;,
    price: 999,
  },
  {
    id: 3,
    pname: &#39;荣耀&#39;,
    price: 1299,
  },
  {
    id: 4,
    pname: &#39;华为&#39;,
    price: 1999,
  },
]
</code></pre>
</li>
<li><p><code>arr.some(function(value[,index][,array]){})</code></p>
<p>1）检测数组中的元素是否满足指定条件，查找数组中是否有满足条件的元素，返回布尔值，如果找到第一个满足条件的元素则终止循环</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [10, 30, 4]
var flag = arr.some(function (value) {
  return value &lt; 3    // false
})
console.log(flag)

var arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;]
var flag1 = arr1.some(function (value) {
  return value == &#39;pink&#39;
})
console.log(flag1)    // true
</code></pre>
<p>2）注意：如果在内部函数中写return，一定要跟true终止迭代，否则一直循环下去</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 查找数组中唯一对象，并返回该完整对象
var data = [
  {
    id: 1,
    pname: &#39;小米&#39;,
    price: 3999,
  },
  {
    id: 2,
    pname: &#39;oppo&#39;,
    price: 999,
  },
  {
    id: 3,
    pname: &#39;荣耀&#39;,
    price: 1299,
  },
  {
    id: 4,
    pname: &#39;华为&#39;,
    price: 1999,
  },
]
var arr = []
data.some(function (value) {
  if (value.pname === &#39;oppo&#39;) {
    arr.push(value)
    return true // return 后面必须写true
  }
})
console.log(arr)
</code></pre>
<p>3）区别：forEach、filter中的函数如果写return，不会终止迭代，而some会</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]
// forEach遍历
arr.forEach(function (value) {
  if (value == &#39;green&#39;) {
    console.log(&#39;找到了该元素&#39;)
    return true // forEach里面return true不会终止迭代
  }
  console.log(11)
})
// some遍历：适合查询数组中唯一的元素
arr.some(function (value) {
  if (value == &#39;green&#39;) {
    console.log(&#39;找到了该元素&#39;)
    return true // some里面return true就是终止遍历，迭代效率更高
  }
  console.log(11)
})
// filter筛选
arr.filter(function (value) {
  if (value == &#39;green&#39;) {
    console.log(&#39;找到了该元素&#39;)
    return true // filter里面return true不会终止迭代
  }
  console.log(11)
})
</code></pre>
</li>
</ol>
<h4 id="2-5-14-">2.5.14 数组去重</h4>
<ol>
<li><p>自定义去重函数：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function unique(arr) {
  var newArr = []
  for (var i = 0; i &lt; arr.length; i++) {
    if (newArr.indexOf(arr[i]) === -1) {
      newArr.push(arr[i])
    }
  }
  return newArr
}
var demo = unique([&#39;c&#39;, &#39;a&#39;, &#39;z&#39;, &#39;a&#39;, &#39;x&#39;, &#39;a&#39;, &#39;x&#39;, &#39;c&#39;, &#39;b&#39;])
console.log(demo)
</code></pre>
</li>
</ol>
<h4 id="2-5-14-">2.5.14 数组降维</h4>
<ol>
<li><p><code>array.flat(arg)</code>：用于将多维数组转化为低位数组，可选参数arg为“深度”，输入数字选择展开层级，默认1层。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//flat：将多维数组转化为低位数组
const arr = [1, 2, 3, 4, [5, 6]]
console.log(arr.flat())

const arr2 = [1, 2, 3, 4, [5, 6, [7, 8, 9]]]
console.log(arr2.flat())
console.log(arr2.flat(2))
</code></pre>
</li>
<li><p><code>array.flatMap(function(){...})</code>：相当于Map和flat的结合，可以把Map返回的多维数组降维，深度为1层。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// flatMap：相当于Map和flat的结合
const arr3 = [1, 2, 3, 4]
// 直接用map返回的是多维数组
const result = arr3.map((item) =&gt; [item * 10])
console.log(result)
// flatMap可以把多维数组降维
const result2 = arr3.flatMap((item) =&gt; [item * 10])
console.log(result2)
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-6-string">2.6 字符串 String</h3>
<ol>
<li>定义：属于基本包装类型，即JS把简单数据类型包装成为了复杂数据类型，使其具有了属性和方法</li>
<li>不可变性：里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开了一个空间，原数据依然存在，所以不要大量拼接字符串</li>
</ol>
<h4 id="2-6-1-">2.6.1 字符串索引</h4>
<ol>
<li><p>索引位</p>
<p>1）<code>str.indexOf(&#39;要查找的字符&#39;,[起始的位置])</code>，起始的位置可不填，如果未查找到结果，返回-1</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 统计字符串中某字符出现的次数
var str = &#39;oabcoefoxyozzopp&#39;
var index = str.indexOf(&#39;o&#39;)
var num = 0
while (index !== -1) {
  console.log(index)
  num++
  index = str.indexOf(&#39;o&#39;, index + 1)
}
console.log(&#39;o出现的次数是: &#39; + num)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 判断一个字符（比如”a”）是否出现在另一个字符（比如”2340sadfj2affa2”）中，如果出现，并求出现了几次
var str = &#39;2340sadfj2affa2&#39;
var n = str.indexOf(&#39;a&#39;)
if (n == -1) {
  alert(&#39;没出现&#39;)
} else {
  alert(&#39;出现了&#39;)
}
var count = 0
var arr = str.split(&#39;&#39;)
for (var i = 0; i &lt; arr.length; i++) {
  if (arr[i] == &#39;a&#39;) {
    count++
  }
}
document.write(&#39;出现了&#39; + count + &#39;次&#39;)
</code></pre>
<p>2）<code>str.lastIndexOf(&#39;要查找的字符&#39;,[起始的位置])</code>，起始的位置可不填，如果未查找到结果，返回-1</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 获取一个长文件路径中的文件名及其后缀
// 注意：字符串中的特殊字符需要使用反斜杠进行转义，比如“\”要写成“\\”，换行要写成“\n”，单引号要写成“ \’ ”，双引号要写成“ \” ”
var str = &#39;E:\\itcast\\class\\php\\js\\day2\\abc.html&#39;
var gang = str.lastIndexOf(&#39;\\&#39;)
var dian = str.lastIndexOf(&#39;.&#39;)
var ming = str.substring(gang + 1, dian)
var houzhui = str.substr(dian + 1)
document.write(&#39;文件名&#39; + ming + &#39;后缀&#39; + houzhui)
</code></pre>
<p>3）注意：所有字符串都包含空字符&#39;&#39;，且位置在最前面</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&#39;abc&#39;.indexOf(&#39;&#39;) // 结果：0
&#39;abc&#39;.lastIndexOf(&#39;&#39;) // 结果：3
</code></pre>
</li>
<li><p>索引值：</p>
<p>1）<code>str.charAt(index)</code>：返回指定位置的字符</p>
<p>2）<code>str.charCodeAt(index)</code>：返回相应索引号的字符ASCII值，目的是判断用户按下了哪个键（ASCII：American Standard Code for Information Interchange，美国标准信息交换代码）</p>
<p>3）<code>str[index]</code>：获取指定位置处的字符，H5新增</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// charAt(index)：根据位置返回字符
var str = &#39;andy&#39;
console.log(str.charAt(3))
// 遍历所有的字符
for (var i = 0; i &lt; str.length; i++) {
  console.log(str.charAt(i))
}
// charCodeAt(index)  返回相应索引号的字符ASCII值，目的：判断用户按下了那个键
console.log(str.charCodeAt(0)) // 97
// H5新增：str[index]
console.log(str[0]) // a
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 统计字符串中出现最多的字符和次数
var str = &#39;abcoefoxyozzopp&#39;
var o = {} // 声明一个空对象，用作字典储存每个字符串对应的出现次数
for (var i = 0; i &lt; str.length; i++) {
  var chars = str.charAt(i)
  if (o[chars]) {
    o[chars]++
  } else {
    o[chars] = 1
  }
}

var max = 0
var ch = &#39;&#39;
for (var k in o) {
  if (o[k] &gt; max) {
    max = o[k]
    ch = k
  }
}
console.log(max)
console.log(`最多的字符是${ch}，一共出现了${max}次`)
</code></pre>
</li>
</ol>
<h4 id="2-6-2-">2.6.2 字符串拼接</h4>
<ol>
<li><code>str.concat(str2,str3,...)</code></li>
</ol>
<h4 id="2-6-3-">2.6.3 截取字符串</h4>
<ol>
<li><p><code>str.substr(开始位置, 截取长度)</code>：如果不写截取长度，默认从开始位置一直截取到最后</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var str1 = &#39;改革春风吹满地&#39;
console.log(str1.substr(2)) // 春风吹满地
console.log(str1.substr(2, 2)) // 春风
</code></pre>
</li>
<li><p><code>str.slice(开始位置, 结束位置)</code></p>
</li>
<li><p><code>str.substring(开始位置, 结束位置)</code>：基本与slice相同，但不接受负数</p>
</li>
</ol>
<h4 id="2-6-4-">2.6.4 替换字符串</h4>
<ol>
<li><p><code>str.replace(&#39;被替换的字符&#39;,&#39;替换为的字符&#39; )</code></p>
<p>1）只会替换第一个字符</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var str = &#39;andyandy&#39;
console.log(str.replace(&#39;a&#39;, &#39;b&#39;))
</code></pre>
<p>2）若要全部替换，需配合while+indexOf使用，或用正则表达式</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var str1 = &#39;abcoefoxyozzopp&#39;
while (str1.indexOf(&#39;o&#39;) !== -1) {
  str1 = str1.replace(&#39;o&#39;, &#39;*&#39;)
}
console.log(str1)
</code></pre>
</li>
</ol>
<h4 id="2-6-5-">2.6.5 字符串转数组</h4>
<ol>
<li><p><code>str.split(&#39;字符串中的分隔符&#39;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">var str2 = &#39;red, pink, blue&#39;
console.log(str2.split(&#39;,&#39;))
var str3 = &#39;red&amp;pink&amp;blue&#39;
console.log(str3.split(&#39;&amp;&#39;))
</code></pre>
</li>
</ol>
<h4 id="2-6-6-">2.6.6 大小写转换</h4>
<ol>
<li><p>转换大写：<code>str.toUpperCase()</code></p>
</li>
<li><p>转为小写：<code>str.toLowerCase()</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 将用户输入的字符串翻转，并将首尾转换为大写，其余转为小写
var s1 = prompt(&#39;请输入任意字符&#39;, &#39;&#39;)
var arr = s1.split(&#39;&#39;) //转成数组
var newArr = arr.reverse() //翻转顺序保存给newArr=[&#39;c&#39;,&#39;b&#39;,&#39;a&#39;]
for (var i = 0; i &lt; newArr.length; i++) {
  if (i == 0 || i == newArr.length - 1) {
    newArr[i] = newArr[i].toUpperCase()
  } else {
    newArr[i] = newArr[i].toLowerCase()
  }
}
var str = newArr.join(&#39;&#39;)
alert(str)
</code></pre>
</li>
</ol>
<h4 id="2-6-7-">2.6.7 去除空白字符</h4>
<ol>
<li><p><code>str.trim()</code>：去除两端空白字符，不影响字符串本身，返回一个新字符串</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;!--案例：输入框自动去除两端空格（无法去除中间空格）--&gt;
&lt;input type=&quot;text&quot; /&gt; &lt;button&gt;点击&lt;/button&gt;
&lt;script&gt;
  var input = document.querySelector(&#39;input&#39;)
  var btn = document.querySelector(&#39;button&#39;)
  var div = document.querySelector(&#39;div&#39;)
  btn.onclick = function () {
    var str = input.value.trim()
    if (str === &#39;&#39;) {
      alert(&#39;请输入内容&#39;)
    } else {
      console.log(str)
      console.log(str.length)
      div.innerHTML = str
    }
  }
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>str.trimStart()</code>、<code>str.trimEnd()</code>：trimStart用于删除字符串左侧的空格，trimEnd用于删除字符串右侧的空格。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// trim
let str = &#39;   iloveyou   &#39;
console.log(str.trimStart())  // &#39;iloveyou   &#39;
console.log(str.trimEnd())    // &#39;   iloveyou&#39;
</code></pre>
</li>
</ol>
<h4 id="2-6-8-">2.6.8 模板字符串</h4>
<ol>
<li><p>定义：是增强版的字符串，用反引号（`）标识</p>
</li>
<li><p>特点：</p>
<p>1）字符串中可以出现换行符</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let str = `&lt;ul&gt;
              &lt;li&gt;沈腾&lt;/li&gt;
              &lt;li&gt;玛丽&lt;/li&gt;
              &lt;li&gt;魏翔&lt;/li&gt;
              &lt;li&gt;艾伦&lt;/li&gt;
          &lt;/ul&gt;`
</code></pre>
<p>2）可以使用 ${xxx} 形式输出变量</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let lovest = &#39;魏翔&#39;
let out = `${lovest}是我心目中最搞笑的演员!!`
console.log(out)
</code></pre>
</li>
<li><p>注意：当遇到字符串与变量拼接的情况使用模板字符串</p>
</li>
</ol>
<h4 id="2-6-9-">2.6.9 匹配字符串</h4>
<ol>
<li><p>str.matchAll(regObj)：用来得到正则表达式批量匹配的结果</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let str = `&lt;ul&gt;
      &lt;li&gt;
          &lt;a&gt;肖生克的救赎&lt;/a&gt;
          &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
          &lt;a&gt;阿甘正传&lt;/a&gt;
          &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;
      &lt;/li&gt;
  &lt;/ul&gt;`
//声明正则
const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs
//调用方法
const result = str.matchAll(reg)

// 方法1：for of遍历
/* for (let v of result) {
  console.log(v)
} */

// 方法2：扩展字符串展开
const arr = [...result]
console.log(arr)
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-7-function">2.7 函数 Function</h3>
<h4 id="2-7-1-">2.7.1 声明函数</h4>
<ol>
<li><p>函数关键字（命名函数）：<code>function 函数名(形参1,形参2,...) {函数体 return...}</code>，函数体换行用分号<code>；</code>隔开</p>
</li>
<li><p>函数表达式（匿名函数）：<code>var 变量名 = function(形参1,形参2,...) {函数体 return...}</code>，调用时用<code>变量名()</code></p>
</li>
<li><p>利用<code>Function()构造函数</code>来定义函数：</p>
<p>1）语法：<code>var f = new Function(&#39;参数1&#39;,&#39;参数2&#39;, ..., &#39;函数体&#39;)</code>，注意：里面要用字符串的格式写</p>
<p>2）所有函数都是Function的实例对象</p>
<p>3）函数也属于对象：<code>f instanceof Object</code></p>
<p><img src="D:\MyProjects\Website\Tutoring\Web_Basic\Section4-JavaScript\src\Function构造函数.png" alt="Function构造函数"></p>
</li>
</ol>
<hr>
<h4 id="2-7-2-">2.7.2 函数参数</h4>
<h5 id="2-7-2-1-">2.7.2.1 形参与实参</h5>
<ol>
<li><p>形参与实参不匹配：</p>
<p>1）如果实参的个数多于形参的个数，会取到形参的个数 </p>
<p>2）如果实参的个数小于形参的个数，多余的形参定义为undefined，最终输出的结果是 NaN</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function getSum(num1, num2) {
  console.log(num1 + num2)
}
// 如果实参的个数和形参的个数一致 则正常输出结果
getSum(1, 3)     // 4
// 如果实参的个数多于形参的个数，会取到形参的个数
getSum(1, 2, 3)     // 3
// 如果实参的个数小于形参的个数，多于的形参定义为undefined，最终的结果就是 NaN
getSum(1)          // NaN
</code></pre>
</li>
</ol>
<h5 id="2-7-2-2-arguments-">2.7.2.2 arguments对象</h5>
<ol>
<li><p>arguments存储了传递的所有实参</p>
</li>
<li><p>形式：伪数组 Arguments(x)</p>
<p>1）可用<code>arguments[i]</code>调用</p>
<p>2）有<code>length</code>属性</p>
<p>3）没有<code>pop()</code>、<code>push()</code>方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 只有函数才有 arguments对象，而且是每个函数都内置好了这个arguments
function fn() {
  console.log(arguments)         // 里面存储了所有传递过来的实参，arguments = [1,2,3]（伪数组：Arguments(3)）
  console.log(arguments.length)
  console.log(arguments[2])
  // 可以按照数组的方式遍历arguments
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i])
  }
}
fn(1, 2, 3)
fn(1, 2, 3, 4, 5)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 只有函数才有 arguments对象，而且是每个函数都内置好了这个arguments
function fn() {
  console.log(arguments)         // 里面存储了所有传递过来的实参，arguments = [1,2,3]（伪数组：Arguments(3)）
  console.log(arguments.length)
  console.log(arguments[2])
  // 可以按照数组的方式遍历arguments
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(arguments[i])
  }
}
fn(1, 2, 3)
fn(1, 2, 3, 4, 5)
</code></pre>
</li>
</ol>
<h5 id="2-7-2-3-">2.7.2.3 函数参数默认值</h5>
<ol>
<li><p>定义：ES6允许给函数参数赋值初始值</p>
</li>
<li><p>形参初始值：具有默认值的参数，一般位置要靠后(潜规则)</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function add(a, b, c = 10) {
  return a + b + c
}
let result = add(1, 2)
console.log(result)
</code></pre>
</li>
<li><p>与解构赋值结合</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function connect({ host = &#39;127.0.0.1&#39;, username, password, port }) {
  console.log(host)
  console.log(username)
  console.log(password)
  console.log(port)
}
connect({
  host: &#39;atguigu.com&#39;,
  username: &#39;root&#39;,
  password: &#39;root&#39;,
  port: 3306,
})
</code></pre>
</li>
</ol>
<h5 id="2-7-2-4-rest-">2.7.2.4 rest参数</h5>
<ol>
<li><p>形式：<code>...args</code></p>
</li>
<li><p>作用：用于获取函数的实参，用来代替 arguments</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function date(...args) {console.log(args)}
</code></pre>
</li>
<li><p>注意：rest 参数必须要放到参数最后</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function fn(a,b,...args){...}
</code></pre>
</li>
<li><p>返回：数组Array</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// rest参数
function connect({ host, port, ...user }) {
  console.log(host)
  console.log(port)
  console.log(user)
}
// username、password、type都会存到user对象中
connect({
  host: &#39;127.0.0.1&#39;,
  port: 3306,
  username: &#39;root&#39;,
  password: &#39;root&#39;,
  type: &#39;master&#39;,
})
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-3-">2.7.3 函数返回结果</h4>
<ol>
<li><p>终止函数：函数中return后面的语句不会被执行</p>
</li>
<li><p>return只能返回一个值，想返回多个值用数组存储</p>
</li>
<li><p>如果没有return，函数返回的值是undefined</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// return 终止函数
function getSum(num1, num2) {
  return num1 + num2 // return 后面的代码不会被执行
  alert(&#39;我是不会被执行的哦！&#39;)
}
console.log(getSum(1, 2))

// return 只能返回一个值
function fn(num1, num2) {
  return num1, num2 // 返回的结果是最后一个值
}
console.log(fn(1, 2))

// 想返回多个值用数组存储：求任意两个数的加减乘数结果
function getResult(num1, num2) {
  return [num1 + num2, num1 - num2, num1 * num2, num1 / num2]
}
var re = getResult(1, 2) // 返回的是一个数组
console.log(re)

// 函数如果有return，则返回的是 return 后面的值，如果函数没有 return，则返回 undefined
function fun1() {
  return 666
}
console.log(fun1()) // 返回 666
function fun2() {}
console.log(fun2()) // 函数返回的结果是 undefined
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-4-">2.7.4 函数的调用</h4>
<ol>
<li><p>普通函数：<code>function fn(){}</code></p>
<p>1）直接调用：fn()</p>
<p>2）call()调用：fn.call()</p>
<p>3）this指向：window（正常调用的完整写法是：window.fn()）</p>
</li>
<li><p>对象中的方法：<code>var obj = {fun: function(){}}</code></p>
<p>1）调用：obj.fun()
2）this指向：obj</p>
</li>
<li><p>构造函数：<code>function Star(){}</code></p>
<p>1）调用：var ldh = new Star()</p>
<p>2）this指向：实例对象ldh（原型对象中的this也指向ldh）</p>
</li>
<li><p>绑定事件函数：<code>btn.onclick = function(){}</code></p>
<p>1）点击按钮调用</p>
<p>2）this指向：btn</p>
</li>
<li><p>定时器函数：<code>setInterval(function(){}, 1000)</code>
1）自动1秒钟调用一次</p>
<p>2)this指向：window（正常调用的完整写法是：window.setInterval()）</p>
</li>
<li><p>立即执行函数：<code>(function(){})()</code></p>
<p>1）自动调用</p>
<p>2）this指向：window</p>
</li>
</ol>
<hr>
<h4 id="2-7-5-this-">2.7.5 改变this指向</h4>
<ol>
<li><p>call()：<code>function.call(thisArg,arg1,arg2 ...)</code>，thisArg：当前调用函数this的指向对象</p>
<p>1）用法：调用函数：有函数fun(x,y){...}，正常可以用fun()调用，也可以用fun.call()调用</p>
<p>2）改变函数指向：<code>var o = {...}, fun.call (o, x, y)</code>, 此时fun中的this指向了对象o</p>
</li>
<li><p>apply()：<code>function.apply(thisArg,[argsArray])</code></p>
<p>1）参数：</p>
<ul>
<li>thisArg：当前调用函数this的指向对象</li>
<li>argsArray：传递的值，必须包含在【数组】里</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">var o = {
  name: &#39;andy&#39;,
}
function fn(arr) {
  console.log(this)    // 对象o：{name: &#39;andy&#39;}
  console.log(arr)  // pink
}
fn.apply(o, [&#39;pink&#39;])
</code></pre>
<p>2）应用：数组求最大最小值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var arr = [1, 66, 3, 99, 4]
var max = Math.max.apply(Math, arr)
var min = Math.min.apply(Math, arr)
</code></pre>
</li>
<li><p>bind()：<code>function.bind(thisArg,arg1,arg2,...)</code>，thisArg：当前调用函数this的指向对象</p>
<p>1）作用：如果有的函数不需要立即调用，但是又想改变这个函数内部的this指向，此时用bind</p>
<p>2）返回：由指定的this值和初始化参数改造的原函数拷贝（新函数）</p>
<p>3）注意：不会调用原来的函数，需要手动调用新函数才会执行</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var o = {
  name: &#39;andy&#39;,
}
function fn(a, b) {
  console.log(this)
  console.log(a + b)
}
var f = fn.bind(o, 1, 2)
f()    // {name: &#39;andy&#39;}, 3
</code></pre>
<p>4）案例1：点击按钮后禁用，3秒钟后恢复正常</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 难点：在定时器中如果想用 this.disabled = false 是无法做到的，因为定时器函数中的this指向windows

// 方法1：在btn事件函数中声明 var that = this，再令定时器中的 that.disabled = false
var btn1 = document.querySelector(&#39;button&#39;)
btn1.onclick = function () {
  this.disabled = true // 这个this 指向的是 btn 这个按钮
  var that = this
  setTimeout(function () {
    that.disabled = false
  }, 3000)
}

// 方法2：在定时器函数后用bind(this)即可改变this指向
var btn1 = document.querySelector(&#39;button&#39;)
btn1.onclick = function () {
  this.disabled = true
  setTimeout(
    function () {
      this.disabled = false // 此时定时器函数里面的this指向的是btn
    }.bind(this),             // 这个this指向的是btn
    3000
  )
}
</code></pre>
<p>5）案例2：Tab栏增删改内容完善（不需要在外部声明that，直接内部修改this指向即可）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;tabsbox&quot; id=&quot;tab&quot;&gt;
  &lt;!-- tab 标签 --&gt;
  &lt;nav class=&quot;fisrstnav&quot;&gt;
    &lt;ul&gt;
      &lt;li class=&quot;liactive&quot;&gt;
        &lt;span&gt;测试1&lt;/span&gt;
        &lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;span&gt;测试2&lt;/span&gt;
        &lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;span&gt;测试3&lt;/span&gt;
        &lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;div class=&quot;tabadd&quot;&gt;
      &lt;span&gt;+&lt;/span&gt;
    &lt;/div&gt;
  &lt;/nav&gt;
  &lt;!-- tab 内容 --&gt;
  &lt;div class=&quot;tabscon&quot;&gt;
    &lt;section class=&quot;conactive&quot;&gt;测试1&lt;/section&gt;
    &lt;section&gt;测试2&lt;/section&gt;
    &lt;section&gt;测试3&lt;/section&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">class Tab {
  constructor(id) {
    // 获取元素
    this.main = document.querySelector(id)
    this.add = this.main.querySelector(&#39;.tabadd&#39;)
    // li的父元素
    this.ul = this.main.querySelector(&#39;.fisrstnav ul:first-child&#39;)
    // section 父元素
    this.fsection = this.main.querySelector(&#39;.tabscon&#39;)
    this.init()
  }
  init() {
    this.updateNode()
    // init 初始化操作让相关的元素绑定事件
    this.add.onclick = this.addTab.bind(this.add, this)
    for (var i = 0; i &lt; this.lis.length; i++) {
      this.lis[i].index = i
      this.lis[i].onclick = this.toggleTab.bind(this.lis[i], this)
      this.remove[i].onclick = this.removeTab.bind(this.remove[i], this)
      this.spans[i].ondblclick = this.editTab
      this.sections[i].ondblclick = this.editTab
    }
  }
  // 因为我们动态添加元素 需要从新获取对应的元素
  updateNode() {
    this.lis = this.main.querySelectorAll(&#39;li&#39;)
    this.sections = this.main.querySelectorAll(&#39;section&#39;)
    this.remove = this.main.querySelectorAll(&#39;.icon-guanbi&#39;)
    this.spans = this.main.querySelectorAll(&#39;.fisrstnav li span:first-child&#39;)
  }
  // 1. 切换功能
  // 这里的that，只是一个形参
  toggleTab(that) {
    that.clearClass()
    this.className = &#39;liactive&#39;
    that.sections[this.index].className = &#39;conactive&#39;
  }
  // 清除所有li和section的类
  clearClass() {
    for (var i = 0; i &lt; this.lis.length; i++) {
      this.lis[i].className = &#39;&#39;
      this.sections[i].className = &#39;&#39;
    }
  }
  // 2. 添加功能
  addTab(that) {
    that.clearClass()
    // (1) 创建li元素和section元素
    var random = Math.random()
    var li = &#39;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#39;
    var section = &#39;&lt;section class=&quot;conactive&quot;&gt;测试 &#39; + random + &#39;&lt;/section&gt;&#39;
    // (2) 把这两个元素追加到对应的父元素里面
    that.ul.insertAdjacentHTML(&#39;beforeend&#39;, li)
    that.fsection.insertAdjacentHTML(&#39;beforeend&#39;, section)
    that.init()
  }
  // 3. 删除功能
  removeTab(that, e) {
    e.stopPropagation() // 阻止冒泡 防止触发li 的切换点击事件
    var index = this.parentNode.index
    console.log(index)
    // 根据索引号删除对应的li和section，remove()方法可以直接删除指定的元素
    that.lis[index].remove()
    that.sections[index].remove()
    that.init()
    // 当我们删除的不是选中状态的li的时候，原来的选中状态li保持不变
    if (document.querySelector(&#39;.liactive&#39;)) return
    // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态
    index--
    // 手动调用我们的点击事件  不需要鼠标触发
    that.lis[index] &amp;&amp; that.lis[index].click()
  }
  // 4. 修改功能
  editTab() {
    var str = this.innerHTML
    // 双击禁止选定文字
    window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty()
    this.innerHTML = &#39;&lt;input type=&quot;text&quot; /&gt;&#39;
    var input = this.children[0]
    input.value = str
    input.select() // 文本框里面的文字处于选定状态
    // 当我们离开文本框就把文本框里面的值给span
    input.onblur = function () {
      this.parentNode.innerHTML = this.value
    }
    // 按下回车也可以把文本框里面的值给span
    input.onkeyup = function (e) {
      if (e.keyCode === 13) {
        // 手动调用表单失去焦点事件  不需要鼠标离开操作
        this.blur()
      }
    }
  }
}
new Tab(&#39;#tab&#39;)
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-6-">2.7.6 严格模式</h4>
<ol>
<li><p>定义：ES5的严格模式(Strict Mode)是采用具有限制性JS变体的一种方式，即在严格的条件下运行JS代码</p>
</li>
<li><p>兼容性：IE10+支持，旧版本浏览器会忽略</p>
</li>
<li><p>作用：</p>
<p>1）消除了JS语法不合理、不安全之处，提高编译器效率</p>
<p>2）禁用了ES未来版本可能会定义的一些语法，为未来版本JS做好铺垫，某些保留关键字不能用作变量名</p>
</li>
<li><p>语法：</p>
<p>1）为整个脚本(script标签)开启严格模式</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--方法1--&gt;
&lt;script&gt; &#39;use strict&#39;; ...&lt;/script&gt;
&lt;!--方法2--&gt;
&lt;script&gt;(function(){&#39;use strict&#39;; ...})()&lt;/script&gt;
</code></pre>
<p>2）为某个函数开启严格模式</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function fn() {&#39;use strict&#39;; ...}
</code></pre>
</li>
<li><p>特性：</p>
<p>1）变量名必须先声明再使用</p>
<p>2）不能随意删除已经声明好的变量</p>
<p>3）全局作用域中函数中的 this 是 undefined</p>
<p>4）如果构造函数不加new调用, this 指向的是undefined，如果给 this.属性 赋值则会报错</p>
<p>5）定时器 this 还是指向 window</p>
<p>6）严格模式下函数里面的参数不允许有重名</p>
</li>
</ol>
<hr>
<h4 id="2-7-7-">2.7.7 高阶函数</h4>
<ol>
<li><p>定义：对其他函数进行操作的函数，接收函数作为参数，或将函数作为返回值输出</p>
</li>
<li><p>接收函数作为参数：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function fn(callback) {
  callback &amp;&amp; callback()
}
fn(function () {
  alert(&#39;hi&#39;)
})
</code></pre>
</li>
<li><p>将函数作为返回值输出：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function fn() {
  return function () {}
}
fn()
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-8-closure">2.7.8 闭包 Closure</h4>
<ol>
<li><p>定义：指有权访问另一个函数作用域中变量的【函数】（注：本质上是函数）</p>
</li>
<li><p>浏览器检查：F12-来源(source)-代码打断点刷新逐步运行-作用域(scope)，可以看到闭包(fn)</p>
</li>
<li><p>作用：延伸了变量的作用范围</p>
</li>
<li><p>案例：</p>
<p>1）案例1：点击li输出索引号</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 传统方法
var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;)
for (var i = 0; i &lt; lis.length; i++) {
  lis[i].index = i
  lis[i].onclick = function () {
    console.log(this.index)
  }
}
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 闭包方法
for (var i = 0; i &lt; lis.length; i++) {
  // 利用for循环创建了4个立即执行函数
  // 立即执行函数也称为小闭包，因为立即执行函数里面的任何一个函数都可以使用它的i这个变量
  (function (i) {
    lis[i].onclick = function () {
      console.log(i)
   }
  })(i)
}
</code></pre>
<p>2）案例2：定时器中的闭包（外面的for循环是同步任务，里面的定时器是异步任务，会产生冲突，需要立即执行函数包裹进去解决问题）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 3秒钟之后,打印所有li元素的内容
var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;)
for (var i = 0; i &lt; lis.length; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(lis[i].innerHTML)
   }, 3000)
  })(i)
}
</code></pre>
<p>3）案例3：打车价格</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 打车起步价13(3公里内)，之后每多一公里增加5块钱，用户输入公里数就可以计算打车价格
// 如果有拥堵情况，总价格多收取10块钱拥堵费
var car = (function () {
  var start = 13 // 起步价：局部变量
  var total = 0  // 总价：局部变量
  return {
    // 正常的总价
    price: function (n) {
      if (n &lt;= 3) {
        total = start
      } else {
        total = start + (n - 3) * 5
      }
      return total
    },
    // 拥堵之后的费用
    yd: function (flag) {
      return flag ? total + 10 : total
    },
  }
})()
console.log(car.price(5)) // 23
console.log(car.yd(true)) // 33
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-9-">2.7.9 递归函数</h4>
<ol>
<li><p>定义：如果一个函数在内部可以调用其本身，这个函数为递归函数</p>
</li>
<li><p>注意：递归里面必须加退出条件，但如果是有限循环的话就不用加</p>
</li>
<li><p>案例：</p>
<p>1）求阶乘</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n
function fn(n) {
  if (n == 1) {
    return 1
  }
  return n * fn(n - 1)
}
console.log(fn(3))
</code></pre>
<p>2）斐波那契数列</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21...
// 用户输入一个数字n就可以求出这个数字对应的兔子序列值
// 只需要知道用户输入的n的前面两项(n-1 n-2)就可以计算出n对应的序列值
function fb(n) {
  if (n === 1 || n === 2) {
    return 1
  }
  return fb(n - 1) + fb(n - 2)
}
console.log(fb(3))
</code></pre>
<p>3）深度嵌套数据查找</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 输入id号，就可以返回数据对象
var data = [
  {
    id: 1,
    name: &#39;家电&#39;,
    goods: [
      {
        id: 11,
        gname: &#39;冰箱&#39;,
        goods: [
          {
            id: 111,
            gname: &#39;海尔&#39;,
          },
          {
            id: 112,
            gname: &#39;美的&#39;,
          },
        ],
      },
      {
        id: 12,
        gname: &#39;洗衣机&#39;,
      },
    ],
  },
  {
    id: 2,
    name: &#39;服饰&#39;,
  },
]
// 1. 用forEach遍历里面的每一个对象
function getID(json, id) {
  var o = {}
  json.forEach(function (item) {
    if (item.id == id) {
      o = item
      // 2. 里层的数据可以利用递归函数，里面应该有goods这个数组且长度不为0
    } else if (item.goods &amp;&amp; item.goods.length &gt; 0) {
      o = getID(item.goods, id)
    }
  })
  return o
}
console.log(getID(data, 1))
console.log(getID(data, 2))
console.log(getID(data, 11))
console.log(getID(data, 12))
console.log(getID(data, 111))
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-10-">2.7.10 深浅拷贝</h4>
<h5 id="2-7-10-1-">2.7.10.1 浅拷贝</h5>
<ol>
<li><p>定义：只是拷贝一层，更深层次对象级别的只拷贝引用，修改拷贝对象会影响原对象</p>
</li>
<li><p>方法1：用for循环拷贝对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var obj = {
  id: 1,
  name: &#39;andy&#39;,
  msg: {
    age: 18,
  },
}
var o = {}
for (var k in obj) {
  o[k] = obj[k]
}
console.log(o)            // {id: 1,name: &#39;andy&#39;,msg: {age: 18,},}
o.msg.age = 20
console.log(obj)        // 原对象也跟随改变：{id: 1,name: &#39;andy&#39;,msg: {age: 18}}
</code></pre>
</li>
<li><p>方法2：<code>Object.assign（拷贝对象，原对象）</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">var obj = {
  id: 1,
  name: &#39;andy&#39;,
  msg: {
    age: 18,
  },
}
var o = {}
Object.assign(o, obj)
console.log(o)            // {id: 1,name: &#39;andy&#39;,msg: {age: 18,},}
o.msg.age = 20
console.log(obj)        // 原对象也跟随改变：{id: 1,name: &#39;andy&#39;,msg: {age: 18}}
</code></pre>
</li>
</ol>
<h5 id="2-7-10-2-">2.7.10.2 深拷贝</h5>
<ol>
<li><p>定义：拷贝多层，每一级别的数据都会拷贝</p>
</li>
<li><p>方法：利用递归函数进行深度拷贝，if 判断数据类型（注意：判断数据类型时，要先筛出数组，因为array即是Object也是Array）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function deepCopy(newobj, oldobj) {
  for (var k in oldobj) {
    // 判断属性值属于那种数据类型
    // 1. 获取属性值：oldobj[k]
    var item = oldobj[k]
    // 2. 判断这个值是否是数组
    if (item instanceof Array) {
      newobj[k] = []
      deepCopy(newobj[k], item)
    } else if (item instanceof Object) {
      // 3. 判断这个值是否是对象
      newobj[k] = {}
      deepCopy(newobj[k], item)
    } else {
      // 4. 属于简单数据类型
      newobj[k] = item
    }
  }
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-7-11-">2.7.11 箭头函数</h4>
<ol>
<li><p>定义：使用「箭头」（=&gt;）定义函数</p>
</li>
<li><p>语法：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let fn = (arg1, arg2, arg3) =&gt; { return arg1 + arg2 + arg3;}
</code></pre>
</li>
<li><p>特点：</p>
<p>1）this是静态的：this始终指向函数声明时所在作用域下的this的值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function getName() {
  console.log(this.name)
}
let getName2 = () =&gt; {
  console.log(this.name)
}
//设置 window 对象的 name 属性
window.name = &#39;尚硅谷&#39;
const school = {
  name: &#39;ATGUIGU&#39;,
}
// 直接调用：window.name &#39;尚硅谷&#39;
getName()
getName2()

// call 方法调用：school.name &#39;ATGUIGU&#39;
getName.call(school)
getName2.call(school)
</code></pre>
<p>2）不能作为构造函数实例化</p>
<pre class="prettyprint linenums:0"><code class="lang-js">  let Person = (name, age) =&gt; {
    this.name = name
    this.age = age
  }
  let me = new Person(&#39;xiao&#39;, 30)
  console.log(me)

  // 提示：会报错，Person is not a constructor
</code></pre>
<p>3）不能使用 arguments变量：在普通函数中，arguments变量是用来储存实参的</p>
<pre class="prettyprint linenums:0"><code class="lang-js">  let fn = () =&gt; {
    console.log(arguments)
  }
  fn(1, 2, 3)

  // 对比
  let fn = function () {
    console.log(arguments)
  }
  fn(1, 2, 3)
</code></pre>
<p>4）箭头函数的简写</p>
<pre class="prettyprint linenums:0"><code class="lang-js">  // 省略小括号：当形参有且只有一个的时候
  let add = n =&gt; {
    return n + n
  }
  console.log(add(9))

  // 省略花括号：函数体只有一条语句，函数的返回值为该条语句的执行结果
  let pow = n =&gt; n * n
  console.log(pow(8))
</code></pre>
</li>
<li><p>应用场景：</p>
<p>1）箭头函数适合 this无关的回调：定时器、数组的方法回调</p>
<p>2）箭头函数不适合与 this 有关的回调：事件回调、对象的方法</p>
</li>
<li><p>案例1：事件回调函数中的定时器：setTimeout</p>
<p>1）普通函数：绑定事件后，回调函数内必须先保存this，否则定时器内的回调函数this指向的是windows</p>
<pre class="prettyprint linenums:0"><code class="lang-js">ad.addEventListener(&#39;click&#39;, function () {
  //保存 this 的值
  let _this = this
  //定时器
  setTimeout(function () {
    //修改背景颜色 this
    _this.style.background = &#39;pink&#39;
  }, 2000)
})
</code></pre>
<p>2）箭头函数：定时器内的回调函数使用箭头函数，this依然指向事件函数中的this</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 因为this始终指向函数声明时所在作用域下的this的值
// setTimeout函数是在事件函数内部定义的
ad.addEventListener(&#39;click&#39;, function () {
  //定时器
  setTimeout(() =&gt; {
    this.style.background = &#39;pink&#39;
  }, 2000)
</code></pre>
</li>
<li><p>案例2：数组筛选：arr.filter(function(){...})</p>
<p>1）普通函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const arr = [1, 6, 9, 10, 100, 25]
const result = arr.filter(function (item) {
  if (item % 2 === 0) {
    return true
  } else {
    return false
  }
})
console.log(result)
</code></pre>
<p>2）箭头函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 一般写法
const arr = [1, 6, 9, 10, 100, 25]
const result = arr.filter((item) =&gt; {
  if (item % 2 === 0) {
    return true
  } else {
    return false
  }
})
console.log(result)

// 精简写法
const arr = [1, 6, 9, 10, 100, 25]
const result = arr.filter((item) =&gt; item % 2 === 0)
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-8-">2.8 作用域</h3>
<ol>
<li><p>定义：变量在某个范围内起作用和效果，为了提高程序的可靠性，减少命名冲突</p>
</li>
<li><p>分类：</p>
<p>1）全局作用域：整个script标签，或者是一个单独的js文件</p>
<p>2）局部作用域：在函数内部就是局部作用域</p>
<p>3）块级作用域（ES6）：在函数内部用<code>let</code>或<code>const</code>定义变量</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 外面的是不能调用num的
if (3 &lt; 5) {
  let num = 10    // 如果是var，外面就可以调用了
}
console.log(num)
</code></pre>
</li>
<li><p>变量作用域：</p>
<p>1）全局变量：全局作用域下的变量，在全局下都可以使用；只有浏览器关闭的时候才会销毁，比较占内存资源</p>
<ul>
<li>如果在函数内部，没有声明直接赋值的变量也属于全局变量</li>
<li>没有声明即无var，直接令x=a，例：foo() {var a = 1; b = 2;}，b为全局变量</li>
</ul>
<p>2）局部变量：在局部作用域下的变量，在函数内部的变量就是局部变量</p>
<ul>
<li>函数的形参也可以看做是局部变量</li>
<li>当程序执行完毕就会销毁，比较节约内存资源</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">// 全局变量：在全局作用域下的变量，在全局下都可以使用
// 注意：如果在函数内部 没有声明直接赋值的变量也属于全局变量
var num = 10 // num就是一个全局变量
console.log(num)
function fn() {
  console.log(num)
}
fn()

// 局部变量：在局部作用域下的变量，后者在函数内部的变量就是局部变量
// 注意：函数的形参也可以看做是局部变量
function fun(aru) {
  var num1 = 10     // num1就是局部变量 只能在函数内部使用
  num2 = 20
}
fun()
console.log(num1)     // Uncaught ReferenceError: num1 is not defined
console.log(num2)     // 20
</code></pre>
</li>
<li><p>作用域链：</p>
<p>1）就近原则：内部函数访问外部函数的变量，采取的是链式查找的方式来决定取那个值</p>
<p>2）例：全局变量num=10，函数内局部变量num=20，内部函数调用num，取的是20</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 案例1：结果是0
function f1() {
  var num = 123
  function f2() {
    var num = 0
    console.log(num) // 0
  }
  f2()
}
var num = 456
f1()

// 案例2：结果是4、22
var a = 1
function fn1() {
  var a = 2
  var b = &#39;22&#39;
  fn2()
  function fn2() {
    var a = 3
    fn3()
    function fn3() {
      var a = 4
      console.log(a) // 4
      console.log(b) // 22
    }
  }
}
fn1()
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-9-">2.9 预解析</h3>
<ol>
<li><p>预解析</p>
<p>1）原理：把js里面所有的 var 和 function 提升到当前作用域的最前面</p>
<p>2）变量提升：把所有的变量声明提升到当前的作用域最前面，不提升赋值操作</p>
<p>3）函数提升：把所有的函数声明提升到当前作用域的最前面 ，不调用函数</p>
</li>
<li><p>代码执行：按书写顺序从上到下执行</p>
</li>
<li><p>案例：</p>
<p>1）先调用变量但后赋值，输出结果为undefined</p>
<p>2）先用变量名调用匿名函数后定义函数，提示报错</p>
<p>3）先调用命名函数但后定义函数，可以成功运行</p>
</li>
<li><p>经典案例：</p>
<p>1）var a = b = c = 9; 仅有a是局部变量，b、c都是直接赋值，为全局变量</p>
<p>2）想同时赋值多个变量，要用逗号隔开：var a = 9, b = 9, c =9;</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 原始代码（命名函数）
f1()
console.log(c)
console.log(b)
console.log(a)
function f1() {
  var a = (b = c = 9)
  console.log(a)
  console.log(b)
  console.log(c)
}

// 预解析后
function f1() {
  var a
  a = b = c = 9
  console.log(a) // 9
  console.log(b) // 9
  console.log(c) // 9
}
f1()
console.log(c) // 9
console.log(b) // 9
console.log(a) // undefined
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-10-obejct">2.10 对象 Obejct</h3>
<blockquote>
<p>对象是一组无序的相关属性和方法的集合，所有事物都是对象，如字符串、数值、数组、函数等。</p>
</blockquote>
<h4 id="2-10-1-">2.10.1 创建对象</h4>
<h5 id="2-10-1-1-">2.10.1.1 字面量法</h5>
<ol>
<li><p>传统写法：<code>var 对象名 = {key1：value1，key2：value2，key3：function(){}....}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">var obj = {
  uname: &#39;张三疯&#39;,
  age: 18,
  sex: &#39;男&#39;,
  sayHi: function () {
    console.log(&#39;hi~&#39;)
  },
}
</code></pre>
</li>
<li><p>简化对象写法：在大括号里面直接写入变量和函数，作为对象的属性和方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let name = &#39;尚硅谷&#39;
let change = function () {
  console.log(&#39;我们可以改变你!!&#39;)
}
const school = {
  name,
  change,
  improve() {
    console.log(&#39;我们可以提高你的技能&#39;)
  },
}
</code></pre>
</li>
</ol>
<h5 id="2-10-1-2-new-">2.10.1.2 new关键字</h5>
<ol>
<li><p>语法：<code>var 对象名 = new Object()</code></p>
</li>
<li><p>定义属性：<code>对象名.属性名 = 属性</code></p>
</li>
<li><p>定义方法：<code>对象名.方法名 = function() {...}</code></p>
</li>
<li><p>new关键字执行过程</p>
<p>1）new 构造函数可以在内存中创建了一个空的对象</p>
<p>2）this 就会指向刚才创建的空对象</p>
<p>3）执行构造函数里面的代码 给这个空对象添加属性和方法</p>
<p>5）返回这个对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var obj = new Object()
obj.uname = &#39;张三疯&#39;
obj.age = 18
obj.sex = &#39;男&#39;
obj.sayHi = function () {
  console.log(&#39;hi~&#39;)
}
</code></pre>
</li>
</ol>
<h5 id="2-10-1-3-">2.10.1.3 构造函数</h5>
<ol>
<li><p>定义：如果需要重复引用同一个对象进行定义，可以利用函数的方法重复相同的代码，称为构造函数</p>
</li>
<li><p>目前大多数浏览器的JS是ES5版本，少部分高版本浏览器支持ES6；ES5中的对象不是基于类创建的，而是基于构造函数创建的</p>
</li>
<li><p>缺点：存在浪费内存的问题，每进行一次实例化，便新开辟一个内存空间</p>
</li>
<li><p>规则：</p>
<p>1）构造函数名字首字母要大写</p>
<p>2）构造函数不需要return就可以返回结果</p>
<p>3）用构造函数必须使用<code>new</code></p>
<p>4）属性和方法前面必须添加<code>this</code></p>
</li>
<li><p>语法：<code>function Classname(arg1,arg2,...){this.attr1=arg1 this.attr2=arg2 this.method=function(){...}}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">function Star(uname, age) {
  this.uname = uname
  this.age = age
  this.sing = function () {
    console.log(&#39;我会唱歌&#39;)
  }
}
// 创建新对象
var ldh = new Star(&#39;刘德华&#39;,18)
</code></pre>
</li>
<li><p>实例成员：构造函数内部通过this添加的成员，只能通过实例化的对象来访问</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 构造函数Star的age属性，只能通过以下方法访问
var ldh = new Star(&#39;刘德华&#39;,48)
ldh.age
</code></pre>
</li>
<li><p>静态成员：在构造函数本身上添加的成员（在外部后添加的），只能通过构造函数来访问，不能通过实例化对象来访问</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 构造函数Star没有sex属性，只能通过以下方法访问
Star.sex = &#39;男&#39;
Star.sex
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-10-2-">2.10.2 调用对象</h4>
<ol>
<li><p>调用属性：</p>
<p>1）对象名.属性名：<code>object.attribute</code></p>
<p>2）对象名[&#39;属性名&#39;]：<code>object[&#39;attribute&#39;]</code></p>
</li>
<li><p>调用方法：对象名.方法名()：<code>object.method()</code></p>
</li>
</ol>
<h4 id="2-10-3-">2.10.3 遍历对象</h4>
<ol>
<li><p>传统方法：<code>for (var k in obj) {obj[k]}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">for (var k in obj) {
  console.log(k)      // k：属性名
  console.log(obj[k]) // obj[k]：属性值
}
</code></pre>
</li>
<li><p><code>Object.keys()</code>：用于获取对象自身所有的属性名</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var obj = {
  name: &#39;pink老师&#39;,
  age: 18,
  sex: &#39;男&#39;,
  fn: function () {},
}
// 先用数组储存对象属性名
var arr = Object.keys(obj)
// 用forEach遍历
arr.forEach(function (value) {
  console.log(value) // 输出的value是属性名：name age sex fn
})
</code></pre>
</li>
</ol>
<h4 id="2-10-4-">2.10.4 对象属性</h4>
<ol>
<li><p>传统方法：<code>obj.属性名=属性值</code></p>
</li>
<li><p>ES5新方法：<code>Object.defineProperty(obj,prop,descriptor)</code></p>
<p>1）descriptor说明：以对象的形式书写</p>
<ul>
<li>value：设置属性值，默认为undefined</li>
<li>writable: 布尔值，值是否可以重写，默认为false</li>
<li>enumerable: 布尔值，目标属性是否可以被枚举，默认为 false，即Object.keys()是否可以遍历出该属性</li>
<li>configurable：布尔值，目标属性是否可以被删除或是否可以再次修改特性，默认为false，如果已经设置过一次descriptor了，不允许在下面再次修改descriptor中的参数</li>
</ul>
<p>2）对于obj初始时内部定义的属性，descriptor中后三项默认都是true</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var obj = {
  id: 1,
  pname: &#39;小米&#39;,
  price: 1999,
}
Object.defineProperty(obj, &#39;address&#39;, {
  value: &#39;中国山东蓝翔技校xx单元&#39;,
  // 如果只为false 不允许修改这个属性值 默认值也是false
  writable: false,
  // enumerable 如果值为false 则不允许遍历, 默认的值是 false
  enumerable: false,
  // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false
  configurable: false,
})
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-10-5-">2.10.5 对象方法</h4>
<ol>
<li><p><code>Object.is</code>：比较两个值是否严格相等，与<code>===</code>行为基本一致（+0 与 NaN）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Object.is(120, 120)) // true
console.log(Object.is(NaN, NaN)) // true
console.log(NaN === NaN)         // false
</code></pre>
</li>
<li><p><code>Object.assign</code>：对象的合并，将源对象的所有可枚举属性，复制到目标对象，如果属性重名则会覆盖掉</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const config1 = {
  host: &#39;localhost&#39;,
  port: 3306,
  name: &#39;root&#39;,
  pass: &#39;root&#39;,
  test: &#39;test&#39;,
}

const config2 = {
  host: &#39;http://atguigu.com&#39;,
  port: 33060,
  name: &#39;atguigu.com&#39;,
  pass: &#39;iloveyou&#39;,
  test2: &#39;test2&#39;,
}

console.log(Object.assign(config1, config2))
</code></pre>
</li>
<li><p><code>__proto__</code>、<code>setPrototypeOf</code>、<code>setPrototypeOf</code>：可以直接设置对象的原型</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const school = {
  name: &#39;尚硅谷&#39;,
}
const cities = {
  xiaoqu: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;],
}
// 将cities设置为school的原型对象
Object.setPrototypeOf(school, cities)
console.log(Object.getPrototypeOf(school))    // 结果：xiaoqu: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]
console.log(school)    // 结果：{name: &#39;尚硅谷&#39;}，进一步展开后里面有Prototype：xiaoqu: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;]
</code></pre>
</li>
<li><p><code>Object.keys()</code>：返回一个给定对象的所有可枚举属性键的数组</p>
</li>
<li><p><code>Object.values()</code>：返回一个给定对象的所有可枚举属性值的数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const school = {
  name: &#39;尚硅谷&#39;,
  cities: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;],
  xueke: [&#39;前端&#39;, &#39;Java&#39;, &#39;大数据&#39;, &#39;运维&#39;],
}
//获取对象所有的键
console.log(Object.keys(school))
//获取对象所有的值
console.log(Object.values(school))
</code></pre>
</li>
<li><p><code>Object.entries()</code>：返回一个给定对象自身可遍历属性<code>[key,value]</code>的数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const school = {
  name: &#39;尚硅谷&#39;,
  cities: [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;],
  xueke: [&#39;前端&#39;, &#39;Java&#39;, &#39;大数据&#39;, &#39;运维&#39;],
}
//entries
console.log(Object.entries(school))
//可以利用entries创建 Map
const m = new Map(Object.entries(school))
console.log(m.get(&#39;cities&#39;))
</code></pre>
</li>
<li><p><code>Object.getOwnPropertyDescriptors()</code>：返回指定对象所有自身属性的描述对象（writable、configurable、enumerable）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const obj = Object.create(null, {
  name: {
    //设置值
    value: &#39;尚硅谷&#39;,
    //属性特性
    writable: true,
    configurable: true,
    enumerable: true,
  },
})
// 对象属性的描述对象
console.log(Object.getOwnPropertyDescriptors(school))
</code></pre>
</li>
<li><p><code>Object.fromEntries()</code>：ES10新特性，用来创建对象，但参数比较特殊，接收一个二维数组或Map</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 二维数组：返回结果：{name: &#39;尚硅谷&#39;, xueke: &#39;Java,大数据,前端,云计算&#39;}
const result = Object.fromEntries([
  [&#39;name&#39;, &#39;尚硅谷&#39;],
  [&#39;xueke&#39;, &#39;Java,大数据,前端,云计算&#39;],
])

// Map：返回结果：{name: &#39;ATGUIGU&#39;}
const m = new Map()
m.set(&#39;name&#39;, &#39;ATGUIGU&#39;)
const result2 = Object.fromEntries(m)

// 对比Object.entries：反向操作，将对象转为二维数组，返回：[&#39;name&#39;, &#39;尚硅谷&#39;]
const arr = Object.entries({
  name: &#39;尚硅谷&#39;,
})
console.log(arr)
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-10-6-">2.10.6 可选链操作符</h4>
<ol>
<li><p>格式为问号+点（<code>?.</code>），用于简化判断深层级对象中的属性和方法。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function main(config) {
  // 需求：判断用户是否传入config，是否传入config.db，是否传入config.db.host

  // 旧方法：如果不判断直接调用dbHost，用户未传入的情况下，会报错
  // const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host

  // 新方法
  const dbHost = config?.db?.host
  console.log(dbHost)

  const cacheUser = config?.cache?.username
  console.log(cacheUser)    // undefined
}
main({
  db: {
    host: &#39;192.168.1.100&#39;,
    username: &#39;root&#39;,
  }
})
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-10-7-">2.10.7 内置对象</h4>
<blockquote>
<p>内置对象：JS已经定义好的，直接拿来使用即可，都是首字母大写的。</p>
</blockquote>
<h5 id="2-10-7-1-math-">2.10.7.1 Math对象</h5>
<ol>
<li><p>定义：不是构造函数，不用new实例化</p>
</li>
<li><p>圆周率：<code>Math.PI</code></p>
</li>
<li><p>最大值：<code>Math.max()</code></p>
</li>
<li><p>最小值：<code>Math.min()</code></p>
</li>
<li><p>绝对值：<code>Math.abs()</code>，如果输入字符串自动转为数字</p>
</li>
<li><p>向下取整：<code>Math.floor()</code>，往小了取值</p>
</li>
<li><p>向上取整：<code>Math.ceil()</code>，往大了取值</p>
</li>
<li><p>四舍五入：<code>Math.round()</code>，0.5往大取，1.5变成2，-1.5变成-1</p>
</li>
<li><p>将数字的小数部分抹掉：<code>Math.trunc()</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Math.trunc(3.5))    // 3
</code></pre>
</li>
<li><p>判断一个数到底为正数、负数、还是零：<code>Math.sign()</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">console.log(Math.sign(100))        // 1
console.log(Math.sign(0))        // 0
console.log(Math.sign(-20000))    // -1
</code></pre>
</li>
<li><p>随机数：<code>Math.random()</code>，取值范围 [0,1)</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 案例：得到一个两数之间的随机数
function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

// 案例：得到一个两数之间的随机整数
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min; //不含最大值，含最小值
}

// 案例：得到一个两数之间的随机整数，包括两个数在内
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 
}
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 案例：从学员名单中不重复地选出4名学员
//           0       1      2         3        4        5       6
var arr = [&#39;鹿晗&#39;, &#39;王三&#39;, &#39;彭于晏&#39;, &#39;刘德华&#39;, &#39;张学友&#39;, &#39;张三丰&#39;, &#39;乔峰&#39;]
// 定义函数：得到一个两数之间的随机整数
function getRandomInt(min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)
  return Math.floor(Math.random() * (max - min)) + min
}
var numArray = [] // 存放索引的数组
var newArray = [] // 存放筛选出来的4个学员

// 如果真的突然出现筛选出重复的人，最多不会出现3次等
for (var i = 0; i &lt; 11; i++) {
  var num = getRandomInt(0, 6)
  // console.log(num);
  if (numArray.indexOf(num) == -1) {
    // 如果在numArray空数组里面检测不到随机的num，就放到数组里面
    numArray[numArray.length] = num
    newArray[newArray.length] = arr[num]
  }
  if (numArray.length == 4) {
    break
  }
}
document.write(newArray)
document.write(numArray)
</code></pre>
</li>
</ol>
<h5 id="2-10-7-2-date-">2.10.7.2 Date对象</h5>
<ol>
<li><p>定义：是构造函数，需要new实例化</p>
</li>
<li><p>语法：<code>var date = Date(参数)</code>，如果没有参数，返回系统当前时间</p>
</li>
<li><p>参数：</p>
<p>1）数字型：2019,10,01，注意：数字型月份默认+1，即输入10，输出为11月</p>
<p>2）字符串：&#39;2019-10-1 8:8:8&#39;</p>
</li>
<li><p>格式化：<code>var date = new Date()</code></p>
<p>1）获取当年：<code>date.getFullYear()</code></p>
<p>2）获取当月：<code>date.getMonth()</code>，注意：返回的数值需要+1才是当前月份</p>
<p>3）获取当天日期：<code>date.getDate()</code></p>
<p>4）获取星期几：<code>date.getDay()</code>，注意：周日返回的是0，最好用数组自定义一下，然后arr[day]</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 格式化日期
var date = new Date()
var year = date.getFullYear()
var month = date.getMonth() + 1
var dates = date.getDate()
var arr = [&#39;星期日&#39;, &#39;星期一&#39;, &#39;星期二&#39;, &#39;星期三&#39;, &#39;星期四&#39;, &#39;星期五&#39;, &#39;星期六&#39;]
var day = date.getDay()
console.log(&#39;今天是：&#39; + year + &#39;年&#39; + month + &#39;月&#39; + dates + &#39;日 &#39; + arr[day])
</code></pre>
<p>5）获取当前小时：<code>date.getHours()</code>，补零：<code>h = h &lt; 10 ? &#39;0&#39; + h : h</code></p>
<p>6）获取当前分钟：<code>date.getMinutes()</code>，补零：<code>m = m &lt; 10 ? &#39;0&#39; + m : m</code></p>
<p>7）获取当前秒钟：<code>date.getSeconds()</code>，补零：<code>s = s &lt; 10 ? &#39;0&#39; + s : s</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 格式化时间
function getTimer() {
  var time = new Date()
  var h = time.getHours()
  h = h &lt; 10 ? &#39;0&#39; + h : h
  var m = time.getMinutes()
  m = m &lt; 10 ? &#39;0&#39; + m : m
  var s = time.getSeconds()
  s = s &lt; 10 ? &#39;0&#39; + s : s
  return h + &#39;:&#39; + m + &#39;:&#39; + s
}
console.log(getTimer())
</code></pre>
</li>
<li><p>时间戳：当前距离1970年1月1日的总毫秒数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 方法1
var date = new Date()
date.valueOf()
date.getTime()
// 方法2
var date = +new Date()
// 方法3
Date.now()
</code></pre>
</li>
<li><p>案例：倒计时</p>
<p>1）输入的时间减去现在的时间就是剩余的时间，但是不能拿着时分秒相减，比如05分减去25分，结果会是负数的</p>
<p>2）用时间戳：用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余时间的毫秒数</p>
<p>3）把剩余时间总的毫秒数转换为天、时、分、秒 （时间戳转换为时分秒）</p>
<ul>
<li>毫秒转为秒：除1000</li>
<li>计算天数：parseInt(总秒数/ 60/60 /24)</li>
<li>计算小时：parseInt(总秒数/ 60/60 %24)</li>
<li>计算分钟：parseInt(总秒数 /60 %60 )</li>
<li>计算秒数：parseInt(总秒数%60)</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">function countDown(time) {
  var nowTime = +new Date() // 返回的是当前时间总的毫秒数
  var inputTime = +new Date(time) // 返回的是用户输入时间总的毫秒数
  var times = (inputTime - nowTime) / 1000 // times是剩余时间总的秒数
  var d = parseInt(times / 60 / 60 / 24) // 天
  d = d &lt; 10 ? &#39;0&#39; + d : d
  var h = parseInt((times / 60 / 60) % 24) //时
  h = h &lt; 10 ? &#39;0&#39; + h : h
  var m = parseInt((times / 60) % 60) // 分
  m = m &lt; 10 ? &#39;0&#39; + m : m
  var s = parseInt(times % 60) // 当前的秒
  s = s &lt; 10 ? &#39;0&#39; + s : s
  return d + &#39;天&#39; + h + &#39;时&#39; + m + &#39;分&#39; + s + &#39;秒&#39;
}
console.log(countDown(&#39;2023-01-01 18:00:00&#39;))
</code></pre>
</li>
</ol>
<h5 id="2-10-7-3-">2.10.7.3 扩展内置对象</h5>
<ol>
<li><p>作用：通过原型对象prototype，对JS内置对象进行扩展自定义的方法，如给Array添加求和的功能</p>
</li>
<li><p>正确写法：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">Array.prototype.sum = function () {
  var sum = 0
  for (var i = 0; i &lt; this.length; i++) {
    sum += this[i]
  }
  return sum
}
</code></pre>
</li>
<li><p>错误写法：即使用constructor: Array重新定向也不行，内置对象扩展方法必须用上面的写法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">Array.prototype = {
  sum: function () {
    var sum = 0
    for (var i = 0; i &lt; this.length; i++) {
      sum += this[i]
    }
    return sum
  },
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-10-8-proto">2.10.8 原型 Proto</h4>
<h5 id="2-10-8-1-prototype">2.10.8.1 原型对象：prototype</h5>
<ol>
<li><p>定义：</p>
<p>1）每个构造函数都有一个prototype属性，指向另一个【对象】，这个对象的所有属性和方法，都会被构造函数拥有</p>
<p>2）把不变的方法直接定义在 prototype 对象上，所有对象实例都可以共享这些方法，可以有效解决浪费内存问题</p>
</li>
<li><p>语法：<code>Object.prototype.method = function() {...}</code></p>
<p>1）一般来说，公共属性定义到构造函数里面，公共的方法放到原型对象身上</p>
<p>2）用原型在外部定义的成员，可以通过实例对象访问</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 构造函数创建Star类
function Star(uname, age) {
  this.uname = uname
  this.age = age
}
// 使用原型对象在外部定义sing方法，可以通过实例对象ldh或zxy访问（如果直接用Star.sing定义，实例对象无法调用）
Star.prototype.sing = function () {
  console.log(&#39;我会唱歌&#39;)
}

var ldh = new Star(&#39;刘德华&#39;, 18)
var zxy = new Star(&#39;张学友&#39;, 19)

console.log(ldh.sing === zxy.sing)    // true
ldh.sing()    // 我会唱歌
zxy.sing()    // 我会唱歌
</code></pre>
</li>
</ol>
<h5 id="2-10-8-2-__proto__">2.10.8.2 对象原型: <code>__proto__</code></h5>
<ol>
<li><p>定义：每个对象都会有一个属性<code>__proto__</code>指向【构造函数】的【原型对象prototype】，之所以对象可以使用【构造函数】的【原型对象prototype】的属性和方法，就是因为对象有<code>__proto__</code>原型存在</p>
</li>
<li><p>实例化对象的<code>__proto__</code>指向【构造函数】的【原型对象prototype】</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var ldh = new Star(...)
console.log(ldh.__proto__ === Star.prototype)  // ture
</code></pre>
</li>
<li><p>方法的查找规则：</p>
<p>1）首先先看ldh对象身上是否有sing方法，如果有就执行这个对象上的sing</p>
<p>2）如果没有sing这个方法，因为有<code>__proto__</code>的存在，就去【构造函数Star】的【原型对象prototype】身上去查找sing这个方法</p>
<p>3)<code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p>
</li>
</ol>
<h5 id="2-10-8-3-constructor">2.10.8.3 构造函数 Constructor</h5>
<ol>
<li><p>定义：</p>
<p>1）【对象原型（<code>__proto__</code>）】和【构造函数】的【原型对象（<code>prototype</code>）】里都有一个<code>constructor</code>属性，指回【构造函数】本身</p>
<p>2）用于记录该对象引用于哪个构造函数，可以让原型对象prototype重新指向原来的构造函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function Star(uname, age) {
  this.uname = uname
  this.age = age
}
console.log(ldh.__proto__.constructor === Star.prototype.constructor)  // ture
</code></pre>
</li>
<li><p>作用：由于通过【原型对象prototype】定义公共的方法，而方法往往有多个，不可能重复书写，此时需要重新定义【原型对象prototype】</p>
<p>1）单一公共方法的定义</p>
<pre class="prettyprint linenums:0"><code class="lang-js">Star.prototype.sing = function () {
  console.log(&#39;我会唱歌&#39;)
}
</code></pre>
<p>2）多个公共方法的定义：此处修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor指回原来的构造函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">Star.prototype = {
  constructor: Star,
  sing: function () {
    console.log(&#39;我会唱歌&#39;)
  },
  movie: function () {
    console.log(&#39;我会演电影&#39;)
  },
}
</code></pre>
</li>
</ol>
<h5 id="2-10-8-4-">2.10.8.4 原型链</h5>
<p><img src="D:\MyProjects\Website\Tutoring\Web_Basic\Section4-JavaScript\src\原型链.png" alt="原型链"></p>
<ol>
<li><p>只要是对象就有<code>__proto__</code>原型，指向原型对象【Object.prototype】</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 三者等价
ldh.__proto__.__proto__
Star.prototype.__proto__
Object.prototype
</code></pre>
</li>
<li><p>【Object.prototype】原型对象里面的<code>__proto__</code>原型，指向为 null</p>
<pre class="prettyprint linenums:0"><code class="lang-js">Object.prototype.__proto__ === null
</code></pre>
</li>
<li><p>成员查找规则（就近原则）</p>
<p>1）先看 <code>ldh</code> 自身是否有该属性/方法</p>
<p>2）没有的话查找它的原型 <code>Star.prototype</code>（即 <code>ldh.__proto__</code> 所指向的）</p>
<p>3）还没有的话查找原型对象的原型 <code>Object.prototype</code>（即 <code>Star.prototype.__proto__</code> 所指向的）</p>
<p>4）再没有的话，返回 <code>Object.prototype.__proto__</code>，即 <code>null</code></p>
<p>5）注意：ldh、Star、Object身上可能有相同属性名但不同属性值的情况，此时要就近原则查找</p>
</li>
</ol>
<h5 id="2-10-8-5-this-">2.10.8.5 this指向</h5>
<ol>
<li><p>都指向实例对象 ldh：</p>
<p>1）构造函数 Star(){...} 中的this</p>
<p>2）原型对象函数 Star.prototype.sing = function() {...} 中的this</p>
</li>
</ol>
<hr>
<h3 id="2-11-class">2.11 类 Class</h3>
<blockquote>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
</blockquote>
<h4 id="2-11-1-">2.11.1 创建类</h4>
<ol>
<li><p>类必须使用new实例化对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 首字母大写，不加小括号
class Name {...}
var xx = new Name()
</code></pre>
</li>
<li><p>构造函数：<code>constructor()</code></p>
<p>1）定义：接受传递过来的参数，同时返回实例对象，只要 new 生成实例时就会自动调用这个函数</p>
<p>2）语法：<code>class Name {constructor(arg) {this.xx = arg ... }}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 1. 创建类 class
class Star {
  constructor(uname, age) {
    this.uname = uname
    this.age = age
  }
  sing(song) {
    console.log(this.uname + song)
  }
}
// 2. 利用类创建对象 new
var ldh = new Star(&#39;刘德华&#39;, 18)
</code></pre>
</li>
<li><p>注意：</p>
<p>1）ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
<p>2）类里面的共有的属性和方法一定要加this使用</p>
<p>3）在类中调用内部定义的函数，不用加括号</p>
</li>
<li><p>类其实是构造函数的另一种写法而已：</p>
<p>1）类有原型对象prototype：<code>Star.prototype</code></p>
<p>2）类原型对象prototype里面有constructor指向类本身：<code>Star.prototype.constructor</code></p>
<p>3）类可以通过原型对象添加方法：<code>Star.prototype.sing = function () {...}</code></p>
<p>4）类创建的实例对象有<code>__proto__</code>原型指向类的原型对象：<code>ldh.__proto__ === Star.prototype</code></p>
</li>
</ol>
<h4 id="2-11-2-">2.11.2 类的方法</h4>
<ol>
<li><p>语法：直接写到类里面即可，在constructor下面写</p>
</li>
<li><p>注意：不用写function关键字，直接写函数名，如 sing(song) {...}，函数/方法之间不能加逗号分割</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Star {
  // 类的共有属性放到 constructor 里面
  constructor(uname, age) {
    this.uname = uname
    this.age = age
  }
  sing(song) {
    console.log(this.uname + song)
  }
}
</code></pre>
</li>
</ol>
<h4 id="2-11-3-">2.11.3 静态属性</h4>
<ol>
<li><p>定义：属于类的属性和方法，但不属于实例对象的属性和方法</p>
</li>
<li><p>ES5方法：给实例对象添加属性和方法，使用 <code>Obj.prototype</code>，直接在类上添加的属性和方法，属于静态方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// ES5方法
function Phone() {}
Phone.name = &#39;手机&#39;
Phone.change = function () {
    console.log(&#39;我可以改变世界&#39;)
}
Phone.prototype.size = &#39;5.5inch&#39;

let nokia = new Phone()
// 直接在函数对象上添加属性，实例对象无法读取，必须用prototype添加，否则属于静态属性和方法
console.log(nokia.name)    // undefined
console.log(Phone.name)       // &#39;手机&#39;
nokia.change()            // 报错nokia.change is not a function
Phone.change()               // &#39;我可以改变世界&#39;
console.log(nokia.size)   // &#39;5.5inch&#39;
</code></pre>
</li>
<li><p>ES6方法：使用static定义静态方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// ES6方法
class Phone {
  //静态属性：属于类的属性和方法，但不属于实例对象的属性和方法
  static name = &#39;手机&#39;
  static change() {
    console.log(&#39;我可以改变世界&#39;)
  }
}
let nokia = new Phone()
console.log(nokia.name)    // undefined
console.log(Phone.name)    // &#39;手机&#39;
nokia.change() // 报错nokia.change is not a function
Phone.change() //&#39;我可以改变世界&#39; */
</code></pre>
</li>
</ol>
<h4 id="2-11-4-">2.11.4 私有属性</h4>
<ol>
<li><p>定义：私有属性是不能被直接访问的属性，在属性名前添加井号<code>#</code>即可。需要在外部先单独声明，如果要访问，需要在类内部定义访问函数。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Person {
  //公有属性（写不写都行）
  name
  //私有属性（需要在外部先声明）
  #age
  #weight
  //构造方法
  constructor(name, age, weight) {
    this.name = name
    this.#age = age
    this.#weight = weight
  }
  // 如果要访问私有属性，需要在类内部定义函数
  intro() {
    console.log(this.name)
    console.log(this.#age)
    console.log(this.#weight)
  }
}
//实例化
const girl = new Person(&#39;晓红&#39;, 18, &#39;45kg&#39;)

// console.log(girl.name)
// console.log(girl.#age)    // 无法这样直接访问
// console.log(girl.#weight) // 无法这样直接访问

// 这样可以访问私有属性
girl.intro()
</code></pre>
</li>
</ol>
<h4 id="2-11-5-">2.11.5 类的继承</h4>
<h5 id="2-11-5-1-es6-">2.11.5.1 ES6之后继承</h5>
<ol>
<li><p>就近原则：</p>
<p>1）继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的</p>
<p>2）如果子类里面没有，就去查找父类有没有这个方法，如果有就执行父类的这个方法</p>
</li>
<li><p>extends关键字：<code>class Son extends Father {...}</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Father {
  constructor() {}
  money() {
    console.log(100)
  }
}
class Son extends Father {}
var son = new Son()
son.money()
</code></pre>
</li>
<li><p>super关键字：用于访问和调用父类上的函数，可以调用父类的构造函数、普通函数</p>
<p>1）调用构造函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Father {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
  sum() {
    console.log(this.x + this.y)
  }
}
class Son extends Father {
  constructor(x, y) {
    super(x, y) //调用了父类中的构造函数
  }
}
var son = new Son(1, 2)
var son1 = new Son(11, 22)
son.sum()
son1.sum()
</code></pre>
<p>2）调用普通函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Father {
  say() {
    return &#39;我是爸爸&#39;
  }
}
class Son extends Father {
  say() {
    // super.say() 就是调用父类中的普通函数 say()
    console.log(super.say() + &#39;的儿子&#39;)  
  }
}
var son = new Son()
son.say()
</code></pre>
</li>
<li><p>继承的同时扩展自己的方法：</p>
<p>1）利用super调用父类的构造函数（注意：super 必须在子类this之前调用）</p>
<p>2）然后直接在子类的构造函数下写自己的函数方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Phone {
  //构造方法
  constructor(brand, price) {
    this.brand = brand
    this.price = price
  }
  //父类的成员属性
  call() {
    console.log(&#39;我可以打电话!!&#39;)
  }
}
// extends关键字继承父类
class SmartPhone extends Phone {
  //构造方法
  constructor(brand, price, color, size) {
    // super调用父级构造方法
    super(brand, price) // 等价于Phone.call(this, brand, price)
    this.color = color
    this.size = size
  }
  photo() {
    console.log(&#39;拍照&#39;)
  }
  playGame() {
    console.log(&#39;玩游戏&#39;)
  }
  // 可以重写父类中的属性和方法
  call() {
    console.log(&#39;我可以进行视频通话&#39;)
  }
}
const xiaomi = new SmartPhone(&#39;小米&#39;, 799, &#39;黑色&#39;, &#39;4.7inch&#39;)
console.log(xiaomi)
xiaomi.call()
xiaomi.photo()
xiaomi.playGame()
</code></pre>
</li>
</ol>
<h5 id="2-11-5-2-es6-">2.11.5.2 ES6之前继承</h5>
<ol>
<li><p>组合继承：构造函数+原型对象，模拟实现继承</p>
</li>
<li><p><code>function.call(thisArg,arg1,arg2,...)</code>：thisArg：当前调用函数this的指向对象</p>
<p>1）作用：修改函数运行时的this指向</p>
<p>2）调用函数：有函数fun(x,y){...}，正常可以用fun()调用，也可以用fun.call()调用</p>
<p>3）改变函数指向：<code>var o = {...}, fun.call (o, x, y)</code>, 此时fun中的this指向了对象o</p>
</li>
<li><p>借用父构造函数继承【属性】：在子构造函数中添加 <code>Father.call(this, arg1,arg2,...)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">function Father(uname, age) {
  this.uname = uname
  this.age = age
}

function Son(uname, age, score) {
  Father.call(this, uname, age)
  this.score = score
}
</code></pre>
</li>
<li><p>借用原型对象继承【方法】：子构造函数的原型对象=new 父构造函数，同时用constructor指回子构造函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">Father.prototype.money = function () {
  console.log(100000)
}
// 注意：如果用Son.prototype = Father.prototype赋值会有问题，修改Son的同时也会修改Father的方法
Son.prototype = new Father()
Son.prototype.constructor = Son
</code></pre>
</li>
</ol>
<h4 id="2-11-6-get-set">2.11.6 get和set</h4>
<ol>
<li><p>get：获取属性</p>
</li>
<li><p>set：对某属性进行设置</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Phone {
  get price() {
    console.log(&#39;价格属性被读取了&#39;)
    return &#39;iloveyou&#39;
  }
  // 注意：set至少要有一个参数
  set price(newVal) {
    console.log(&#39;价格属性被修改了&#39;)
  }
}

//实例化对象
let s = new Phone()

console.log(s.price)
s.price = &#39;free&#39;
</code></pre>
</li>
</ol>
<h4 id="2-11-7-this-">2.11.7 this指向</h4>
<ol>
<li><p>constructor中的this指向的是创建的实例对象</p>
</li>
<li><p>类的方法函数中的this指向的是调用它的对象，一般就是实例对象</p>
<ul>
<li>特殊案例：如果在构造函数中调用内部函数，比如点击按钮触发函数，函数中的this指向的是按钮</li>
</ul>
</li>
<li><p>如果想保留constructor中的this指向，最好用其他变量保存一下，防止命名冲突，如：that = this（先在类的外面声明全局变量 var that）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button&gt;点击&lt;/button&gt;
&lt;script&gt;
  var that
  var _that
  class Star {
    constructor(uname, age) {
      // constructor 里面的this 指向的是创建的实例对象
      that = this
      console.log(this) // Star{...}，即ldh
      this.uname = uname
      this.age = age
      this.btn = document.querySelector(&#39;button&#39;)
      this.btn.onclick = this.sing
    }
    sing() {
      // 这个sing方法里面的this指向的是btn这个按钮，因为这个按钮调用了这个函数
      console.log(this)       // &lt;button&gt;点击&lt;/button&gt;
      console.log(that.uname) // 刘德华，that里面存储的是constructor里面的this
    }
    dance() {
      // 这个dance里面的this指向的是实例对象ldh，因为ldh调用了这个函数
      _that = this
      console.log(this)        // Star{...}，即ldh
    }
  }
  var ldh = new Star(&#39;刘德华&#39;)
  console.log(that === ldh)        // true
  ldh.dance()
  console.log(_that === ldh)    // true
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-12-">2.12 正则表达式</h3>
<blockquote>
<p>Regular Expression，用于匹配字符串中字符组合的模式，在JS中正则表达式也是对象。</p>
</blockquote>
<h4 id="2-12-1-">2.12.1 创建正则表达式</h4>
<ol>
<li>调用RegExp对象的构造函数：<code>var 变量名 = new RegExp(/表达式/)</code></li>
<li>利用字面量创建：<code>var 变量名 = /表达式/</code></li>
<li>注意：正则表达式里面不需要加引号，不管是数字型还是字符串型</li>
</ol>
<h4 id="2-12-2-">2.12.2 测试正则表达式</h4>
<ol>
<li><p>检测字符串是否符合规则，返回布尔值</p>
</li>
<li><p>语法：<code>regObj.test（str）</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">var rg = /123/
console.log(rg.test(123))
</code></pre>
</li>
<li><p>正则测试工具：<a href="http://tool.oschina.net/regex">http://tool.oschina.net/regex</a></p>
</li>
</ol>
<h4 id="2-12-3-">2.12.3 检索正则表达式</h4>
<ol>
<li><p>exec()函数：<code>regObj.exec(string)</code>，用于检索字符串中的正则表达式的匹配，如果有匹配的值，返回该匹配值，否则返回null</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var str = &#39;hello&#39;
var pattern = /o/
var result = pattern.exec(str)
console.log(result)
// 输出结果：[&#39;o&#39;, index: 4, input: &#39;hello&#39;, groups: undefined]
</code></pre>
</li>
</ol>
<h4 id="2-12-4-">2.12.4 元字符</h4>
<ul>
<li>在正则表达式中具有特殊意义的专用符号，如：^、$、+ 等</li>
</ul>
<h5 id="2-12-4-1-">2.12.4.1 边界符</h5>
<ol>
<li><p><code>^</code>：表示匹配行首的文本</p>
</li>
<li><p><code>$</code>：表示匹配行尾的文本</p>
</li>
<li><p>如果<code>^</code>和<code>$</code>在一起，表示必须是精确匹配</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 边界符 ^ $
var rg = /abc/ // 正则表达式里面不需要加引号 不管是数字型还是字符串型
// /abc/ 只要包含有abc这个字符串返回的都是true
console.log(rg.test(&#39;abc&#39;))
console.log(rg.test(&#39;abcd&#39;))
console.log(rg.test(&#39;aabcd&#39;))
console.log(&#39;---------------------------&#39;)
var reg = /^abc/
console.log(reg.test(&#39;abc&#39;)) // true
console.log(reg.test(&#39;abcd&#39;)) // true
console.log(reg.test(&#39;aabcd&#39;)) // false
console.log(&#39;---------------------------&#39;)
var reg1 = /^abc$/ // 精确匹配 要求必须是 abc字符串才符合规范
console.log(reg1.test(&#39;abc&#39;)) // true
console.log(reg1.test(&#39;abcd&#39;)) // false
console.log(reg1.test(&#39;aabcd&#39;)) // false
console.log(reg1.test(&#39;abcabc&#39;)) // false
</code></pre>
</li>
</ol>
<h5 id="2-12-4-2-">2.12.4.2 字符类</h5>
<ul>
<li><p>定义：表示有一系列字符可供选择，只要匹配其中一个就可以了，所有可供选择的字符都放在方括号内。</p>
</li>
<li><p><code>[]</code>：只要包含里面任意一个字符即可</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var rg = /[abc]/ // 只要包含有a 或者 包含有b 或者包含有c 都返回为true
console.log(rg.test(&#39;andy&#39;))
console.log(rg.test(&#39;baby&#39;))
console.log(rg.test(&#39;color&#39;))
console.log(rg.test(&#39;red&#39;))
</code></pre>
</li>
<li><p><code>^[]$</code>：只能是包含其中任意一个字符的单个字符</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var rg1 = /^[abc]$/ // 三选一，只有是a或b或c这三个字母才返回 true
console.log(rg1.test(&#39;aa&#39;))
console.log(rg1.test(&#39;a&#39;))
console.log(rg1.test(&#39;b&#39;))
console.log(rg1.test(&#39;c&#39;))
console.log(rg1.test(&#39;abc&#39;))
</code></pre>
</li>
<li><p><code>[-]</code>：表示范围，如<code>[a-z]</code>代表包含任意26个字母之一即可</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var reg = /^[a-z]$/ // 26个英文字母任何一个字母返回true，- 表示的是a到z的范围
console.log(reg.test(&#39;a&#39;))
console.log(reg.test(&#39;z&#39;))
console.log(reg.test(1))
console.log(reg.test(&#39;A&#39;))
</code></pre>
</li>
<li><p><code>^[a-zA-Z0-9_-]$</code>：26个大小写英文字母+0-9数字+下划线_+短横线-，包含任意其中之一的一个</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var reg1 = /^[a-zA-Z0-9_-]$/ // 26个大小写英文字母+0-9数字+下划线_+短横线-，包含任意其中之一的一个，返回true
console.log(reg1.test(&#39;1&#39;))
console.log(reg1.test(&#39;B&#39;))
console.log(reg1.test(8))
console.log(reg1.test(&#39;-&#39;))
console.log(reg1.test(&#39;_&#39;))
console.log(reg1.test(&#39;!&#39;))
</code></pre>
</li>
<li><p><code>[^]</code>：方括号内部取反符^，只要包含其中任意字符，都返回false</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var reg2 = /^[^a-zA-Z0-9_-]$/  // 26个大小写英文字母+0-9数字+下划线_+短横线-，包含任意其中之一的一个，返回false
console.log(reg2.test(&#39;a&#39;))
console.log(reg2.test(&#39;B&#39;))
console.log(reg2.test(8))
console.log(reg2.test(&#39;-&#39;))
console.log(reg2.test(&#39;_&#39;))
console.log(reg2.test(&#39;!&#39;))
</code></pre>
</li>
</ul>
<h5 id="2-12-4-3-">2.12.4.3 量词符</h5>
<ul>
<li><p>定义：设定某个模式出现的次数</p>
</li>
<li><p><code>*</code>：可以出现0次或很多次</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// * 相当于 &gt;= 0 可以出现0次或者很多次
var reg = /^a*$/
console.log(reg.test(&#39;&#39;))
console.log(reg.test(&#39;a&#39;))
console.log(reg.test(&#39;aaaa&#39;))
</code></pre>
</li>
<li><p><code>+</code>：可以出现1次或者很多次</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// + 相当于 &gt;= 1 可以出现1次或者很多次
var reg1 = /^a+$/
console.log(reg1.test(&#39;&#39;)) // false
console.log(reg1.test(&#39;a&#39;)) // true
console.log(reg1.test(&#39;aaaa&#39;)) // true
</code></pre>
</li>
<li><p><code>?</code> ：可以出现0次或1次</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//  ?  相当于 1 || 0
var reg2 = /^a?$/
console.log(reg2.test(&#39;&#39;)) // true
console.log(reg2.test(&#39;a&#39;)) // true
console.log(reg2.test(&#39;aaaa&#39;)) // false
</code></pre>
</li>
<li><p><code>{n}</code>：重复n次</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// {3} 就是重复3次
var reg3 = /^a{3}$/
console.log(reg3.test(&#39;&#39;)) // false
console.log(reg3.test(&#39;a&#39;)) // false
console.log(reg3.test(&#39;aaaa&#39;)) // false
console.log(reg3.test(&#39;aaa&#39;)) // true
</code></pre>
</li>
<li><p><code>{n, }</code>：大于等于n次</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//  {3,}  大于等于3
var reg4 = /^a{3,}$/
console.log(reg4.test(&#39;&#39;)) // false
console.log(reg4.test(&#39;a&#39;)) // false
console.log(reg4.test(&#39;aaaa&#39;)) // true
console.log(reg4.test(&#39;aaa&#39;)) // true
</code></pre>
</li>
<li><p><code>{n,m}</code>：大于等于n次，并且小于等于m次（注意：n,m之间不要有空格）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//  {3,16}  大于等于3并且小于等于16
var reg5 = /^a{3,6}$/
console.log(reg5.test(&#39;&#39;)) // false
console.log(reg5.test(&#39;a&#39;)) // false
console.log(reg5.test(&#39;aaaa&#39;)) // true
console.log(reg5.test(&#39;aaa&#39;)) // true
console.log(reg5.test(&#39;aaaaaaa&#39;)) // false
</code></pre>
</li>
<li><p><code>var reg = /^[a-zA-Z0-9_-]{6,16}$/</code>：26个大小写英文字母+0-9数字+下划线_+短横线-，包含任意其中之一，6-16个字符之间</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：用户名验证--&gt;
&lt;style&gt;
  span {
    color: #aaa;
    font-size: 14px;
  }
  .right {
    color: green;
  }
  .wrong {
    color: red;
  }
&lt;/style&gt;
&lt;input type=&quot;text&quot; class=&quot;uname&quot; /&gt; &lt;span&gt;请输入用户名&lt;/span&gt;
&lt;script&gt;
  // 用户只能输入英文字母、数字、下划线、短横线但是有边界符和[]，包含任意其中之一，6-16个字符之间
  var reg = /^[a-zA-Z0-9_-]{6,16}$/ 
  var uname = document.querySelector(&#39;.uname&#39;)
  var span = document.querySelector(&#39;span&#39;)
  uname.onblur = function () {
    if (reg.test(this.value)) {
      console.log(&#39;正确的&#39;)
      span.className = &#39;right&#39;
      span.innerHTML = &#39;用户名格式输入正确&#39;
    } else {
      console.log(&#39;错误的&#39;)
      span.className = &#39;wrong&#39;
      span.innerHTML = &#39;用户名格式输入不正确&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="2-12-4-4-">2.12.4.4 或者符</h5>
<ol>
<li>或者符：<code>|</code></li>
</ol>
<h5 id="2-12-4-5-">2.12.4.5 括号类</h5>
<ol>
<li><p>小括号<code>()</code>：表示优先级，可与模板语法配合：<code>{{(...)}}</code>小括号内表示一个分组，提取想要的内容</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 让abc重复三次
var reg = /^(abc){3}$/
// 仅让c重复三次
var reg = /^abc{3}$/
</code></pre>
</li>
<li><p>中括号<code>[]</code>：字符集合，匹配方括号中的任意字符</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 匹配a、b、c中的任意一个
var reg = /^[abc]$/;
</code></pre>
</li>
<li><p>大括号<code>{}</code>：量词符，里面表示重复次数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 匹配连续出现3次的c
var reg = /^abc{3}$/
console.log(reg.test(&#39;abcabcabc&#39;))    // false
console.log(reg.test(&#39;abccc&#39;))        // true
</code></pre>
</li>
</ol>
<h5 id="2-12-4-6-">2.12.4.6 预定义类</h5>
<ul>
<li><p>定义：某些常见模式的简写方式</p>
</li>
<li><p><code>\d</code>：匹配一个数字字符，等价于<code>[0-9]</code></p>
</li>
<li><p><code>\D</code>：匹配一个非数字字符，等价于<code>[^0-9]`</code></p>
</li>
<li><p><code>\w</code>：匹配包括下划线的任何单词字符，等价于<code>[A-Za-z0-9_]</code></p>
</li>
<li><p><code>\W</code>：匹配任何非单词字符，等价于<code>[^A-Za-z0-9_]</code></p>
</li>
<li><p><code>\s</code>：匹配任何空白字符，包括空格、制表符、换页符等等，等价于<code>[ \f\n\r\t\v]</code></p>
<p>1）<code>\f</code>：匹配一个换页符，等价于<code>\x0c</code>和<code>\cL</code></p>
<p>2）<code>\n</code>：匹配一个换行符，等价于<code>\x0a</code>和<code>\cJ</code></p>
<p>3）<code>\r</code>：匹配一个回车符，等价于<code>\x0d</code>和<code>\cM</code></p>
<p>4）<code>\t</code>：匹配一个制表符，等价于<code>\x09</code>和<code>\cI</code></p>
<p>5）<code>\v</code>：匹配一个垂直制表符，等价于<code>\x0b</code>和<code>\cK</code></p>
</li>
<li><p><code>\S</code>：匹配任何非空白字符，等价于<code>[^ \f\n\r\t\v]</code></p>
</li>
</ul>
<h5 id="2-12-4-7-">2.12.4.7 常用表达式</h5>
<ol>
<li><p>座机号：</p>
<p>1）区号（3-4位）：<code>/^\d{3,4}-\d{7,8}$/</code></p>
<p>2）座机号（7-8位）：<code>/^\d{3}-\d{8}|\d{4}-\d{7}$/</code></p>
</li>
<li><p>表单验证</p>
<p>1）手机号：<code>/^1[3|4|5|7|8]\d{9}$/</code></p>
<p>2）QQ号：<code>/^[1-9]\d{4,}$/</code></p>
<p>3）中文昵称：<code>/^[\u4e00-\u9fa5]{2,8}$/</code></p>
<p>4）短信验证码：<code>/^\d{6}$/</code></p>
<p>5）密码：<code>/^[a-zA-Z0-9_-]{6,16}$/</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：表单验证--&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;label for=&quot;tel&quot;&gt;手机号:&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;tel&quot; /&gt;
    &lt;span class=&quot;&quot;&gt; &lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;label for=&quot;&quot;&gt;QQ:&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;qq&quot; /&gt;
    &lt;span&gt;&lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;label for=&quot;&quot;&gt;昵称:&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;nc&quot; /&gt;
    &lt;span&gt;&lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;label for=&quot;&quot;&gt;短信验证码:&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;msg&quot; /&gt;
    &lt;span&gt;&lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;label for=&quot;&quot;&gt;登陆密码:&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;pwd&quot; /&gt;
    &lt;span&gt; &lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;label for=&quot;&quot;&gt;确认密码:&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;inp&quot; id=&quot;surepwd&quot; /&gt;
    &lt;span&gt;&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  window.onload = function () {
    var regtel = /^1[3|4|5|7|8]\d{9}$/ // 手机号码的正则表达式
    var regqq = /^[1-9]\d{4,}$/ // 10000
    var regnc = /^[\u4e00-\u9fa5]{2,8}$/
    var regmsg = /^\d{6}$/
    var regpwd = /^[a-zA-Z0-9_-]{6,16}$/
    var tel = document.querySelector(&#39;#tel&#39;)
    var qq = document.querySelector(&#39;#qq&#39;)
    var nc = document.querySelector(&#39;#nc&#39;)
    var msg = document.querySelector(&#39;#msg&#39;)
    var pwd = document.querySelector(&#39;#pwd&#39;)
    var surepwd = document.querySelector(&#39;#surepwd&#39;)

    regexp(tel, regtel) // 手机号码
    regexp(qq, regqq) // qq号码
    regexp(nc, regnc) // 昵称
    regexp(msg, regmsg) // 短信验证
    regexp(pwd, regpwd) // 密码框

    // 表单验证的函数
    function regexp(ele, reg) {
      ele.onblur = function () {
        if (reg.test(this.value)) {
          this.nextElementSibling.className = &#39;success&#39;
          this.nextElementSibling.innerHTML = &#39;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#39;
        } else {
          this.nextElementSibling.className = &#39;error&#39;
          this.nextElementSibling.innerHTML = &#39;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 格式不正确，请从新输入 &#39;
        }
      }
    }
    surepwd.onblur = function () {
      if (this.value == pwd.value) {
        this.nextElementSibling.className = &#39;success&#39;
        this.nextElementSibling.innerHTML = &#39;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#39;
      } else {
        this.nextElementSibling.className = &#39;error&#39;
        this.nextElementSibling.innerHTML = &#39;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 两次密码输入不一致&#39;
      }
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h4 id="2-12-5-">2.12.5 正则表达式参数</h4>
<ol>
<li>语法：<code>/表达式/[switch]</code>，switch又称修饰符，表示按照什么样的模式匹配</li>
<li>全局匹配：g</li>
<li>忽略大小写：i</li>
<li>全局匹配+忽略大小写：gi</li>
</ol>
<h4 id="2-12-6-">2.12.6 正则表达式替换</h4>
<ol>
<li><p>repalce()：<code>stringObject.replace(regexp/substr,replacement)</code></p>
</li>
<li><p>用法：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var str = &#39;andy和red&#39;
// 旧方法
var newStr = str.replace(&#39;andy&#39;, &#39;baby&#39;)
// 新方法
var newStr = str.replace(/andy/, &#39;baby&#39;)
</code></pre>
</li>
<li><p>注意：只能替换第一个满足条件的字符串，后面的不会替换，如果要全部替换令<code>switch=g</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 使用星号替换敏感词
div.innerHTML = text.value.replace(/激情|gay/g, &#39;**&#39;);
</code></pre>
</li>
</ol>
<h4 id="2-12-7-">2.12.7 正则表达式匹配</h4>
<ol>
<li><p>match()：<code>stringObject.match(searchvalue/regexp)</code></p>
</li>
<li><p>返回：指定的值，而不是字符串的位置</p>
</li>
<li><p>注意：如果使用正则匹配，一定要配合g进行全局匹配</p>
</li>
<li><p>案例：与replace搭配，动态匹配值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function htmlUnEscape(str) {
  return str.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, (match) =&gt; {
    switch (match) {
      case &#39;&amp;lt;&#39;:
        return &#39;&lt;&#39;
      case &#39;&amp;gt;&#39;:
        return &#39;&gt;&#39;
      case &#39;&amp;quot;&#39;:
        return &#39;&quot;&#39;
      case &#39;&amp;amp;&#39;:
        return &#39;&amp;&#39;
    }
  })
}
</code></pre>
</li>
</ol>
<h4 id="2-12-8-">2.12.8 命名捕获组</h4>
<blockquote>
<p>ES9允许命名捕获组使用符号<code>?&lt;name&gt;</code>,这样获取捕获结果可读性更强，无需通过改变index来获取结果。</p>
</blockquote>
<ol>
<li><p>传统方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 声明一个字符串
let str = &#39;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#39;
// 提取 url 与 『标签文本』
const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/
// 执行
const result = reg.exec(str)
// 返回结果：数组：[整个正则匹配结果,第一个小括号匹配结果,第二个小括号匹配结果,...]
console.log(result)
console.log(result[1])
console.log(result[2])
</code></pre>
</li>
<li><p>ES9新特性</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// ES9新特性：分组命名
// 声明一个字符串
let str = &#39;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#39;
//分组命名
const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/
// 返回结果，与传统方法相同，但多了一个groups属性，里面有url、text属性
// 优势：如果正则发生变化，也无需通过改变小括号内index来获取结果
const result = reg.exec(str)
console.log(result.groups.url)
console.log(result.groups.text)
</code></pre>
</li>
</ol>
<h4 id="2-12-9-">2.12.9 反向断言</h4>
<ol>
<li><p>ES9支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//需求：提取“你知道么”和“啦啦啦”之间的数字
let str = &#39;JS5211314你知道么555啦啦啦&#39;

//正向断言
const reg = /\d+(?=啦)/
const result = reg.exec(str)

//反向断言
const reg2 = /(?&lt;=么)\d+/
const result2 = reg2.exec(str)
console.log(result2)
</code></pre>
</li>
</ol>
<h4 id="2-12-10-dotall-">2.12.10 dotAll模式</h4>
<ol>
<li><p>正则表达式中 dot（<code>.</code>）匹配除回车外的任意单个字符，标记<code>s</code>改变这种行为，允许行终止符出现。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 传统方法
// 需求：分别把电影名和日期提取出来，存入数组
let str = `
  &lt;ul&gt;
      &lt;li&gt;
          &lt;a&gt;肖生克的救赎&lt;/a&gt;
          &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
          &lt;a&gt;阿甘正传&lt;/a&gt;
          &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;
      &lt;/li&gt;
  &lt;/ul&gt;`
// 声明正则
const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/
//执行匹配
const result = reg.exec(str)
console.log(result)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// ES9新方法：dotAll模式
// 声明正则
const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs
// 执行匹配
let result
let data = []
while ((result = reg.exec(str))) {
  data.push({ title: result[1], time: result[2] })
}
//输出结果
console.log(data)
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-13-symbol">2.13 唯一值 Symbol</h3>
<ol>
<li><p>定义：ES6中新的原始数据类型，是JS中第7种数据类型，表示独一无二的值，类似于字符串的数据类型</p>
</li>
<li><p>特点：</p>
<p>1）Symbol 的值是唯一的，用来解决命名冲突的问题</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// Symbol创建：即便symbol里面值相同，这两个变量也不相等
let s = Symbol()
onsole.log(s, typeof s)

let s2 = Symbol(&#39;尚硅谷&#39;)
let s3 = Symbol(&#39;尚硅谷&#39;)
console.log(s2 === s3)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// Symbol.for创建：如果symbol里面值相同，这两个变量相等
let s4 = Symbol.for(&#39;尚硅谷&#39;)
let s5 = Symbol.for(&#39;尚硅谷&#39;)
console.log(s4 === s5)
</code></pre>
<p>2）Symbol 值不能与其他数据进行运算</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 以下运算会报错
let result = s + 100;
let result = s &gt; 100;
let result = s + s;
</code></pre>
<p>3）Symbol 定义的对象属性不能使用for…in循环遍历，但是可以使用<code>Reflect.ownKeys</code>来获取对象的所有键名</p>
</li>
<li><p>作用：给对象添加/创建属性（用中括号<code>[ ]</code>添加）</p>
<p>1）如果想给对象添加属性，传统方法需要查看对象中是否已经有某种属性名，以防重名覆盖</p>
<p>2）外部添加法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 向对象中添加方法 up down
let game = {
  name: &#39;俄罗斯方块&#39;,
  up: function () {},
  down: function () {},
}
// 声明一个对象
let methods = {
  up: Symbol(),
  down: Symbol(),
}
game[methods.up] = function () {
  console.log(&#39;我可以改变形状&#39;)
}
game[methods.down] = function () {
  console.log(&#39;我可以快速下降!!&#39;)
}
console.log(game)
</code></pre>
<p>3）内部添加法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let youxi = {
  name: &#39;狼人杀&#39;,
  [Symbol(&#39;say&#39;)]: function () {
    console.log(&#39;我可以发言&#39;)
  },
  [Symbol(&#39;zibao&#39;)]: function () {
    console.log(&#39;我可以自爆&#39;)
  },
}
console.log(youxi)
</code></pre>
</li>
<li><p>内置值：除了定义自己使用的 Symbol 值以外，ES6 还提供了11个内置的 Symbol 值指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行。</p>
<p>1）<code>Symbol.hasInstance</code>：当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">class Person {
  static [Symbol.hasInstance](param) {
    console.log(param)
    console.log(&#39;我被用来检测类型了&#39;)
    return false
  }
}
let o = {}
console.log(o instanceof Person)
</code></pre>
<p>2）<code>Symbol.isConcatSpreadable</code>：布尔值，表示该对象用于 Array.prototype.concat()时，是否可以展开</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const arr = [1, 2, 3]
const arr2 = [4, 5, 6]
console.log(arr.concat(arr2))
arr2[Symbol.isConcatSpreadable] = false
console.log(arr.concat(arr2))
</code></pre>
<p>3）<code>Symbol.species</code>：创建衍生对象时，会使用该属性</p>
<p>4）<code>Symbol.match</code>：当执行 str.match(myObject) 时，如果该属性存在，会调用它，返回该方法的返回值</p>
<p>5）<code>Symbol.replace</code>：当该对象被 str.replace(myObject)方法调用时，会返回该方法的返回值</p>
<p>6）<code>Symbol.search</code>：当该对象被 str.search (myObject)方法调用时，会返回该方法的返回值</p>
<p>7）<code>Symbol.split</code>：当该对象被 str.split(myObject)方法调用时，会返回该方法的返回值</p>
<p>8）<code>Symbol.iterator</code>：对象进行 for...of 循环时，会调用该方法，返回该对象的默认遍历器</p>
<p>9）<code>Symbol.toPrimitive</code>：该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值</p>
<p>10）<code>Symbol.toStringTag</code>：在该对象上面调用 toString 方法时，返回该方法的返回值</p>
<p>11）<code>Symbol.unscopables</code>：该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除</p>
</li>
<li><p><code>description</code>属性：用于获取Symbol的字符串描述</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let s = Symbol(&#39;尚硅谷&#39;)
console.log(s.description) // &#39;尚硅谷&#39;
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-14-set">2.14 集合 Set</h3>
<ol>
<li><p>定义：ES6 提供了新的数据结构Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用扩展运算符<code>...</code>展开、<code>for...of...</code>进行遍历。</p>
</li>
<li><p>属性与方法：</p>
<ul>
<li>size：返回集合的元素个数</li>
<li>add：增加一个新元素，返回当前集合</li>
<li>delete：删除元素，返回 boolean 值</li>
<li>has：检测集合中是否包含某个元素，返回 boolean 值</li>
<li>clear：清空集合，返回 undefined</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">//声明一个 set
let s = new Set()
let s2 = new Set([&#39;大事儿&#39;, &#39;小事儿&#39;, &#39;好事儿&#39;, &#39;坏事儿&#39;, &#39;小事儿&#39;])
//元素个数
console.log(s2.size)
//添加新的元素
s2.add(&#39;喜事儿&#39;)
//删除元素
s2.delete(&#39;坏事儿&#39;)
//检测
console.log(s2.has(&#39;糟心事&#39;))
//清空
s2.clear()
console.log(s2)
// for of遍历
for (let v of s2) {
  console.log(v)
}
</code></pre>
</li>
<li><p>应用：</p>
<ul>
<li>数组去重</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">let arr = [1, 2, 3, 4, 5, 4, 3, 2, 1]
let result = [...new Set(arr)];
console.log(result);
</code></pre>
<ul>
<li>求交集</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">let arr2 = [4, 5, 6, 5, 6]
// 方法1：详细写法
let result = [...new Set(arr)].filter((item) =&gt; {
  let s2 = new Set(arr2) // 4 5 6
  if (s2.has(item)) {
    return true
  } else {
    return false
  }
})

// 方法2：简便写法
let result = [...new Set(arr)].filter((item) =&gt; new Set(arr2).has(item))
console.log(result)
</code></pre>
<ul>
<li>求并集</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">let union = [...new Set([...arr, ...arr2])];
console.log(union);
</code></pre>
<ul>
<li>求差集</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">let diff = [...new Set(arr)].filter((item) =&gt; !new Set(arr2).has(item))
console.log(diff)
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-15-map">2.15 高级对象 Map</h3>
<ol>
<li><p>定义：ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator接口，所以可以使用扩展运算符<code>...</code>展开、<code>for...of...</code>进行遍历。</p>
</li>
<li><p>属性与方法：</p>
<ul>
<li>size：返回 Map 的元素个数</li>
<li>set：增加一个新元素，返回当前 Map</li>
<li>get：返回键名对象的键值</li>
<li>has：检测 Map 中是否包含某个元素，返回 boolean 值</li>
<li>delete：删除元素，指定键名</li>
<li>clear：清空集合，返回 undefine</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">//声明 Map
let m = new Map()

//set：增加一个新元素，返回当前 Map
m.set(&#39;name&#39;, &#39;尚硅谷&#39;)
m.set(&#39;change&#39;, function () {
  console.log(&#39;我们可以改变你!!&#39;)
})
let key = {
  school: &#39;ATGUIGU&#39;,
}
m.set(key, [&#39;北京&#39;, &#39;上海&#39;, &#39;深圳&#39;])

//size：返回 Map 的元素个数
console.log(m.size)

//delete：删除元素，指定键名
m.delete(&#39;name&#39;)

//get：返回键名对象的键值
console.log(m.get(&#39;change&#39;))
console.log(m.get(key))

//clear：清空集合，返回 undefine
m.clear()

//for of：遍历，返回数组，第一个元素为键，第二个元素为值
for (let v of m) {
  console.log(v)
}
console.log(m);
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-16-module">2.16 模块化 Module</h3>
<h4 id="2-16-1-">2.16.1 模块化定义</h4>
<ol>
<li>定义：模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</li>
<li>优点：防止命名冲突、代码复用、高维护性。</li>
<li>ES6 之前的模块化规范产品：<ul>
<li>CommonJS =&gt; NodeJS、Browserify</li>
<li>AMD =&gt; requireJS</li>
<li>CMD =&gt; seaJS</li>
</ul>
</li>
</ol>
<h4 id="2-16-2-">2.16.2 模块化语法</h4>
<h5 id="2-16-2-1-export">2.16.2.1 暴露模块 export</h5>
<blockquote>
<p><code>export</code>：用于规定模块的对外接口</p>
</blockquote>
<ol>
<li><p>分别暴露</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 分别暴露
// m1.js
export let school = &#39;尚硅谷&#39;
export function teach() {
  console.log(&#39;我们可以教给你开发技能&#39;)
}
</code></pre>
</li>
<li><p>统一暴露</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 统一暴露
// m2.js
let school = &#39;尚硅谷&#39;
function findJob() {
  console.log(&#39;我们可以帮助你找工作!!&#39;)
}
export { school, findJob }
</code></pre>
</li>
<li><p>默认暴露</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 默认暴露
// m3.js
export default {
  school: &#39;ATGUIGU&#39;,
  change: function () {
    console.log(&#39;我们可以改变你!!&#39;)
  },
}
</code></pre>
</li>
</ol>
<h5 id="2-16-2-2-import">2.16.2.2 导入模块 import</h5>
<blockquote>
<p><code>import</code>：用于输入其他模块提供的功能（需要用 <code>&lt;script type=&quot;module&quot;&gt; &lt;/script&gt;</code>包裹）</p>
</blockquote>
<ol>
<li><p>通用导入：调用属性和方法时，需要用 m1.xxx、m2.xxx、m3.default.xxx</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;script type=&quot;module&quot;&gt;
    import * as m1 from &#39;./src/js/m1.js&#39;
    import * as m2 from &#39;./src/js/m2.js&#39;
    import * as m3 from &#39;./src/js/m3.js&#39;  // 注意：由于是默认暴露，调用m3的方法和属性时，需要用m3.default.xxx
&lt;/script&gt;
</code></pre>
</li>
<li><p>解构赋值导入：可以直接调用导入的属性和方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;script type=&quot;module&quot;&gt;
    import { school, teach } from &#39;./src/js/m1.js&#39;
    import { school as guigu, findJob } from &#39;./src/js/m2.js&#39;
    import { default as m3 } from &#39;./src/js/m3.js&#39;
&lt;/script&gt;
</code></pre>
</li>
<li><p>简便形式：针对默认暴露，可以直接用 m3.xxx 调用default默认暴露的属性和方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;script type=&quot;module&quot;&gt;
    import m3 from &#39;./src/js/m3.js&#39;
    console.log(m3)
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="2-16-2-3-">2.16.2.3 整体导入模块</h5>
<blockquote>
<p>整体导入模块：<code>&lt;script src=&quot;...&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></p>
</blockquote>
<ol>
<li><p>如果把需要导入的模块全部写在html下的script中，会显得很长，可以把需要导入的部分单独写成独立js入口文件，统一导入</p>
</li>
<li><p>缺点：兼容性问题，目前只有chrome等浏览器支持，并非所有浏览器都支持此方法</p>
<pre class="prettyprint linenums:0"><code class="lang-html">// index.html
&lt;script src=&quot;./src/js/app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// app.js（入口文件）
//模块引入
import * as m1 from &#39;./m1.js&#39;
import * as m2 from &#39;./m2.js&#39;
import * as m3 from &#39;./m3.js&#39;

console.log(m1);
console.log(m2);
console.log(m3);

m1.teach()
m2.findJob()
m3.default.change()
</code></pre>
</li>
</ol>
<h5 id="2-16-2-4-">2.16.2.4 动态导入模块</h5>
<ol>
<li><p>ES6导入是静态的，需要全部导入，不能实现懒加载（按需加载）。ES11可以用动态import导入，按需加载。</p>
</li>
<li><p>语法：<code>import(&#39;xxx.js&#39;).then((module)=&gt;{module.xxx()})</code>，then后面返回的是promise对象，对应的就是导入的模块，可以调用其属性和方法。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 模块：hello.js
export function hello() {
  alert(&#39;Hello&#39;)
}
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 入口文件：app.js
const btn = document.getElementById(&#39;btn&#39;)

btn.onclick = function () {
  import(&#39;./hello.js&#39;).then((module) =&gt; {
    module.hello()
  })
}
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// html页面
&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;
&lt;script src=&quot;./js/app.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
</ol>
<h4 id="2-16-3-babel-">2.16.3 Babel模块化转换</h4>
<ol>
<li><p>作用：解决其他浏览器无法整体导入模块，以及ES6无法直接导入npm模块的问题</p>
</li>
<li><p>官网：<a href="https://www.babeljs.cn/">www.babeljs.cn</a></p>
</li>
<li><p>步骤：</p>
<ul>
<li>配置环境：一次即可</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">// 安装工具：真正项目开发会使用 webpack 代替 browserify
npm init --yes
npm i babel-cli babel-preset-env browserify -D
</code></pre>
<ul>
<li>编译+打包：如果代码改动，需要重新编译打包</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">// 编译（如果是全局安装，省略npx，直接babel...
// 语法：npx babel 需要编译的代码目录 编译后代码存放目录 --presets=babel-preset-env
npx babel src/js -d dist/js --presets=babel-preset-env

// 打包
// 语法：npx browserify 入口文件目录app.js -o 打包文件目录bundle.js
npx browserify dist/js/app.js -o dist/bundle.js
</code></pre>
</li>
<li><p>整体导入模块：<code>&lt;script src=&quot;...bundle.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></p>
</li>
</ol>
<h4 id="2-16-4-npm-">2.16.4 引入npm包</h4>
<ol>
<li><p>安装所需的npm包：<code>npm i jquery</code></p>
</li>
<li><p>使用包：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// app.js（入口文件）

//修改背景颜色为粉色
import $ from &#39;jquery&#39; // 等价于const $ = require(&#39;jquery&#39;)
$(&#39;body&#39;).css(&#39;background&#39;, &#39;pink&#39;)
</code></pre>
</li>
<li><p>编译+打包：如果代码改动，需要重新编译打包（代码见上）</p>
</li>
<li><p>整体导入模块：<code>&lt;script src=&quot;...bundle.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></p>
</li>
</ol>
<hr>
<h3 id="2-17-promise">2.17 Promise</h3>
<h4 id="2-17-1-promise-">2.17.1 Promise的基本使用</h4>
<h5 id="2-17-1-1-promise-">2.17.1.1 Promise简介</h5>
<ol>
<li><p>抽象表达：</p>
<ul>
<li>Promise 是一门新的技术（ES6 规范）</li>
<li>Promise 是 JS 中进行异步编程的新解决方案（旧方案是单纯使用回调函数）</li>
<li>异步编程包括：<code>fs</code>、定时器、数据库操作、<code>ajax</code>等</li>
</ul>
</li>
<li><p>具体表达：</p>
<ul>
<li>从语法上来说: Promise 是一个构造函数</li>
<li>从功能上来说: Promise 对象用来封装一个异步操作并可以获取其成功或失败的结果值</li>
</ul>
</li>
<li><p>Promise的状态 <code>PromiseState</code>：只有以下2种, 且一个 promise 对象只能改变一次。无论变为成功还是失败, 都会有一个结果数据</p>
<ul>
<li>成功：pending 变为 resolved/fulfilled</li>
<li>失败：pending 变为 rejected</li>
</ul>
</li>
<li><p>Promise对象的值 <code>PromiseResult</code>：</p>
<ul>
<li>成功的结果数据: <code>value</code></li>
<li>失败的结果数据: <code>reason</code></li>
</ul>
</li>
<li><p>Promise 的基本流程：</p>
<p><img src="D:\MyProjects\Website\Tutoring\Web_Basic\Section4-JavaScript\Chapter07-Promise\资源\promise的基本流程.png" alt=""></p>
</li>
</ol>
<hr>
<h5 id="2-17-1-2-promise-">2.17.1.2 Promise优势</h5>
<ol>
<li><p>指定回调函数的方式更加灵活：</p>
<ul>
<li>旧方法：必须在启动异步任务前指定</li>
<li>promise：启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</li>
</ul>
</li>
<li><p>支持链式调用, 可以解决回调地狱问题：</p>
<ul>
<li>回调地狱：回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件。不便于阅读、不便于异常处理。</li>
<li>解决方案：promise 链式调用</li>
<li>终极解决方案：async与await</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">// 回调地狱
doSomething(function (result) {
  doSomethingElse(
    result,
    function (newResult) {
      doThirdThing(
        newResult,
        function (finalResult) {
          console.log(&#39;Got the final result: &#39; + finalResult)
        },
        failureCallback
      )
    },
    failureCallback
  )
}, failureCallback)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 使用 promise 的链式调用解决回调地狱
doSomething()
  .then(function (result) {
    return doSomethingElse(result)
  })
  .then(function (newResult) {
    return doThirdThing(newResult)
  })
  .then(function (finalResult) {
    console.log(&#39;Got the final result: &#39; + finalResult)
  })
  .catch(failureCallback)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// async+await: 回调地狱的终极解决方案
// 注意：doSomething()、doSomethingElse()、doThirdThing()函数需要返回的是Promise对象
async function request() {
  try {
    const result = await doSomething()
    const newResult = await doSomethingElse(result)
    const finalResult = await doThirdThing(newResult)
    console.log(&#39;Got the final result: &#39; + finalResult)
  } catch (error) {
    failureCallback(error)
  }
}
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-1-3-promise-">2.17.1.3 Promise基本案例</h5>
<ol>
<li><p>定时器模拟中奖：点击按钮, 1s 后显示是否中奖（30%概率中奖）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 若中奖弹出:恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券
// 若未中奖弹出:再接再厉

// 定时器实现
// 生成随机数
function rand(m, n) {
  return Math.ceil(Math.random() * (n - m + 1)) + m - 1
}
//获取元素对象
const btn = document.querySelector(&#39;#btn&#39;)

// 绑定单击事件
btn.addEventListener(&#39;click&#39;, function () {
  //定时器实现
  setTimeout(() =&gt; {
    // 30%中奖概率
    // 获取从1-100的一个随机数
    let n = rand(1, 100)
    //判断
    if (n &lt;= 30) {
      alert(&#39;恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券&#39;)
    } else {
      alert(&#39;再接再厉&#39;)
    }
  }, 1000)
})
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// Promise形式实现
// 生成随机数
function rand(m, n) {
  return Math.ceil(Math.random() * (n - m + 1)) + m - 1
}
//获取元素对象
const btn = document.querySelector(&#39;#btn&#39;)
// 绑定单击事件
btn.addEventListener(&#39;click&#39;, function () {
  //Promise形式实现
  const p = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      // 30%中奖概率
      // 获取从1-100的一个随机数
      let n = rand(1, 100)
      //判断
      if (n &lt;= 30) {
        resolve(n) // 将 promise 对象的状态设置为 『成功』
      } else {
        reject(n) // 将 promise 对象的状态设置为 『失败』
      }
    }, 1000)
  })
  console.log(p)
  //调用 then 方法
  p.then(
    (value) =&gt; {
      alert(&#39;恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券, 您的中奖数字为：&#39; + value)
    },
    (reason) =&gt; {
      alert(&#39;再接再厉, 您的号码为：&#39; + reason)
    }
  )
})
</code></pre>
</li>
<li><p>判断时间戳是否为奇数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 1.创建 promise 对象(pending 状态), 指定执行器函数
const p = new Promise((resolve, reject) =&gt; {
  // 2.在执行器函数中启动异步任务
  setTimeout(() =&gt; {
    const time = Date.now()
    // 3.根据结果做不同处理
    // 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态
    if (time % 2 === 1) {
      resolve(&#39;成功的值 &#39; + time)
    } else {
      // 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态
      reject(&#39;失败的值&#39; + time)
    }
  }, 2000)
})
// 4.指定成功或失败的回调函数来获取成功的 value 或失败的 reason
p.then(
  (value) =&gt; {
    // 成功的回调函数 onResolved, 得到成功的 value
    console.log(&#39;成功的 value: &#39;, value)
  },
  (reason) =&gt; {
    // 失败的回调函数 onRejected, 得到失败的 reason
    console.log(&#39;失败的 reason: &#39;, reason)
  }
)
</code></pre>
</li>
<li><p>与fs模块结合读取文件</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const fs = require(&#39;fs&#39;)

// 方法1：回调函数:
fs.readFile(&#39;./resource/content.txt&#39;, (err, data) =&gt; {
  // 如果出错 则抛出错误
  if (err) throw err
  //输出文件内容
  console.log(data.toString())
})

// 方法2：Promise 形式
let p = new Promise((resolve, reject) =&gt; {
  fs.readFile(&#39;./resource/content.txt&#39;, (err, data) =&gt; {
    //如果出错
    if (err) reject(err)
    //如果成功
    resolve(data)
  })
})

//调用 then
p.then(
  (value) =&gt; {
    console.log(value.toString())
  },
  (reason) =&gt; {
    console.log(reason)
  }
)
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-1-4-promise-">2.17.1.4 Promise封装功能</h5>
<ol>
<li><p>使用 promise 封装 fs 模块 (node.js)</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 封装一个函数 mineReadFile 读取文件内容
// 参数:  path  文件路径
// 返回:  promise 对象

function mineReadFile(path) {
  return new Promise((resolve, reject) =&gt; {
    //读取文件
    require(&#39;fs&#39;).readFile(path, (err, data) =&gt; {
      //判断
      if (err) reject(err)
      //成功
      resolve(data)
    })
  })
}

mineReadFile(&#39;./resource/content.txt&#39;).then(
  (value) =&gt; {
    //输出文件内容
    console.log(value.toString())
  },
  (reason) =&gt; {
    console.log(reason)
  }
)
</code></pre>
</li>
<li><p>使用 promise 封装基于定时器的异步</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function doDelay(time) {
  // 1.创建 promise 对象
  return new Promise((resolve, reject) =&gt; {
    // 2.启动异步任务
    console.log(&#39;启动异步任务&#39;)
    setTimeout(() =&gt; {
      console.log(&#39;延迟任务开始执行...&#39;)
      const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败
      if (time % 2 === 1) {
        // 成功了，调用 resolve()并传入成功的 value
        resolve(&#39;成功的数据 &#39; + time)
      } else {
        // 失败了，调用 reject()并传入失败的 reason
        reject(&#39;失败的数据 &#39; + time)
      }
    }, time)
  })
}

const promise = doDelay(2000)
promise.then(
  (value) =&gt; {
    console.log(&#39;成功的 value: &#39;, value)
  },
  (reason) =&gt; {
    console.log(&#39;失败的 reason: &#39;, reason)
  }
)
</code></pre>
</li>
<li><p>使用 promise 封装 Ajax 异步请求</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function promiseAjax(url) {
  return new Promise((resolve, reject) =&gt; {
    //1.创建对象
    const xhr = new XMLHttpRequest()
    //2. 初始化
    xhr.open(&#39;GET&#39;, url)
    //3. 发送
    xhr.send()
    //4. 处理响应结果
    xhr.onreadystatechange = () =&gt; {
      if (xhr.readyState !== 4) return
      const { status, response } = xhr
      // 请求成功, 调用 resolve(value)
      if (status &gt;= 200 &amp;&amp; status &lt; 300) {
        resolve(JSON.parse(response))
      } else {
        // 请求失败, 调用 reject(reason)
        reject(new Error(&#39;请求失败: status: &#39; + status))
      }
    }
  })
}

promiseAjax(&#39;https://api.apiopen.top/getJoke&#39;).then(
  (data) =&gt; {
    console.log(&#39;显示成功数据&#39;, data)
  },
  (error) =&gt; {
    alert(error.message)
  }
)
</code></pre>
</li>
</ol>
<h5 id="2-17-1-5-util-promisify-">2.17.1.5 util.promisify方法</h5>
<ol>
<li><p>第三方插件<code>util</code>：传入一个遵循常见错误优先的回调风格函数（即以<code>(err,value)=&gt;...</code>回调作为最后一个参数），并返回一个promise版本。可以使用它来达到用promise封装功能的效果。</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 封装fs读取模块（node.js）
// 引入 util 模块
const util = require(&#39;util&#39;)
// 引入 fs 模块
const fs = require(&#39;fs&#39;)
// 返回一个新的函数
let mineReadFile = util.promisify(fs.readFile)

mineReadFile(&#39;./resource/content.txt&#39;).then((value) =&gt; {
  console.log(value.toString()),
    (reason) =&gt; {
      console.log(reason)
    }
})
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-17-2-promise-api">2.17.2 Promise API</h4>
<h5 id="2-17-2-1-promise-">2.17.2.1 Promise构造函数</h5>
<blockquote>
<p>Promise (excutor) {}：executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行。</p>
</blockquote>
<ol>
<li><code>executor</code> 函数: 执行器 (resolve, reject) =&gt; {} </li>
<li><code>resolve</code> 函数: 内部定义成功时调用的函数 value =&gt; {}</li>
<li><code>reject</code>函数: 内部定义失败时调用的函数 reason =&gt; {}</li>
</ol>
<hr>
<h5 id="2-17-2-2-promise-prototype-then">2.17.2.2 Promise.prototype.then</h5>
<blockquote>
<p>Promise.prototype.then(onResolved, onRejected) =&gt; {}</p>
<p>指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调返回一个新的 promise 对象</p>
</blockquote>
<ol>
<li><code>onResolved</code> 函数: 成功的回调函数 (value) =&gt; {}</li>
<li><code>onRejected</code> 函数: 失败的回调函数 (reason) =&gt; {}</li>
</ol>
<hr>
<h5 id="2-17-2-3-promise-prototype-catch">2.17.2.3 Promise.prototype.catch</h5>
<blockquote>
<p>Promise.prototype.catch(onRejected) =&gt; {}，then()的语法糖, 但只能指定失败的回调函数，相当于: then(undefined, onRejected)</p>
</blockquote>
<ol>
<li><p>onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p>
<pre class="prettyprint linenums:0"><code class="lang-js">new Promise((resolve, reject) =&gt; {
  if (Date.now() % 2 === 0) {
    resolve(1)
  } else {
    reject(2)
  }
})
  .then((value) =&gt; {
    console.log(&#39;onResolved1()&#39;, value)
  })
  .catch((reason) =&gt; {
    console.log(&#39;onRejected1()&#39;, reason)
  })
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-2-4-promise-resolve">2.17.2.4 Promise.resolve</h5>
<blockquote>
<p>Promise.resolve(value) =&gt; {}，返回一个成功/失败的 promise 对象</p>
</blockquote>
<ol>
<li><p>value: 成功的数据或 promise 对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//如果传入的参数为：非Promise类型的对象, 则返回的结果为成功promise对象
let p1 = Promise.resolve(521)
//如果传入的参数为：Promise 对象, 则参数的结果决定了 resolve 的结果
let p2 = Promise.resolve(
  new Promise((resolve, reject) =&gt; {
    //   resolve(&#39;OK&#39;)
    reject(&#39;Error&#39;)
  })
)
console.log(p2)
p2.catch((reason) =&gt; {
  console.log(reason)
})
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-2-5-promise-reject">2.17.2.5 Promise.reject</h5>
<blockquote>
<p>Promise.reject(reason) =&gt; {}，返回一个失败的 promise 对象</p>
</blockquote>
<ol>
<li><p>reason: 失败的原因</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = Promise.reject(521)           // Promise {&lt;rejected&gt;: 521}
let p2 = Promise.reject(&#39;iloveyou&#39;)   // Promise {&lt;rejected&gt;: &#39;iloveyou&#39;}
let p3 = Promise.reject(              // Promise {&lt;rejected&gt;: Promise}
  new Promise((resolve, reject) =&gt; {
    resolve(&#39;OK&#39;)
  })
)
console.log(p3)
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-2-6-promise-all">2.17.2.6 Promise.all</h5>
<blockquote>
<p>Promise.all(promises) =&gt; {}，返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就直接失败</p>
</blockquote>
<ol>
<li><p>promises: 包含 n 个 promise 的数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p1 = new Promise((resolve, reject) =&gt; {
  resolve(&#39;OK&#39;)
})
let p2 = Promise.resolve(&#39;Success&#39;)
let p3 = Promise.reject(&#39;Error&#39;)
let p4 = Promise.resolve(&#39;Oh Yeah&#39;)

const pAll = Promise.all([p1, p2, p4])  // PromiseState: &quot;fulfilled&quot;, PromiseResult: [&quot;OK&quot;, &quot;Success&quot;, &quot;Oh Yeah&quot;]
const pAll2 = Promise.all([p1, p3, p4]) // PromiseState: &quot;rejected&quot;, PromiseResult: &quot;Error&quot;

pAll.then(
  (values) =&gt; {
    console.log(&#39;all 成功了&#39;, values)
  },
  (reason) =&gt; {
    console.log(&#39;all 失败了&#39;, reason)
  }
)
pAll2.then(
  (values) =&gt; {
    console.log(&#39;all 成功了&#39;, values)
  },
  (reason) =&gt; {
    console.log(&#39;all 失败了&#39;, reason)
  }
)
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-2-8-promise-allsettled">2.17.2.8 Promise.allSettled</h5>
<blockquote>
<p>Promise.allSettled(promises) =&gt; {}，返回一个新的 promise, PromiseState始终为&quot;fulfilled&quot;，PromiseResult为数组，其成员为原始数组中promise的返回对象，包含states、value或reason。</p>
</blockquote>
<ol>
<li><p>promises: 包含 n 个 promise 的数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">//声明两个promise对象
const p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;商品数据 - 1&#39;)
  }, 1000)
})
const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    // resolve(&#39;商品数据 - 2&#39;)
    reject(&#39;出错啦!&#39;)
  }, 1000)
})

//调用 allSettled 方法
const result = Promise.allSettled([p1, p2])
console.log(result)
</code></pre>
</li>
</ol>
<hr>
<h5 id="2-17-2-7-promise-race">2.17.2.7 Promise.race</h5>
<blockquote>
<p>Promise.race(promises) =&gt; {}，返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p>
</blockquote>
<ol>
<li><p>promises: 包含 n 个 promise 的数组</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;OK&#39;)
  }, 1000)
})
let p2 = Promise.resolve(&#39;Success&#39;)
let p3 = Promise.resolve(&#39;Oh Yeah&#39;)
const pRace = Promise.race([p1, p2, p3]) // PromiseState: &quot;fulfilled&quot;, PromiseResult: &quot;Success&quot;
pRace.then(
  (value) =&gt; {
    console.log(&#39;race 成功了&#39;, value)
  },
  (reason) =&gt; {
    console.log(&#39;race 失败了&#39;, reason)
  }
)
</code></pre>
</li>
</ol>
<hr>
<h4 id="2-17-3-promise-">2.17.3 Promise的关键问题</h4>
<ol>
<li><p>如何改变 Promise 的状态?</p>
<p>(1) resolve(value): 如果当前是 pending 就会变为 resolved</p>
<p>(2) reject(reason): 如果当前是 pending 就会变为 rejected</p>
<p>(3) 抛出异常 throw(&#39;error&#39;): 如果当前是 pending 就会变为 rejected</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {
  // 1. resolve 函数
  // resolve(&#39;ok&#39;);   // pending =&gt; fulfilled (resolved)
  // 2. reject 函数
  // reject(&quot;error&quot;); // pending =&gt;  rejected
  // 3. 抛出错误
  throw &#39;出问题了&#39;
})
console.log(p)
</code></pre>
</li>
<li><p>一个 Promise 指定多个成功/失败回调函数, 都会调用吗？</p>
<ul>
<li>当 promise 改变为对应状态时都会调用</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {
  // resolve(&#39;OK&#39;) // 如果里面不写resolve或reject，promise状态一直为pending，下面的回调不会执行
  reject(&#39;error&#39;)
})

//指定回调-1
p.then(
  (value) =&gt; {
    console.log(value)
  },
  (reason) =&gt; {
    console.warn(reason)
  }
)
//指定回调-2
p.then(
  (value) =&gt; {
    alert(value)
  },
  (reason) =&gt; {
    alert(reason)
  }
)
</code></pre>
</li>
<li><p>改变 Promise 状态和指定回调函数谁先谁后？</p>
<p>(1) 都有可能, 同步任务是先改变状态、再指定回调，异步任务是先指定回调、再改变状态</p>
<p>(2) 如何先改状态再指定回调？</p>
<ul>
<li><p>在执行器中直接调用 resolve()/reject()</p>
</li>
<li><p>延迟更长时间才调用 then()</p>
</li>
</ul>
<p>(3) 什么时候才能得到数据？</p>
<ul>
<li>如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</li>
<li>如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">// 同步任务：先改变状态，再指定回调
let p = new Promise((resolve, reject) =&gt; {
  resolve(&#39;OK&#39;)
})

p.then(
  (value) =&gt; {
    console.log(value)
  },
  (reason) =&gt; {}
)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 异步任务：先指定回调，再改变状态
let p = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;OK&#39;)
  }, 1000)
})
p.then(
  (value) =&gt; {
    console.log(value)
  },
  (reason) =&gt; {}
)
</code></pre>
</li>
<li><p>Promise.then()返回的新 promise 的结果状态由什么决定？</p>
<p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定</p>
<p>(2) 详细表达:</p>
<ul>
<li>如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</li>
<li>如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</li>
<li>如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {
  resolve(&#39;ok&#39;)
  // reject(&#39;Error&#39;)
})
//执行 then 方法
let result = p.then(
  (value) =&gt; {
    //1. 抛出错误：新 promise 变为 rejected, reason 为抛出的异常
    //   throw &#39;出了问题&#39;

    //2. 返回结果是非 Promise 类型的对象：新 promise 变为 resolved, value 为返回的值
    // return 521

    //3. 返回结果是 Promise 对象：新 promise 的结果就会成为新 promise 的结果
    return new Promise((resolve, reject) =&gt; {
      // resolve(&#39;success&#39;)
      reject(&#39;error2&#39;)
    })
  },
  (reason) =&gt; {
    console.warn(reason)
  }
)
console.log(result)
</code></pre>
</li>
<li><p>Promise 如何串连多个操作任务？</p>
<p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用</p>
<p>(2) 通过 then 的链式调用串连多个同步/异步任务</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;OK&#39;)
  }, 1000)
})
p.then((value) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    resolve(&#39;success&#39;)
  })
})
  .then((value) =&gt; {
    console.log(value) // &#39;success&#39;
  })
  .then((value) =&gt; {
    console.log(value) // undefined（因为由then()指定的回调函数执行的结果决定）
  })
</code></pre>
</li>
<li><p>Promise 异常穿透？</p>
<p>(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</p>
<p>(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;OK&#39;)
    // reject(&#39;Err&#39;) // 如果开启此行代码，提示的错误就是&#39;Err&#39;
  }, 1000)
})
p.then((value) =&gt; {
  console.log(111)
  throw &#39;失败啦!&#39;    // 如果前面没有错误，则最终提示的错误是：&#39;失败啦!&#39;
})
  .then((value) =&gt; {
    console.log(222)
  })
  .then((value) =&gt; {
    console.log(333)
  })
  .catch((reason) =&gt; {
    console.warn(reason)
  })
</code></pre>
</li>
<li><p>中断 Promise 链？</p>
<p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p>
<p>(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&#39;OK&#39;)
  }, 1000)
})
p.then((value) =&gt; {
  console.log(111)
  // 有且只有一个方式中断 Promise 链
  return new Promise(() =&gt; {})
})
  .then((value) =&gt; {
    console.log(222)
  })
  .then((value) =&gt; {
    console.log(333)
  })
  .catch((reason) =&gt; {
    console.warn(reason)
  })
</code></pre>
</li>
</ol>
<hr>
<h3 id="2-18-async-await">2.18 async与await</h3>
<h4 id="2-18-1-async-">2.18.1 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async函数</a></h4>
<ol>
<li><p>函数的返回值为 promise 对象</p>
</li>
<li><p>promise 对象的结果由 async 函数执行的返回值决定</p>
<pre class="prettyprint linenums:0"><code class="lang-js">async function main() {
  // 1. 如果返回值是一个非Promise类型的数据：return一个成功状态的promise
  // PromiseState: &quot;fulfilled&quot;, PromiseResult: 521
  return 521
  // PromiseState:&#39;fulfilled&#39;，PromiseResult:undefined
  return

  // 2. 如果返回的是一个Promise对象：return一个与该promise对象状态相同的promise对象
  return new Promise((resolve, reject) =&gt; {
    resolve(&#39;OK&#39;)   // PromiseState: &quot;fulfilled&quot;, PromiseResult: &quot;OK&quot;
    reject(&#39;Error&#39;) //  PromiseState: &quot;rejected&quot;, PromiseResult: &quot;Error&quot;
  })

  // 3. 抛出异常：返回一个失败状态的promise
  //  PromiseState: &quot;rejected&quot;, PromiseResult: &quot;Oh NO&quot;
  throw &#39;Oh NO&#39;
}
let result = main()
// 如果想直接返回promise值（value或reason），可以用then
result.then(
  (value) =&gt; {
    console.log(value)
  },
  (reason) =&gt; {
    console.warn(reason)
  }
)
</code></pre>
</li>
</ol>
<h4 id="2-18-2-await-">2.18.2 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await表达式</a></h4>
<ol>
<li><p>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</p>
</li>
<li><p>如果表达式是 promise 对象, await 返回的是 promise 成功的值</p>
</li>
<li><p>如果表达式是其它值, 直接将此值作为 await 的返回值</p>
</li>
<li><p>await 必须写在 async 函数中, 但 async 函数中可以没有 await</p>
</li>
<li><p>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理</p>
<pre class="prettyprint linenums:0"><code class="lang-js">async function main() {
  let p = new Promise((resolve, reject) =&gt; {
    // resolve(&#39;OK&#39;)
    reject(&#39;Error&#39;)
  })
  //1. 右侧为promise的情况：返回promise成功的值：&#39;OK&#39;
  let res = await p
  console.log(res)

  //2. 右侧为其他类型的数据：20
  let res2 = await 20
  console.log(res2)

  //3. 如果promise是失败的状态：res、res2、res3都不会执行，直接执行catch部分
  try {
    let res3 = await p
    console.log(res3)
  } catch (e) {
    console.log(e)
  }
}
main()
</code></pre>
</li>
</ol>
<h4 id="2-18-3-async-await-">2.18.3 async与await结合</h4>
<ol>
<li><p>使用fs读取文件内容</p>
<pre class="prettyprint linenums:0"><code class="lang-js">const fs = require(&#39;fs&#39;)
const util = require(&#39;util&#39;)
// util.promisify可以返回一个promise对象，免去封装过程
const mineReadFile = util.promisify(fs.readFile)

//async 与 await
async function main() {
  try {
    //读取第一个文件的内容
    let data1 = await mineReadFile(&#39;./resource/1x.html&#39;)
    let data2 = await mineReadFile(&#39;./resource/2.html&#39;)
    let data3 = await mineReadFile(&#39;./resource/3.html&#39;)
    console.log(data1 + data2 + data3)
  } catch (e) {
    console.log(e.code)
  }
}

main()
</code></pre>
</li>
<li><p>封装Ajax请求</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function sendAJAX(url) {
  return new Promise((resolve, reject) =&gt; {
    const xhr = new XMLHttpRequest()
    xhr.responseType = &#39;json&#39;
    xhr.open(&#39;GET&#39;, url)
    xhr.send()
    //处理结果
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        //判断成功
        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {
          //成功的结果
          resolve(xhr.response)
        } else {
          reject(xhr.status)
        }
      }
    }
  })
}
let btn = document.querySelector(&#39;#btn&#39;)
btn.addEventListener(&#39;click&#39;, async function () {
  try {
    let duanzi = await sendAJAX(&#39;https://api.apiopen.top/getJoke&#39;)
    console.log(duanzi)
  } catch (e) {
    alert(e)
  }
})
</code></pre>
</li>
</ol>
<hr>
<h2 id="-3-web-api">第3章 Web API</h2>
<blockquote>
<p>API：Application Progamming Interface，应用程序接口，无需关心内部构造，直接调用即可</p>
</blockquote>
<h3 id="3-0-">3.0 常用方法集锦</h3>
<ol>
<li><p><code>console.dir</code>：显示元素对象的属性和方法</p>
</li>
<li><p><code>document.write()</code>：如果页面文档流加载完毕，再调用这句话会导致页面重绘，例：document.write(&#39;<div>123</div>&#39;)</p>
</li>
<li><p><code>window.onload=function(){}</code>：页面加载完毕再执行JS的函数</p>
</li>
<li><p><code>window.parent.XXX()</code>：如果存在页面嵌套（如iframe），子页面可以跳到父页面js中的方法</p>
</li>
<li><p>阻止链接<code>&lt;a&gt;</code>跳转：<code>href=javascript:void(0)&#39;</code>或 <code>href=javascript:;</code></p>
</li>
<li><p>立即执行函数：<code>(function(){})()</code>、<code>(function(){}())</code></p>
</li>
<li><p>flag开关：</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button id=&quot;btn&quot;&gt;开关灯&lt;/button&gt;
&lt;script&gt;
  var btn = document.getElementById(&#39;btn&#39;)
  var flag = 0
  btn.onclick = function () {
    if (flag == 0) {
      document.body.style.backgroundColor = &#39;black&#39;
      flag = 1
    } else {
      document.body.style.backgroundColor = &#39;#fff&#39;
      flag = 0
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h3 id="3-1-api-">3.1 API基本概念</h3>
<h4 id="3-1-1-api-">3.1.1 API简介</h4>
<ol>
<li>Web API：浏览器提供的一套操作浏览器功能和页面元素的API，包括DOM、BOM</li>
<li><p>书写顺序：文档页面从上到下加载，所以先写HTML标签，<code>&lt;script&gt;</code>写到标签的最下面</p>
</li>
<li><p>常用命令：<code>console.dir</code>：显示元素对象的属性和方法</p>
</li>
</ol>
<h4 id="3-1-2-api-">3.1.2 API重要概念</h4>
<h5 id="-">回调函数</h5>
<ol>
<li>定义：callback，即需要等待时间才去调用函数</li>
<li>定时器：<code>setTimeout()</code>、<code>setInterval()</code></li>
<li>注册事件中的函数，如addEventListener(&#39;click&#39;,fn）中的fn</li>
</ol>
<h5 id="this-">this指向</h5>
<ol>
<li><p>指向window</p>
<p>1）全局作用域：<code>console.log(this)</code></p>
<p>2）普通函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function fn() {
  console.log(this)
}
window.fn()
</code></pre>
<p> 3）计时器</p>
<pre class="prettyprint linenums:0"><code class="lang-js"> // 注意：定时器里面的函数不能用this代替元素
 window.setTimeout(function () {
   console.log(this)
 }, 1000)
</code></pre>
</li>
<li><p>指向调用它的对象</p>
<p>1）方法调用</p>
<pre class="prettyprint linenums:0"><code class="lang-js"> var o = {
   sayHi: function () {
     console.log(this) // this指向的是 o 这个对象
   },
 }
 o.sayHi()

 var btn = document.querySelector(&#39;button&#39;)
  btn.onclick = function () {
   console.log(this) // this指向的是btn这个按钮对象
 }
 btn.addEventListener(&#39;click&#39;, function () {
   console.log(this) // this指向的是btn这个按钮对象
 })
</code></pre>
<p>2）构造函数</p>
<p> <code>`</code>js
 function Fun() {
   console.log(this) // this 指向的是fun 实例对象
 }
 var fun = new Fun()</p>
</li>
</ol>
<h5 id="js-">JS执行机制</h5>
<ol>
<li><p>JS是单线程：同一个时间只能做一件事，所有的任务需要排队执行，可能会造成阻塞、渲染不连贯</p>
</li>
<li><p>同步：前一个任务结束后再执行后一个任务，按顺序进行</p>
<p>同步任务：都在主线程上执行，形成一个执行栈</p>
</li>
<li><p>异步：同时处理多个任务，目前 JS 默认是异步的</p>
<p>异步任务：通过回调函数实现，放在任务队列（消息队列）中</p>
<p>1）普通事件：<code>click</code>、<code>resize</code></p>
<p>2）资源加载：<code>load</code>、<code>error</code></p>
<p>3）定时器：<code>setTimeout</code>、<code>setInterval</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 问题1：结果：1、2、3
console.log(1)
setTimeout(function () {
  console.log(3)
}, 1000)
console.log(2)

// 问题2：结果：1、2、3
console.log(1)
setTimeout(function () {
  console.log(3)
}, 0)
console.log(2)

// 问题3：结果：1、2、3、cilck出现位置取决于何时点击
console.log(1)
document.onclick = function () {
  console.log(&#39;click&#39;)
}
console.log(2)
setTimeout(function () {
  console.log(3)
}, 3000)
</code></pre>
</li>
<li><p>执行机制：先执行执行栈中的同步任务</p>
<p>1）异步任务（回调函数）放到任务队列中：是先给异步进程处理，判断时间先后顺序，再放入任务队列</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 例：多个异步任务，有点击事件、倒计时等，如果点击先于倒计时，则先执行点击，否则先执行倒计时
console.log(1)
document.onclick = function () {
  console.log(&#39;click&#39;)
}
console.log(2)
setTimeout(function () {
  console.log(3)
}, 3000)
</code></pre>
<p>2）一旦执行栈中的所有同步任务执行完毕，系统按次序读取任务队列中的异步任务，被读取的异步任务结束等待状态，进入执行栈执行</p>
<p>3）事件循环（event loop）：主线程不断重复获得任务、执行任务的机制</p>
</li>
</ol>
<h5 id="-">立即执行函数</h5>
<ol>
<li><p>定义：不需要调用，立刻能够自己执行的函数</p>
</li>
<li><p>特点：独立创建了一个作用域，里面所有的变量都是局部变量，不会有命名冲突的情况</p>
</li>
<li><p>语法：第一个括号定义参数，第二个括号既可以传参、也有调用的作用</p>
<p>1）方法1：<code>(function(){})()</code></p>
<p>2）方法2：<code>(function(){}())</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">;(function (a, b) {
  console.log(a + b)
  var num = 10
})(1, 2) // 第二个小括号可以看做是调用函数

;(function sum(a, b) {
  console.log(a + b)
  var num = 10 // 局部变量
})(2, 3)
</code></pre>
</li>
</ol>
<hr>
<h3 id="3-2-dom">3.2 DOM</h3>
<blockquote>
<p>文档对象模型 (Document Object Model) 是HTML和XML文档的编程接口，它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构、样式和内容。</p>
</blockquote>
<h4 id="3-2-1-dom-">3.2.1 DOM简介</h4>
<ol>
<li>文档：document，一个页面即一个文档</li>
<li>元素：element，页面中所有标签都是元素</li>
<li>节点：node，网页中所有内容都是节点，如标签、属性、文本、注释等</li>
<li>对象：DOM把文档、元素、节点都看做是对象</li>
</ol>
<hr>
<h4 id="3-2-2-">3.2.2 获取元素</h4>
<ol>
<li><p><code>document.getElementById（id名）</code>：根据id获取元素</p>
<p>1）语法：var element = document.getElementById(id)</p>
<p>2）参数：id 是大小写敏感的字符串</p>
<p>3）返回：一个元素对象</p>
<pre class="prettyprint linenums:0"><code class="lang-html">// 案例：点击隐藏或显示密码
&lt;div class=&quot;box&quot;&gt;
  &lt;label for=&quot;&quot;&gt;
    &lt;img src=&quot;images/close.png&quot; alt=&quot;&quot; id=&quot;eye&quot; /&gt;
  &lt;/label&gt;
  &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;pwd&quot; /&gt;
&lt;/div&gt;

&lt;script&gt;
  // 1. 获取元素
  var eye = document.getElementById(&#39;eye&#39;)
  var pwd = document.getElementById(&#39;pwd&#39;)
  // 2. 注册事件
  var flag = 0
  eye.onclick = function () {
    // 点击一次之后， flag 一定要变化
    if (flag == 0) {
      pwd.type = &#39;text&#39;
      eye.src = &#39;images/open.png&#39;
      flag = 1 // 赋值操作
    } else {
      pwd.type = &#39;password&#39;
      eye.src = &#39;images/close.png&#39;
      flag = 0
    }
  }
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>document.getElementsByTagName（标签名）</code>：根据html标签获取元素</p>
<p>1）语法：var element = document.getElementsByTagName(标签名)</p>
<p>2）返回：带有指定标签名对象的集合，以伪数组的形式存储（HTMLCollection(n)）</p>
<p>3）获取父元素中的子元素</p>
<ul>
<li><p>方法1：element.getElementsByTagName(&#39;标签名&#39;)，父元素必须是指定的单个元素</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var ol = document.getElementsByTagName(&#39;ol&#39;)
console.log(ol[0].getElementsByTagName(&#39;li&#39;))
</code></pre>
</li>
<li><p>方法2：给父元素指定id，配合getElementById使用</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var ol = document.getElementById(&#39;ol&#39;)
console.log(ol.getElementsByTagName(&#39;li&#39;))
</code></pre>
</li>
</ul>
</li>
<li><p><code>document.getElementsByClassName（类名）</code>：根据class获取元素</p>
<p>1）语法：var element = document.getElementsByClassName(类名)</p>
<p>2）返回：带有指定类名对象的集合，以伪数组的形式存储</p>
</li>
<li><p><code>document.querySelector（选择器名）</code>：根据选择器名获取元素（仅返回第一个元素）</p>
<p>1）语法：var element = document.querySelector(选择器名)，选择器要加符号（eg: .box，#nav)</p>
<p>2）返回：根据指定选择器返回第一个元素对象</p>
<p>3）注意：如果直接写标签选择器（如：li），前面不用加符号，也是选出第一个标签元素</p>
</li>
<li><p><code>document.querySelectorAll（选择器名）</code>：根据选择器名获取元素（返回全部元素）</p>
<p>1）返回：指定选择器的所有元素对象集合（NodeList(n)）</p>
<p>2）可以配合使用：选中父元素中所有子元素的集合</p>
<pre class="prettyprint linenums:0"><code class="lang-js">document.querySelector(&#39;father&#39;).querySelectorAll(&#39;children&#39;)
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">// 案例：循环精灵图
&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
    var lis = document.querySelectorAll(&#39;li&#39;)
    for (var i = 0; i &lt; lis.length; i++) {
      // 让索引号乘以44，就是每个li的背景y坐标，x坐标都为0
      var index = i * 44
      lis[i].style.backgroundPosition = &#39;0 -&#39; + index + &#39;px&#39;
    }
&lt;/script&gt;
</code></pre>
</li>
<li><p>特殊元素：</p>
<p>1）body元素：<code>document.body</code></p>
<p>2）html元素：<code>document.documentElement</code></p>
</li>
</ol>
<hr>
<h4 id="3-2-3-">3.2.3 事件</h4>
<h5 id="3-2-3-1-">3.2.3.1 事件介绍</h5>
<h6 id="-">事件三要素</h6>
<ol>
<li>事件源：事件被触发的对象，如按钮</li>
<li>事件类型：如何触发事件，如鼠标点击/经过</li>
<li>事件处理程序：通过一个函数赋值的方式完成</li>
</ol>
<h6 id="-">事件执行步骤</h6>
<ol>
<li><p>获取事件源</p>
</li>
<li><p>绑定事件（注册事件）</p>
</li>
<li><p>添加事件处理程序（函数赋值）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;button id=&quot;btn&quot;&gt;唐伯虎&lt;/button&gt;

var btn = document.getElementById(&#39;btn&#39;)
btn.onclick = function () {
  alert(&#39;点秋香&#39;)
}
</code></pre>
</li>
</ol>
<h6 id="dom-">DOM事件流：捕获与冒泡</h6>
<ol>
<li><p>定义：事件流描述的是从页面中接收事件的顺序，事件发生时会在元素节点之间按照特定的顺序传播，传播过程称为DOM事件流</p>
</li>
<li><p>三阶段：</p>
<p>1）捕获阶段：由网景提出，由DOM最顶层节点开始，逐级向下传播到最具体的元素接收的过程</p>
<ul>
<li>如果 addEventListener 第三个参数是 <code>true</code>，那么则处于捕获阶段</li>
<li>从外往里执行：document -&gt; html -&gt; body -&gt; father -&gt; son</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 捕获阶段：addEventListener 第三个参数是 true
  var son = document.querySelector(&#39;.son&#39;)
  son.addEventListener(
    &#39;click&#39;,
    function () {
      alert(&#39;son&#39;)
    },
    true
  )
  var father = document.querySelector(&#39;.father&#39;)
  father.addEventListener(
    &#39;click&#39;,
    function () {
      alert(&#39;father&#39;)
    },
    true
  )
&lt;/script&gt;  
</code></pre>
<p>2）目标阶段</p>
<p>3）冒泡阶段：由IE提出，事件开始时由最具体的元素接收，逐级向上传播到DOM最顶层节点的过程</p>
<ul>
<li>onclick、attachEvent只能得到冒泡阶段</li>
<li>如果 addEventListener 第三个参数是 <code>false</code> 或省略，那么则处于冒泡阶段</li>
<li>从里往外执行：son -&gt; father -&gt;body -&gt; html -&gt; document</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 冒泡阶段：addEventListener 第三个参数是 false 或 省略
  var son = document.querySelector(&#39;.son&#39;)
  son.addEventListener(
    &#39;click&#39;,
    function () {
      alert(&#39;son&#39;)
    },
    false
  )
  var father = document.querySelector(&#39;.father&#39;)
  father.addEventListener(
    &#39;click&#39;,
    function () {
      alert(&#39;father&#39;)
    },
    false
  )
  document.addEventListener(&#39;click&#39;, function () {
    alert(&#39;document&#39;)
  })
&lt;/script&gt;  
</code></pre>
</li>
</ol>
<ol start="3">
<li><p>JS代码中只能执行捕获、冒泡其中之一的阶段</p>
</li>
<li><p>有些事件没有冒泡：onblur、onfocus、onmouseenter、onmouseleave</p>
</li>
</ol>
<hr>
<h5 id="3-2-3-2-">3.2.3.2 事件对象</h5>
<h6 id="-">基本概念</h6>
<ol>
<li><p>event 就是一个事件对象，写到侦听函数的小括号里面，当形参来看</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var div = document.querySelector(&#39;div&#39;)
div.onclick = function (event) {
  console.log(window.event)
  console.log(event)
}
</code></pre>
</li>
<li><p>事件对象只有有了事件才会存在，是系统自动创建的，不需要传递参数</p>
</li>
<li><p>事件对象是事件的一系列相关数据的集合，如鼠标点击包含了鼠标相关信息（坐标），键盘事件包含键盘事件信息（按键）</p>
</li>
<li><p>事件对象可以自己命名，如 event、evt、e</p>
</li>
<li><p>事件对象也有兼容性问题：ie678 通过 window.event 兼容性的写法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var div = document.querySelector(&#39;div&#39;)
div.onclick = function (e) {
  e = e || window.event;
  console.log(e)
}
</code></pre>
</li>
</ol>
<h6 id="-">属性和方法</h6>
<ol>
<li><p><code>e.target</code>：返回触发事件的对象（标准）</p>
<p>1）e.target：返回的是触发事件的对象（元素），点击了哪个元素，就返回哪个元素</p>
<p>2）this：返回的是绑定事件的对象（元素），哪个元素绑定了这个点击事件，那么就返回谁</p>
<p>3）e.currentTarget：和this效果相同，但是不兼容IE6-8，不如直接用this</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul&gt;
  &lt;li&gt;abc&lt;/li&gt;
  &lt;li&gt;abc&lt;/li&gt;
  &lt;li&gt;abc&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  // e.target：返回的是触发事件的对象（元素）：点击了哪个元素，就返回哪个元素
  // this：返回的是绑定事件的对象（元素）：哪个元素绑定了这个点击事件，那么就返回谁
  var ul = document.querySelector(&#39;ul&#39;)
  ul.addEventListener(&#39;click&#39;, function (e) {
    console.log(this)                // ul绑定了点击事件，返回ul
    console.log(e.currentTarget)    // ul绑定了点击事件，返回ul
    console.log(e.target)            // 点击谁，返回谁
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>e.srcElement</code>：返回触发事件的对象（非标准，IE6-8使用）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;123&lt;/div&gt;
&lt;script&gt;
  div.onclick = function (e) {
    e = e || window.event
    var target = e.target || e.srcElement
    console.log(target)
  }
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>e.type</code>：返回事件类型，如：click、mouseover，前面不带on</p>
</li>
<li><p>阻止冒泡：</p>
<p>1）<code>e.stopPropagation()</code>：标准写法</p>
<p>2）<code>e.canceBubble=true</code>：非标准，IE6-8使用</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 常见事件对象的属性和方法
  // 阻止冒泡  dom 推荐的标准 stopPropagation()
  var son = document.querySelector(&#39;.son&#39;)
  son.addEventListener(
    &#39;click&#39;,
    function (e) {
      alert(&#39;son&#39;)
      e.stopPropagation() // stop 停止 Propagation 传播
      // e.cancelBubble = true // 非标准 cancel 取消 bubble 泡泡
    },
    false
  )
  var father = document.querySelector(&#39;.father&#39;)
  father.addEventListener(
    &#39;click&#39;,
    function () {
      alert(&#39;father&#39;)
    },
    false
  )
  document.addEventListener(&#39;click&#39;, function () {
    alert(&#39;document&#39;)
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<ol start="5">
<li><p>阻止默认事件：如不让链接跳转等</p>
<p>1）<code>e.preventDefault()</code>：标准方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var a = document.querySelector(&#39;a&#39;)
a.onclick = function (e) {
  // 普通浏览器：e.preventDefault()方法
  e.preventDefault()
}
</code></pre>
<p>2）<code>e.returnValue</code>：非标准方法，IE6-8使用</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var a = document.querySelector(&#39;a&#39;)
a.onclick = function (e) {
  // 低版本浏览器 ie678：returnValue 属性
  e.returnValue
}
</code></pre>
<p>3）<code>return false</code>：也能阻止默认行为，没有兼容性问题，但return后面的代码不执行，且只限于传统的注册方式</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var a = document.querySelector(&#39;a&#39;)
a.onclick = function (e) {
  return false
  alert(11) // 不会执行此行代码了
}
</code></pre>
</li>
<li><p><code>e.persisted</code>：返回true代表页面从是缓存中取出的，返回false代表不是从缓存取出的，常与pageshow事件搭配使用</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;pageshow&#39;, function (e) {
  // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小
  if (e.persisted) {
    setRemUnit()
  }
})
</code></pre>
</li>
</ol>
<hr>
<h5 id="3-2-3-3-">3.2.3.3 注册事件</h5>
<ol>
<li><p>传统方式：</p>
<p>1）以on开头的事件，如：onclick</p>
<p>2）特点：唯一性，同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var btns = document.querySelectorAll(&#39;button&#39;)
// 1. 传统方式注册事件
btns[0].onclick = function () {
  alert(&#39;hi&#39;)
}
</code></pre>
</li>
<li><p><code>addEventListener()</code>：方法监听注册</p>
<p>1）语法：<code>eventTarget.addEventListener(type,listener,[,useCapture])</code></p>
<p>2）参数：</p>
<ul>
<li>type：事件类型字符串，必须加引号，如：click, mouseover，前面无需加on</li>
<li>listener：事件处理函数，事件发生时，会调用该监听函数</li>
<li>userCapture：DOM事件流方向，可选，布尔值，默认false（冒泡阶段）</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">var btns = document.querySelectorAll(&#39;button&#39;)
// 1. 传统方式注册事件
btns[1].addEventListener(&#39;click&#39;, function () {
  alert(22)
})
</code></pre>
</li>
<li><p><code>attachEvent()</code>：方法监听注册，IE9之前的方法</p>
<p>1）语法：<code>attachEvent(eventNameWithOn, callback)</code></p>
<p>2）参数：</p>
<ul>
<li>eventNameWithOn：事件类型字符串，必须加引号，如：onclick, onmouseover，前面需要加on</li>
<li>callback：事件处理函数，目标出发事件时调用回调函数</li>
</ul>
</li>
<li><p>兼容性处理函数：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function addEventListener(element, eventName, fn) {
  // 判断当前浏览器是否支持 addEventListener 方法
  if (element.addEventListener) {
    element.addEventListener(eventName, fn) // 第三个参数默认是false
  } else if (element.attachEvent) {
    element.attachEvent(&#39;on&#39; + eventName, fn)
  } else {
    // 相当于 element.onclick = fn;
    element[&#39;on&#39; + eventName] = fn
  }
}
</code></pre>
</li>
</ol>
<hr>
<h5 id="3-2-3-4-">3.2.3.4 删除事件</h5>
<ol>
<li><p><code>eventTarget.onclick = null</code>：传统方式，需要写到函数的末尾</p>
<pre class="prettyprint linenums:0"><code class="lang-js">divs[0].onclick = function () {
  alert(11)
  // 传统方式删除事件
  divs[0].onclick = null
}
</code></pre>
</li>
<li><p><code>removeEventListener()</code>：方法监听注册</p>
<p>1）语法：<code>eventTarget.removeEventListener(type,listener[,useCapture])</code></p>
<p>2）需要移除的事件函数不能是匿名函数，否则无法移除，要把removeEventListener写到需要删除的函数末尾</p>
<pre class="prettyprint linenums:0"><code class="lang-js">divs[1].addEventListener(&#39;click&#39;, fn)
function fn() {
  alert(22)
  divs[1].removeEventListener(&#39;click&#39;, fn)
}
</code></pre>
</li>
<li><p><code>deachEvent()</code>：方法监听注册，IE9之前的方法</p>
<p>1）语法：<code>deachEvent(eventNameWithOn,callback)</code></p>
<p>2）同样写到需要删除函数事件的末尾</p>
</li>
</ol>
<hr>
<h5 id="3-2-3-5-">3.2.3.5 事件委托</h5>
<ol>
<li><p>定义：不给每个子节点单独设置事件监听器，而将其设置在父节点上，利用冒泡原理影响设置每个子节点</p>
</li>
<li><p>作用：只操作一次DOM，提高程序性能</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul&gt;
  &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
  &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
  &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  // 事件委托的核心原理：给父节点添加侦听器，利用事件冒泡影响每一个子节点
  var ul = document.querySelector(&#39;ul&#39;)
  ul.addEventListener(&#39;click&#39;, function (e) {
    alert(&#39;知否知否，点我应有弹框在手！&#39;)
    for (var i = 0; i &lt; ul.children.length; i++) {
      ul.children[i].style.backgroundColor = null
    }
    e.target.style.backgroundColor = &#39;pink&#39;     // e.target 可以得到点击的对象
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h5 id="3-2-3-6-">3.2.3.6 鼠标事件</h5>
<h6 id="-">事件动作</h6>
<ol>
<li><p><code>click</code>：点击左键触发</p>
</li>
<li><p><code>dblclick</code>：双击左键触发</p>
</li>
<li><p>鼠标经过触发：</p>
<ul>
<li><code>mouseover</code>：经过自身盒子触发，经过子盒子还会触发</li>
<li><code>mouseenter</code>：仅经过自身盒子触发，因为它不冒泡</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .father {
    width: 300px;
    height: 300px;
    background-color: pink;
    margin: 100px auto;
  }
  .son {
    width: 200px;
    height: 200px;
    background-color: purple;
  }
&lt;/style&gt;

&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  var father = document.querySelector(&#39;.father&#39;)
  var son = document.querySelector(&#39;.son&#39;)
  // mouseover：经过自身盒子触发，经过子盒子还会触发
  father.addEventListener(&#39;mouseover&#39;, function () {
    console.log(&#39;mouseover触发&#39;)
  })
  // mouseenter：仅经过自身盒子触发，因为它不冒泡
  father.addEventListener(&#39;mouseenter&#39;, function () {
    console.log(&#39;mouseenter触发&#39;)
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>鼠标离开触发：</p>
<ul>
<li><code>mouseout</code>：经过自身盒子触发，经过子盒子还会触发</li>
<li><code>mouseleave</code>：仅经过自身盒子触发，因为它不冒泡</li>
</ul>
</li>
<li><p><code>focus</code>：获得鼠标焦点触发</p>
</li>
<li><p><code>blur</code>：失去鼠标焦点触发</p>
</li>
<li><p><code>mousemove</code>：鼠标移动触发</p>
</li>
<li><p><code>mouseup</code>：鼠标弹起触发</p>
</li>
<li><p><code>mousedown</code>：鼠标按下触发</p>
</li>
<li><p><code>contextmenu</code>：右键菜单</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 例：禁用右键菜单
document.addEventListener(&#39;contextmenu&#39;, function (e) {
  e.preventDefault()
})
</code></pre>
</li>
<li><p><code>selectstart</code>：选中文字</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 例：禁止选中文字
document.addEventListener(&#39;selectstart&#39;, function (e) {
  e.preventDefault()
})
</code></pre>
</li>
<li><p>双击禁止选中文字</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty()
</code></pre>
</li>
</ol>
<h6 id="-mouseevent">事件对象：MouseEvent</h6>
<ol>
<li><p><code>e.clientX</code>：鼠标相对浏览器可视区的X坐标</p>
</li>
<li><p><code>e.clientY</code>：鼠标相对浏览器可视区的Y坐标</p>
</li>
<li><p><code>e.pageX</code>：鼠标相对于文档页面的X坐标（IE9+支持）</p>
</li>
<li><p><code>e.pageY</code>：鼠标相对于文档页面的Y坐标（IE9+支持）</p>
</li>
<li><p><code>e.screenX</code>：鼠标相对于电脑屏幕的X坐标</p>
</li>
<li><p><code>e.screenY</code>：鼠标相对于电脑屏幕的Y坐标</p>
<pre class="prettyprint linenums:0"><code class="lang-js">document.addEventListener(&#39;click&#39;, function (e) {
  // 1. client 鼠标在可视区的x和y坐标
  console.log(e.clientX)
  console.log(e.clientY)
  console.log(&#39;---------------------&#39;)
  // 2. page 鼠标在页面文档的x和y坐标
  console.log(e.pageX)
  console.log(e.pageY)
  console.log(&#39;---------------------&#39;)
  // 3. screen 鼠标在电脑屏幕的x和y坐标
  console.log(e.screenX)
  console.log(e.screenY)
})
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：跟随鼠标移动的天使--&gt;
&lt;style&gt;
  img {
    position: absolute;
    top: 2px;
  }
&lt;/style&gt;
&lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot; /&gt;
&lt;script&gt;
  var pic = document.querySelector(&#39;img&#39;)
  document.addEventListener(&#39;mousemove&#39;, function (e) {
    // 每次鼠标移动都会获得最新的鼠标坐标，把这个x和y坐标做为图片的top和left值就可以移动图片
    var x = e.pageX
    var y = e.pageY
    console.log(&#39;x坐标是&#39; + x, &#39;y坐标是&#39; + y)
    // 不要忘记给left和top添加px单位
    pic.style.left = x - 40 + &#39;px&#39;
    pic.style.top = y - 40 + &#39;px&#39;
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h6 id="-">手动调用事件</h6>
<ol>
<li><code>element.click()</code>：点击事件</li>
</ol>
<hr>
<h5 id="3-2-3-7-">3.2.3.7 键盘事件</h5>
<h6 id="-">事件动作</h6>
<ul>
<li><p>执行顺序：keydown --&gt; keypress --&gt; keyup</p>
</li>
<li><p><code>keyup</code>：某个按键松开时触发，注意：在文本框中的特点：事件触发时，文字还没落入文本框，所以最好用keyup</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 按回车触发
input.onkeyup = function (e) {
  if (e.keyCode === 13) {
    // 执行触发后的函数
  }
}
</code></pre>
</li>
<li><p><code>keydown</code>：某个按键按下时触发</p>
</li>
<li><p><code>keypress</code>：某个按键按下时触发，但不能识别功能键，如ctrl、shift、箭头等</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：快递单号查询放大效果--&gt;
&lt;div class=&quot;search&quot;&gt;
  &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot; /&gt;
&lt;/div&gt;
&lt;script&gt;
  // 快递单号输入内容时，上面的大号字体盒子（con）显示（里面的字号更大）
  // 表单检测用户输入：给表单添加键盘事件
  // 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容
  // 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子
  var con = document.querySelector(&#39;.con&#39;)
  var jd_input = document.querySelector(&#39;.jd&#39;)
  jd_input.addEventListener(&#39;keyup&#39;, function () {
    if (this.value == &#39;&#39;) {
      con.style.display = &#39;none&#39;
    } else {
      con.style.display = &#39;block&#39;
      con.innerText = this.value
    }
  })
  // 当失去焦点，就隐藏这个con盒子
  jd_input.addEventListener(&#39;blur&#39;, function () {
    con.style.display = &#39;none&#39;
  })
  // 当获得焦点，就显示这个con盒子
  jd_input.addEventListener(&#39;focus&#39;, function () {
    if (this.value !== &#39;&#39;) {
      con.style.display = &#39;block&#39;
    }
  })
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h6 id="-keyboardevent">事件对象：KeyboardEvent</h6>
<ol>
<li><p><code>e.keyCode</code>：返回按键的ASCII值，其中keyup、keydown不区分大小写，keypress区分大小写</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 案例：按下s键，键盘定位到搜索框中
&lt;input type=&quot;text&quot; /&gt;
&lt;script&gt;
  // 核心思路：检测用户是否按下了s键，如果按下s键，就把光标定位到搜索框里面
  // 使用键盘事件对象里面的keyCode判断用户按下的是否是s键
  // 搜索框获得焦点：使用js里面的focus()方法
  var search = document.querySelector(&#39;input&#39;)
  document.addEventListener(&#39;keyup&#39;, function (e) {
    // console.log(e.keyCode);
    if (e.keyCode === 83) {
      search.focus()
    }
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-2-3-8-">3.2.3.8 表单事件</h5>
<ol>
<li><p>checkbox复选框：<code>change</code>：状态变化</p>
</li>
<li><p>input输入框：</p>
<p>1）<code>select()</code>：文本框里面的文字处于选定状态</p>
<pre class="prettyprint linenums:0"><code class="lang-js">this.innerHTML = &#39;&lt;input type=&quot;text&quot; /&gt;&#39;
var input = this.children[0]
input.value = str
input.select() // 文本框里面的文字处于选定状态
</code></pre>
<p>2）<code>onfocus</code>、<code>onblur</code>：获得、失去焦点</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;!--案例：显示隐藏文本框内容--&gt;
&lt;input type=&quot;text&quot; value=&quot;手机&quot; /&gt;
&lt;script&gt;
  // 1.获取元素
  var text = document.querySelector(&#39;input&#39;)
  // 2.注册事件 获得焦点事件 onfocus
  text.onfocus = function () {
    if (this.value === &#39;手机&#39;) {
      this.value = &#39;&#39;
    }
    // 获得焦点需要把文本框里面的文字颜色变黑
    this.style.color = &#39;#333&#39;
  }
  // 3. 注册事件：失去焦点事件 onblur
  text.onblur = function () {
    if (this.value === &#39;&#39;) {
      this.value = &#39;手机&#39;
    }
    // 失去焦点需要把文本框里面的文字颜色变浅色
    this.style.color = &#39;#999&#39;
  }
&lt;/script&gt;
</code></pre>
</li>
<li><p>form表单域：<code>reset()</code>：重置，清空内容</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// JS对象转DOM对象
$(&#39;#formAddCmt&#39;)[0].reset()
</code></pre>
</li>
<li><p>文字选择框：</p>
<p>1）结构：<code>&lt;input type=&quot;file&quot; accept=&quot;...&quot; /&gt;</code>，accept代表可以选择的文件类型，如image/png, image/jpeg</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;file&quot; id=&quot;file&quot; accept=&quot;image/png,image/jpeg&quot; /&gt;
</code></pre>
<p>2）<code>change</code>：绑定change事件，意味着文件选择框被激活</p>
<p>3）e.target.files：文件列表</p>
<p>4）e.target.files[0]：单个文件</p>
<p>5）URL.createObjectURL(file)：文件转化为路径</p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&#39;#file&#39;).on(&#39;change&#39;, function (e) {
    // 获取用户选择的文件
    var filelist = e.target.files
    if (filelist.length === 0) {
        return layer.msg(&#39;请选择照片！&#39;)
    }
    // 1. 拿到用户选择的文件
    var file = e.target.files[0]
    // 2. 将文件，转化为路径
    var imgURL = URL.createObjectURL(file)
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-2-4-">3.2.4 元素操作</h4>
<h5 id="3-2-4-1-">3.2.4.1 元素内容</h5>
<ol>
<li><p><code>element.innerText</code>：从起始位置到终止位置的内容，去除html标签、空格、换行</p>
<p>1）非标准，IE推出的</p>
<p>2）不识别html标签，如果替换内容有标签会按原型打印出来</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// innerText不识别html标签：非标准，去除空格和换行
var div = document.querySelector(&#39;div&#39;)
div.innerText = &quot;&lt;b&gt;今天是：&lt;/b&gt; 2019&quot;
</code></pre>
</li>
<li><p><code>element.innerHTML</code>：从起始位置到终止位置的内容，保留html标签、空格、换行</p>
<p>1）W3C标准，推荐使用</p>
<p>2）识别html标签，可用html标签给文字添加效果</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// innerHTML：识别html标签，W3C标准，保留空格和换行
var div = document.querySelector(&#39;div&#39;)
div.innerHTML = &#39;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#39;
</code></pre>
<p>3）创建新元素</p>
<ul>
<li><p>拼接法：大量创建标签效率低下，因为字符串拼接占用内存太多</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var inner = document.querySelector(&#39;.inner&#39;)
for (var i = 0; i &lt;= 100; i++) {
  inner.innerHTML += &#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;
}
</code></pre>
</li>
<li><p>数组法：创建空数组，用push方法添加，可以提升创建效率</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var inner = document.querySelector(&#39;.inner&#39;)
var arr = []
for (var i = 0; i &lt;= 100; i++) {
  arr.push(&#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;)
}
inner.innerHTML = arr.join(&#39;&#39;)
</code></pre>
</li>
</ul>
</li>
</ol>
<h5 id="3-2-4-2-">3.2.4.2 元素属性</h5>
<h6 id="-">修改表单属性</h6>
<ol>
<li><p>表单常用属性：type、value、checked、selected、disabled</p>
</li>
<li><p>内容：<code>value</code>，无法用innerHTML获取/修改内容，要通过value修改，例：input.value = XXX</p>
</li>
<li><p>禁用：<code>disabled</code>，例btn.disabled = true，点击按钮后无法再次点击，如果是通过btn.onclick定义的事件，可以用this.disabled = ture</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button&gt;按钮&lt;/button&gt;
&lt;input type=&quot;text&quot; value=&quot;输入内容&quot; /&gt;
&lt;script&gt;
  // 1. 获取元素
  var btn = document.querySelector(&#39;button&#39;)
  var input = document.querySelector(&#39;input&#39;)
  // 2. 注册事件
  btn.onclick = function () {
    // input.innerHTML = &#39;点击了&#39; // 不能用这种方法修改，只能修改普通盒子div中的内容
    // 表单里面的值，文字内容是通过 value 来修改的
    input.value = &#39;被点击了&#39;
    // 如果想要某个表单被禁用，不能再点击：disabled
    this.disabled = true
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h6 id="-">设置元素属性</h6>
<ol>
<li><p><code>element.属性</code>：通过函数/流程控制，直接对元素属性进行设置</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt;
&lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br /&gt;
&lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot; /&gt;

&lt;script&gt;
  // 修改元素属性：src
  // 1. 获取元素
  var ldh = document.getElementById(&#39;ldh&#39;)
  var zxy = document.getElementById(&#39;zxy&#39;)
  var img = document.querySelector(&#39;img&#39;)
  // 2. 注册事件  处理程序
  zxy.onclick = function () {
    img.src = &#39;images/zxy.jpg&#39;
    img.title = &#39;张学友思密达&#39;
  }
  ldh.onclick = function () {
    img.src = &#39;images/ldh.jpg&#39;
    img.title = &#39;刘德华&#39;
  }
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>element.setAttribute（属性名，属性值）</code>：可以自定义元素属性，目的：保存并使用数据，有些数据可以直接保存在页面中，无需从数据库中调用</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  var div = document.querySelector(&#39;div&#39;)
  div.setAttribute(&#39;index&#39;, 2)
  div.setAttribute(&#39;class&#39;, &#39;footer&#39;) // class特殊：这里面写的就是class，不是className
&lt;/script&gt;
</code></pre>
</li>
<li><p>H5自定义属性：</p>
<p>1）格式：<code>data-属性名=属性值</code>，例：<code>&lt;div data-index=&quot;1&quot; &gt;</code></p>
<p>2）目的：消除歧义，便于区分内置属性和自定义属性</p>
</li>
</ol>
<h6 id="-">获取元素属性</h6>
<ol>
<li><p><code>element.属性</code>：只能获取元素内置属性</p>
</li>
<li><p><code>element.getAttribute（属性名）</code>：可以获取自定义属性</p>
</li>
<li><p><code>element.dataset.属性名</code>、<code>element.dataset[属性名]</code>：H5自定义属性</p>
<p>1）dataset：是一个集合（DOMStringMap），里面存放了所有以data开头的自定义属性，获取时属性名前无需再加&#39;data-&#39;</p>
<p>2）自定义属性里面有多个&quot; - &quot;链接的单词，获取的时候采取驼峰命名法，例：属性: data-list-name，获取: listName</p>
<p>3）例：div.dataset.listName、div.dataset[&#39;listName&#39;]</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  var div = document.querySelector(&#39;div&#39;)
  div.setAttribute(&#39;data-time&#39;, 20)
  // 只能用getAttuibute获取自定义属性
  console.log(div.getAttribute(&#39;data-index&#39;))        // 2
  console.log(div.getAttribute(&#39;data-list-name&#39;))    // andy

  // dataset 是一个集合，里面存放了所有以data开头的自定义属性
  console.log(div.dataset)            // DOMStringMap
  console.log(div.dataset.index)    // 2
  console.log(div.dataset[&#39;index&#39;])    // 2

  // 如果自定义属性里面有多个-链接的单词，获取的时候采取驼峰命名法
  console.log(div.dataset.listName)        // andy
  console.log(div.dataset[&#39;listName&#39;])    // andy
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h6 id="-">移除元素属性</h6>
<ol>
<li><code>element.removeAttibute（属性名）</code></li>
</ol>
<h5 id="3-2-4-3-">3.2.4.3 元素样式</h5>
<ul>
<li><p>注意：样式属性需要采用驼峰命名法，background-color需要写成backgroundColor</p>
</li>
<li><p><code>element.style.样式属性</code>：行内样式操作，产生的是行内样式，权重较高</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var div = document.querySelector(&#39;div&#39;)
div.onclick = function () {
  // div.style里面的属性：采取驼峰命名法
  this.style.backgroundColor = &#39;purple&#39;
  this.style.width = &#39;250px&#39;
}
</code></pre>
</li>
<li><p><code>element.className = &#39;新类名&#39;</code>：类名样式操作</p>
<p>1）适用于需要修改样式较多的情况，先在css中写一个新类名，然后达到修改元素类名的效果</p>
<p>2）会直接更改元素的类名，覆盖原先的类名</p>
<p>3）如果希望保留原类名，可以在原类名后加空格，再写新类名</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var test = document.querySelector(&#39;div&#39;)
test.onclick = function () {
  // this.className = &#39;change&#39;
  // 如果想要保留原先的类名，可以用多类名选择器
  this.className = &#39;first change&#39;
}
</code></pre>
</li>
<li><p><code>element.classList</code>：获取元素类名，返回DOMTokenList</p>
<p>1）增加类名：element.classList.add(类名)，不会覆盖原有类，类名不用加“.”</p>
<p>2）删除类名：element.classList.remove(类名)</p>
<p>3）切换类名：element.classList.toggle(类名)，若类名存在则删除，若类名不存在则添加上</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;one two&quot;&gt;&lt;/div&gt;
&lt;button&gt;开关灯&lt;/button&gt;
&lt;script&gt;
  // classList 返回元素的类名
  var div = document.querySelector(&#39;div&#39;)
  // 1. 添加类名  是在后面追加类名不会覆盖以前的类名 注意前面不需要加.
  div.classList.add(&#39;three&#39;)
  // 2. 删除类名
  div.classList.remove(&#39;one&#39;)
  // 3. 切换类
  var btn = document.querySelector(&#39;button&#39;)
  btn.addEventListener(&#39;click&#39;, function () {
    document.body.classList.toggle(&#39;bg&#39;)
  })
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="3-2-4-4-">3.2.4.4 创建元素</h5>
<ol>
<li><code>document.write()</code>：如果页面文档流加载完毕，再调用这句话会导致页面重绘，例：document.write(&#39;<div>123</div>&#39;)</li>
<li><code>window.onload=function(){}</code>：页面加载完毕再执行JS的函数</li>
</ol>
<h5 id="3-2-4-5-">3.2.4.5 常用方法</h5>
<h6 id="-">排他思想</h6>
<ul>
<li><p>多个按钮点击其中一个时，其余按钮恢复原样（首先先排除其他人，然后才设置自己的样式）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button&gt;按钮1&lt;/button&gt;
&lt;button&gt;按钮2&lt;/button&gt;
&lt;button&gt;按钮3&lt;/button&gt;
&lt;button&gt;按钮4&lt;/button&gt;
&lt;button&gt;按钮5&lt;/button&gt;
&lt;script&gt;
  // 获取所有按钮元素
  var btns = document.getElementsByTagName(&#39;button&#39;)
  // btns得到的是伪数组，里面的每一个元素 btns[i]
  for (var i = 0; i &lt; btns.length; i++) {
    btns[i].onclick = function () {
      // 1. 先把所有的按钮背景颜色去掉：干掉所有人
      for (var i = 0; i &lt; btns.length; i++) {
        btns[i].style.backgroundColor = &#39;&#39;
      }
      // 2. 然后才让当前的元素背景颜色为pink：留下我自己
      this.style.backgroundColor = &#39;pink&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h6 id="-">换肤效果</h6>
<ul>
<li><p>更改图片的src路径</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul class=&quot;baidu&quot;&gt;
  &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
  // 1. 获取元素
  var imgs = document.querySelector(&#39;.baidu&#39;).querySelectorAll(&#39;img&#39;)
  // 2. 循环注册事件
  for (var i = 0; i &lt; imgs.length; i++) {
    imgs[i].onclick = function () {
      // this.src 就是点击图片的路径，把这个路径给body就可以了
      document.body.style.backgroundImage = &#39;url(&#39; + this.src + &#39;)&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h6 id="-">表格操作</h6>
<ol>
<li><p>表格变色</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .bg {
    background-color: pink;
  }
&lt;/style&gt;
&lt;script&gt;
  // 1.获取元素：获取的是 tbody 里面所有的行
  var trs = document.querySelector(&#39;tbody&#39;).querySelectorAll(&#39;tr&#39;)
  // 2. 利用循环绑定注册事件
  for (var i = 0; i &lt; trs.length; i++) {
    // 3. 鼠标经过事件 onmouseover
    trs[i].onmouseover = function () {
      this.className = &#39;bg&#39;
    }
    // 4. 鼠标离开事件 onmouseout
    trs[i].onmouseout = function () {
      this.className = &#39;&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
<li><p>表格选项框全选反选</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 1. 全选和取消全选做法：让下面所有复选框的checked属性（选中状态）跟随，全选按钮即可
// 获取元素
var j_cbAll = document.getElementById(&#39;j_cbAll&#39;) // 全选按钮
var j_tbs = document.getElementById(&#39;j_tb&#39;).getElementsByTagName(&#39;input&#39;) // 下面所有的复选框
// 注册事件
j_cbAll.onclick = function () {
  // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中
  console.log(this.checked)
  for (var i = 0; i &lt; j_tbs.length; i++) {
    j_tbs[i].checked = this.checked
  }
}
// 2. 下面复选框需要全部选中，上面全选才能选中做法：给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的，上面全选就不选中。
for (var i = 0; i &lt; j_tbs.length; i++) {
  j_tbs[i].onclick = function () {
    // flag 控制全选按钮是否选中
    var flag = true
    // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
    for (var i = 0; i &lt; j_tbs.length; i++) {
      if (!j_tbs[i].checked) {
        flag = false
        break // 退出for循环 这样可以提高执行效率，因为只要有一个没有选中，剩下的就无需循环判断了
      }
    }
    j_cbAll.checked = flag
  }
}
</code></pre>
</li>
</ol>
<h6 id="tab-">Tab栏切换内容</h6>
<ol>
<li><p>tab栏选中效果：排他算法</p>
</li>
<li><p>底部内容区域跟随变化：通过对应tab栏的index编号进行索引，设置display属性（也用到了排他算法）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .current {
    background-color: red;
  }
&lt;/style&gt;

&lt;div class=&quot;tab&quot;&gt;
  &lt;div class=&quot;tab_list&quot;&gt;
    &lt;ul&gt;
      &lt;li class=&quot;current&quot;&gt;商品介绍&lt;/li&gt;
      &lt;li&gt;规格与包装&lt;/li&gt;
      &lt;li&gt;售后保障&lt;/li&gt;
      &lt;li&gt;商品评价（50000）&lt;/li&gt;
      &lt;li&gt;手机社区&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;div class=&quot;tab_con&quot;&gt;
    &lt;div class=&quot;item&quot; style=&quot;display: block&quot;&gt;商品介绍模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;规格与包装模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;售后保障模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;商品评价（50000）模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;手机社区模块内容&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 获取元素
  var tab_list = document.querySelector(&#39;.tab_list&#39;)
  var lis = tab_list.querySelectorAll(&#39;li&#39;)
  var items = document.querySelectorAll(&#39;.item&#39;)
  // for循环绑定点击事件
  for (var i = 0; i &lt; lis.length; i++) {
    // 开始给5个小li，设置索引号（用于下面显示内容模块）
    lis[i].setAttribute(&#39;index&#39;, i)
    lis[i].onclick = function () {
      // 1. 上面的模块选项卡：点击某一个，当前这一个底色会是红色，其余不变（排他思想）
      // 干掉所有人：其余的li清除 class 这个类
      for (var i = 0; i &lt; lis.length; i++) {
        lis[i].className = &#39;&#39;
      }
      // 留下我自己
      this.className = &#39;current&#39;

      // 2. 下面的显示内容模块
      var index = this.getAttribute(&#39;index&#39;)
      // 干掉所有人 让其余的item 这些div 隐藏
      for (var i = 0; i &lt; items.length; i++) {
        items[i].style.display = &#39;none&#39;
      }
      // 留下我自己 让对应的item 显示出来
      items[index].style.display = &#39;block&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-2-5-node-">3.2.5 Node操作</h4>
<ol>
<li><p>特点：相对DOM获取元素而言，节点操作利用父子兄节点关系获取元素，逻辑性强，但是兼容性差</p>
</li>
<li><p>基本属性：nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）</p>
</li>
<li><p>节点类型：<code>nodeType</code></p>
<p>1）Element：元素节点</p>
<p>2）Attribute：属性节点</p>
<p>3）Text：文本节点</p>
<p>4）CDATA Section</p>
<p>5）Entity Reference</p>
<p>6）Entity</p>
<p>7）Processing Instrucion</p>
<p>8）Comment</p>
<p>9）Document</p>
<p>10）Document Type</p>
<p>11）Document Fragment</p>
<p>12）Notation</p>
</li>
</ol>
<h5 id="3-2-5-1-">3.2.5.1 父节点</h5>
<ol>
<li><p>语法：<code>node.parentNode</code></p>
</li>
<li><p>就近原则：得到的是离元素最近的父级节点，如果找不到父节点就返回为 null</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;demo&quot;&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 父节点 parentNode
  // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
  var erweima = document.querySelector(&#39;.erweima&#39;)
  console.log(erweima.parentNode)
  // html元素的父节点是 #document
  var demo = document.documentElement
  console.log(demo.parentNode)
&lt;/script&gt;
</code></pre>
</li>
<li><p>如果存在页面嵌套（如iframe），子页面可以跳到父页面js中的方法，如：<code>window.parent.XXX()</code></p>
</li>
</ol>
<h5 id="3-2-5-2-">3.2.5.2 子节点</h5>
<ol>
<li><p>语法：</p>
<p>1）<code>parentNode.childNodes</code>：指定节点的子节点的集合（包含元素节点、文本节点等），形式为 NodeList(x)</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul&gt;
  &lt;li&gt;我是li&lt;/li&gt;
  &lt;li&gt;我是li&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  var ul = document.querySelector(&#39;ul&#39;)
  var lis = ul.querySelectorAll(&#39;li&#39;)
  // childNodes：所有的子节点，包含元素节点、文本节点等
  console.log(ul.childNodes)                // NodeList(9)
  console.log(ul.childNodes[0].nodeType)    // 3（text：文本节点，类型为3）
  console.log(ul.childNodes[1].nodeType)    // 1（li：元素节点，类型为1）
&lt;/script&gt;
</code></pre>
<p>2）<code>parentNode.children</code>：返回所有的子元素节点（仅有元素节点），形式为HTMLCollection(x)，指定子元素节点：parentNode.children[i]</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul&gt;
  &lt;li&gt;我是li&lt;/li&gt;
  &lt;li&gt;我是li&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  var ul = document.querySelector(&#39;ul&#39;)
  var lis = ul.querySelectorAll(&#39;li&#39;)
  // children：获取所有的子元素节点，实际开发常用
  console.log(ul.children)    // HTMLCollection(4)
&lt;/script&gt;
</code></pre>
</li>
<li><p>获取第一个子节点：</p>
<p>1）<code>parent.firstChild</code>：第一个子节点（所有类型）</p>
<p>2）<code>parent.firstElementChild</code>：第一个元素子节点，IE9上才支持</p>
<p>3）<code>parentNode.children[0]</code>：第一个元素子节点，兼容性较好</p>
</li>
<li><p>获取最后一个子节点:</p>
<p>1）<code>parent.lastChild</code>：最后一个子节点（所有类型）</p>
<p>2）<code>parent.lastElementChild</code>：最后一个元素子节点，IE9上才支持</p>
<p>3）<code>parentNode.children[parentNode.children.length-1]</code>：最后一个元素子节点，兼容性较好</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ol&gt;
  &lt;li&gt;我是li1&lt;/li&gt;
  &lt;li&gt;我是li2&lt;/li&gt;
  &lt;li&gt;我是li3&lt;/li&gt;
&lt;/ol&gt;
&lt;script&gt;
  var ol = document.querySelector(&#39;ol&#39;)
  // 1. firstChild 第一个子节点：不管是文本节点还是元素节点
  console.log(ol.firstChild)
  console.log(ol.lastChild)
  // 2. firstElementChild 返回第一个子元素节点（ie9支持）
  console.log(ol.firstElementChild)
  console.log(ol.lastElementChild)
  // 3. 实际开发写法：既没有兼容性问题又返回第一个子元素
  console.log(ol.children[0])
  console.log(ol.children[ol.children.length - 1])
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例：下拉菜单</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul class=&quot;nav&quot;&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  // 获取元素
  var nav = document.querySelector(&#39;.nav&#39;)
  var lis = nav.children // 得到里面的小li
  // 循环注册事件
  for (var i = 0; i &lt; lis.length; i++) {
    lis[i].onmouseover = function () {
      this.children[1].style.display = &#39;block&#39;
    }
    lis[i].onmouseout = function () {
      this.children[1].style.display = &#39;none&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-2-5-3-">3.2.5.3 兄弟节点</h5>
<ol>
<li><p>下一个兄弟节点</p>
<p>1）<code>node.nextSibling</code>：获取下一个兄弟节点（所有类型）</p>
<p>2）<code>node.nextElementSibling</code>：获取下一个兄弟元素节点</p>
</li>
<li><p>上一个兄弟节点：</p>
<p>1）<code>node.previousSibling</code>：获取下一个兄弟节点（所有类型）</p>
<p>2）<code>node.previousElementSibling</code>：获取下一个兄弟远元素节点</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;我是div&lt;/div&gt;
&lt;span&gt;我是span&lt;/span&gt;
&lt;script&gt;
  var div = document.querySelector(&#39;div&#39;)

  // 1.nextSibling 下一个兄弟节点：包含元素节点、文本节点等
  console.log(div.nextSibling)
  console.log(div.previousSibling)

  // 2. nextElementSibling 得到下一个兄弟元素节点
  console.log(div.nextElementSibling)
  console.log(div.previousElementSibling)
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-2-5-4-">3.2.5.4 创建节点</h5>
<ol>
<li><p><code>document.createElement(&#39;tagName&#39;)</code>：动态创建节点</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;请输入您的留言...&lt;/textarea&gt;
&lt;button&gt;发布&lt;/button&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;script&gt;
  // 1. 获取元素
  var btn = document.querySelector(&#39;button&#39;)
  var text = document.querySelector(&#39;textarea&#39;)
  var ul = document.querySelector(&#39;ul&#39;)
  // 2. 注册事件
  text.onclick = function () {
    text.value = &#39;&#39;
  }
  btn.onclick = function () {
    if (text.value == &#39;&#39;) {
      alert(&#39;您没有输入内容&#39;)
      return false
    } else {
      // (1) 创建元素
      var li = document.createElement(&#39;li&#39;)
      // 先有li 才能赋值
      li.innerHTML = text.value
      // (2) 添加元素
      ul.insertBefore(li, ul.children[0])
      text.value = &#39;&#39;
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-2-5-5-">3.2.5.5 添加节点</h5>
<ol>
<li><p><code>node.appendChild(child)</code>：将一个节点添加到指定父节点的子节点列表末尾，像CSS的after伪元素</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;create&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  var create = document.querySelector(&#39;.create&#39;)
  for (var i = 0; i &lt;= 100; i++) {
    var a = document.createElement(&#39;a&#39;)
    create.appendChild(a)
}
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>node.insertBefore(child, 指定元素)</code>：将一个节点添加到指定元素之前</p>
</li>
<li><p><code>node.insertAdjacentHTML(位置, 字符串元素)</code>：与appendChild的区别在于，此方法支持直接在父元素插入以字符串形式定义的新元素</p>
<p>1）beforebegin：元素自身的前面</p>
<p>2）afterbegin：插入元素内部第一个子节点之前</p>
<p>3）beforeend：插入元素内部最后一个子节点之后</p>
<p>4）afterend：元素自身后面</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var ul = document.querySelector(&#39;div&#39;)
var li = &#39;&lt;li class=avtive&gt;&lt;span&gt;new&lt;/span&gt;&lt;/li&gt;&#39;
ul.insertAdjacentHTML(&#39;brforeend&#39;, li)
</code></pre>
</li>
</ol>
<h5 id="3-2-5-6-">3.2.5.6 删除节点</h5>
<ol>
<li><p><code>node.removeChild(child)</code>：删除父节点下的子节点</p>
</li>
<li><p>案例：删除留言：制作删除按钮，阻止链接<code>&lt;a&gt;</code>跳转：href = &#39;javascript: void(0);&#39; 或 &#39;javascript:;&#39;</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;
&lt;button&gt;发布&lt;/button&gt;
&lt;ul&gt;&lt;/ul&gt;

&lt;script&gt;
  // 1. 获取元素
  var btn = document.querySelector(&#39;button&#39;)
  var text = document.querySelector(&#39;textarea&#39;)
  var ul = document.querySelector(&#39;ul&#39;)
  // 2. 注册事件
  btn.onclick = function () {
    if (text.value == &#39;&#39;) {
      alert(&#39;您没有输入内容&#39;)
      return false
    } else {
      // 1. 创建元素
      var li = document.createElement(&#39;li&#39;)
      // 先有li才能赋值
      li.innerHTML = text.value + &quot;&lt;a href=&#39;javascript:;&#39;&gt;删除&lt;/a&gt;&quot;
      // 2. 添加元素：让最新的留言在前面
      ul.insertBefore(li, ul.children[0])
      // 3. 删除元素：删除的是当前链接的li的父亲
      var as = document.querySelectorAll(&#39;a&#39;)
      for (var i = 0; i &lt; as.length; i++) {
        as[i].onclick = function () {
          // 删除的是 li：即当前 a 所在的父节点 li：this.parentNode
          ul.removeChild(this.parentNode)
        }
      }
    }
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-2-5-7-">3.2.5.7 复制节点</h5>
<ol>
<li><p><code>node.cloneNode()</code>：括号内为空或false，浅拷贝，只复制标签不复制里面的内容</p>
</li>
<li><p><code>node.cloneNode(true)</code>：括号内为true，深拷贝，复制标签和内容</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;button&gt;复制&lt;/button&gt;
&lt;ul&gt;
  &lt;li&gt;Jack&lt;/li&gt;
  &lt;li&gt;Emliy&lt;/li&gt;
  &lt;li&gt;Alice&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  var ul = document.querySelector(&#39;ul&#39;)
  var btn = document.querySelector(&#39;button&#39;)
  // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
  // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
  btn.onclick = function () {
    var lili = ul.children[0].cloneNode(true)
    ul.appendChild(lili)
  }
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-2-5-8-">3.2.5.8 动态创建表格</h5>
<ol>
<li><p>创建行：for循环储存数据的数组，有几条数据创建几行</p>
</li>
<li><p>创建单元格：for循环对象，对象有几个属性创建几个单元格，如果需要额外添加单元格（如：删除按钮），则再单独创建单元格</p>
</li>
<li><p>删除按钮<code>&lt;a&gt;</code>：tbody.removeChild( this.parentNode.parentNode)，即删除<code>&lt;a&gt;</code>的父元素<code>&lt;td&gt;</code>的父元素<code>&lt;tr&gt;</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;style&gt;
  table {
    width: 500px;
    margin: 100px auto;
    border-collapse: collapse;
    text-align: center;
  }
  td,
  th {
    border: 1px solid #333;
  }
  thead tr {
    height: 40px;
    background-color: #ccc;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;table cellspacing=&quot;0&quot;&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;科目&lt;/th&gt;
        &lt;th&gt;成绩&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;&lt;/tbody&gt;
  &lt;/table&gt;

  &lt;script&gt;
    // 1. 准备好学生的数据
    var datas = [
      {
        name: &#39;魏璎珞&#39;,
        subject: &#39;JavaScript&#39;,
        score: 100,
      },
      {
        name: &#39;弘历&#39;,
        subject: &#39;JavaScript&#39;,
        score: 98,
      },
      {
        name: &#39;傅恒&#39;,
        subject: &#39;JavaScript&#39;,
        score: 99,
      },
      {
        name: &#39;明玉&#39;,
        subject: &#39;JavaScript&#39;,
        score: 88,
      },
      {
        name: &#39;大猪蹄子&#39;,
        subject: &#39;JavaScript&#39;,
        score: 0,
      },
    ]
    // 2. 往tbody里面创建行：有几个人（通过数组的长度）我们就创建几行
    var tbody = document.querySelector(&#39;tbody&#39;)
    for (var i = 0; i &lt; datas.length; i++) {
      // 外面的for循环：行tr
      // 1. 创建 tr行
      var tr = document.createElement(&#39;tr&#39;)
      tbody.appendChild(tr)

      // 2. 行里面创建单元格(跟数据有关系的3个单元格) td，单元格的数量取决于每个对象里面的属性数量
      for (var k in datas[i]) {
        // 里面的for循环：列td
        // 创建单元格
        var td = document.createElement(&#39;td&#39;)
        // 把对象里面的属性值 datas[i][k] 给 td
        td.innerHTML = datas[i][k]
        tr.appendChild(td)
      }

      // 3. 创建有删除2个字的单元格
      var td = document.createElement(&#39;td&#39;)
      td.innerHTML = &#39;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#39;
      tr.appendChild(td)
    }

    // 4. 删除操作
    var as = document.querySelectorAll(&#39;a&#39;)
    for (var i = 0; i &lt; as.length; i++) {
      as[i].onclick = function () {
        // 点击a，删除当前a所在的行(链接的爸爸的爸爸)
        tbody.removeChild(this.parentNode.parentNode)
      }
    }
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</li>
</ol>
<hr>
<h3 id="3-3-bom">3.3 BOM</h3>
<blockquote>
<p>浏览器对象模型（Browser Object Model），提供独立于内容而与浏览器窗口进行交互的对象，核心对象是window。</p>
</blockquote>
<h4 id="3-3-1-bom-">3.3.1 BOM简介</h4>
<ol>
<li>BOM由一系列相关的对象构成，每个对象提供了很多方法和属性</li>
<li>BOM缺乏标准，JS标准是ECMA，DOM标准是W3C，BOM是网景浏览器标准的一部分，兼容性较差</li>
<li>结构：window<ul>
<li>document</li>
<li>location</li>
<li>navigation</li>
<li>screen</li>
<li>history</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-3-2-windows-">3.3.2 Windows对象</h4>
<ol>
<li>是浏览器的顶级对象，具有双重角色</li>
<li>是JS访问浏览器窗口的一个接口</li>
<li>是一个全局对象，定义在全局作用域中的变量、函数，都会变成windows对象的属性和方法</li>
</ol>
<h5 id="3-3-2-1-windows-">3.3.2.1 Windows属性</h5>
<ol>
<li><p><code>window.name</code>：窗口名字，用于为超链接和表单设置目标（targets）</p>
</li>
<li><p><code>window.devicePixelRatio</code>：物理像素比（1px能显示的物理像素点的个数）</p>
</li>
<li><p><code>window.innerWidth</code>：当前窗口大小</p>
</li>
<li><p>页面滚动：</p>
<p>1）<code>window.pageYOffset</code>：页面被卷去的头部大小（无单位）（IE9+支持）</p>
<p>2）<code>window.pageXOffset</code>：页面被卷去的左侧大小（无单位）（IE9+支持）</p>
<p>3）旧版兼容：</p>
<ul>
<li>已声明DTD（即<code>&lt;!DOCTYPE html&gt;</code>）：<code>document.documentElement.scrollTop</code></li>
<li>未声明DTD：<code>document.body.scrollTop</code></li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">// 使用时： getScroll().left 或 getScroll().top
function getScroll() {
  return {
    left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
    top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0,
  }
}
</code></pre>
</li>
</ol>
<h5 id="3-3-2-2-windows-">3.3.2.2 Windows方法</h5>
<h6 id="-load">窗口加载: load</h6>
<ol>
<li><p>load</p>
<p>1）定义：当文档内容完全加载会触发该事件（包括图像、脚本、CSS等），可以把JS放在head里</p>
<p>2）触发动作：<code>&lt;a&gt;</code>、F5刷新、前进后退按钮</p>
<p>3）<code>window.onload</code>：传统注册事件，只能写一次，如果有多个以最后一个为准</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.onload = function () {
  var btn = document.querySelector(&#39;button&#39;)
  btn.addEventListener(&#39;click&#39;, function () {
    alert(&#39;点击我&#39;)
  })
}
</code></pre>
<p>4）<code>window.addEventListener(&#39;load&#39;,fn)</code>：方法监听注册，可以写多个</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;load&#39;, function () {
  var btn = document.querySelector(&#39;button&#39;)
  btn.addEventListener(&#39;click&#39;, function () {
    alert(&#39;点击我&#39;)
  })
})
window.addEventListener(&#39;load&#39;, function () {
  alert(22)
})
</code></pre>
<p>5）<code>document.addEventListener(&#39;DOMContentLoaded&#39;,fn)</code>：仅当DOM加载完成时触发，包括JS，但不包括图片、CSS、flash等（IE9+支持），适用于多媒体较多的网页，不耽误用户操作其他按钮</p>
<pre class="prettyprint linenums:0"><code class="lang-js">document.addEventListener(&#39;DOMContentLoaded&#39;, function () {
  alert(33)
})
</code></pre>
</li>
<li><p><code>window.addEventListener(&#39;pageshow&#39;,fn)</code></p>
<p>1）火狐浏览器具有“往返缓存”的特点，使用后退按钮返回页面时，如果使用load不会重新加载页面，此时需要pageshow，页面先执行其中的回调函数</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;script&gt;
  // 会先执行pageshow内定义的回调函数
  window.addEventListener(&#39;pageshow&#39;, function () {
    alert(11)
  })
&lt;/script&gt;
&lt;!--执行完毕后，才会显示下面内容--&gt;
&lt;a href=&quot;http://www.itcast.cn&quot;&gt;链接&lt;/a&gt;
</code></pre>
<p>2）页面显示时触发，无论页面是否来自于缓存，会在load事件后触发，可配合使用 e.persisted 判断是否是缓存中的页面</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;pageshow&#39;, function (e) {
  // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小
  if (e.persisted) {
    setRemUnit()
  }
})
</code></pre>
</li>
</ol>
<h6 id="-resize">窗口大小: resize</h6>
<ol>
<li><p><code>window.onresize</code></p>
</li>
<li><p><code>window.addEventListener(&#39;resize&#39;,fn)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 200px;
    height: 200px;
    background-color: pink;
  }
&lt;/style&gt;
&lt;script&gt;
  window.addEventListener(&#39;load&#39;, function () {
    var div = document.querySelector(&#39;div&#39;)
    window.addEventListener(&#39;resize&#39;, function () {
      console.log(window.innerWidth)
      console.log(&#39;变化了&#39;)
      if (window.innerWidth &lt;= 800) {
        div.style.display = &#39;none&#39;
      } else {
        div.style.display = &#39;block&#39;
      }
    })
  })
&lt;/script&gt;
&lt;div&gt;&lt;/div&gt;
</code></pre>
</li>
</ol>
<h6 id="-scroll">窗口滚动: scroll</h6>
<ol>
<li><code>window.scroll(x,y)</code>：里面数值不加单位</li>
</ol>
<h6 id="-settimeout">定时器: setTimeout</h6>
<ul>
<li><p>注意：如果重复点击按钮触发定时器，动作会越来越快，这是由于定时器叠加导致的，需要清除掉旧定时器，只保留一个定时器</p>
</li>
<li><p><code>setTimeout(回调函数，[延迟的毫秒数])</code>：仅执行一次</p>
<p>1）调用函数可以直接写函数，还可以写函数名或 &#39;函数名()&#39;</p>
<p>2）页面中可能有很多的定时器，经常给定时器加名字</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function callback() {
  console.log(&#39;爆炸了&#39;)
}
var timer1 = setTimeout(callback, 3000)
var timer2 = setTimeout(callback, 5000)
</code></pre>
<p>3)案例：页面广告自动隐藏</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;img src=&quot;images/ad.jpg&quot; alt=&quot;&quot; class=&quot;ad&quot; /&gt;

&lt;script&gt;
  var ad = document.querySelector(&#39;.ad&#39;)
  setTimeout(function () {
    ad.style.display = &#39;none&#39;
  }, 5000)
&lt;/script&gt;
</code></pre>
<p>4）停止定时器：<code>clearTimeout(定时器名称)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button&gt;点击停止定时器&lt;/button&gt;

&lt;script&gt;
  var btn = document.querySelector(&#39;button&#39;)
  var timer = setTimeout(function () {
    console.log(&#39;爆炸了&#39;)
  }, 5000)
  btn.addEventListener(&#39;click&#39;, function () {
    clearTimeout(timer)
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>setInterval(回调函数，[延迟的毫秒数])</code>：重复调用一个函数，每隔这个时间就调用一次回调函数</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：倒计时--&gt;
&lt;div&gt;
    &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;
    &lt;span&gt;时&lt;/span&gt;
    &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;
    &lt;span&gt;分&lt;/span&gt;
    &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;
    &lt;span&gt;秒&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    // 1. 获取元素 
    var hour = document.querySelector(&#39;.hour&#39;);         // 小时的黑色盒子
    var minute = document.querySelector(&#39;.minute&#39;);     // 分钟的黑色盒子
    var second = document.querySelector(&#39;.second&#39;);     // 秒数的黑色盒子
    var inputTime = +new Date(&#39;2025-12-31 18:00:00&#39;);     // 返回的是用户输入时间总的毫秒数
    countDown()                                         // 先调用一次这个函数，防止第一次刷新页面有空白 
    // 2. 开启定时器
    setInterval(countDown, 1000);
    function countDown() {
        var nowTime = +new Date();                         // 返回的是当前时间总的毫秒数
        var times = (inputTime - nowTime) / 1000;         // times是剩余时间总的秒数 
        var h = parseInt(times / 60 / 60 % 24);         //时
        h = h &lt; 10 ? &#39;0&#39; + h : h;
        hour.innerHTML = h;                             // 把剩余的小时给 小时黑色盒子
        var m = parseInt(times / 60 % 60);                 // 分
        m = m &lt; 10 ? &#39;0&#39; + m : m;
        minute.innerHTML = m;
        var s = parseInt(times % 60);                     // 秒
        s = s &lt; 10 ? &#39;0&#39; + s : s;
        second.innerHTML = s;
    }
&lt;/script&gt;
</code></pre>
<p>1）停止定时器：<code>clearInterval(定时器名称)</code></p>
<p>2）注意：如果定时器被写入了注册事件函数内部的匿名函数，需要在外面声明一个与定时器同名的全局变量，令其为null</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button class=&quot;begin&quot;&gt;开启定时器&lt;/button&gt;
&lt;button class=&quot;stop&quot;&gt;停止定时器&lt;/button&gt;

&lt;script&gt;
  var begin = document.querySelector(&#39;.begin&#39;)
  var stop = document.querySelector(&#39;.stop&#39;)
  var timer = null // 全局变量，null是一个空对象
  begin.addEventListener(&#39;click&#39;, function () {
    timer = setInterval(function () {
      console.log(&#39;ni hao ma&#39;)
    }, 1000)
  })
  stop.addEventListener(&#39;click&#39;, function () {
    clearInterval(timer)
  })
&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：手机发送短信--&gt;
手机号码： &lt;input type=&quot;tel&quot; /&gt; &lt;button&gt;发送&lt;/button&gt;
&lt;script&gt;
  // 按钮点击之后，会禁用 disabled 为true，按钮里面内容变化
  // 注意 button 里面的内容通过 innerHTML修改
  var btn = document.querySelector(&#39;button&#39;)
  var time = 3 // 定义剩下的秒数
  btn.addEventListener(&#39;click&#39;, function () {
    btn.disabled = true
    var timer = setInterval(function () {
      if (time == 0) {
        // 清除定时器和复原按钮
        clearInterval(timer)
        btn.disabled = false
        btn.innerHTML = &#39;发送&#39;
        time = 3
      } else {
        btn.innerHTML = &#39;还剩下&#39; + time + &#39;秒&#39;
        time--
      }
    }, 1000)
  })
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h6 id="-localstorage">本地储存: localStorage</h6>
<ol>
<li><p>特性：</p>
<p>1）数据储存在用户浏览器中</p>
<p>2）设置/读取方便，页面刷新不丢失数据</p>
<p>3）容量大，sessionStorage存5M、localStorage存20M</p>
<p>4）查看数据：点击F12中的应用，本地储存空间/会话储存空间</p>
</li>
<li><p>储存与读取：</p>
<p>1）只能存储字符串，可以将对象<code>JSON.stringify()</code>编码后储存（格式为字符串）</p>
<p>2）读取数据时，也要先用<code>JSON.parse()</code>转化后才能使用（格式为数组）</p>
</li>
<li><p>sessionStorage：会话储存，生命周期：关闭浏览器窗口</p>
<p>1）<code>sessionStorage.setItem(key,value)</code>：存储数据</p>
<pre class="prettyprint linenums:0"><code class="lang-js">sessionStorage.setItem(&#39;todo&#39;, JSON.stringify(todolist))
</code></pre>
<p>2）<code>sessionStorage.getItem(key)</code>：获取数据</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var data = sessionStorage.getItem(&#39;todo&#39;)
data = JSON.parse(data)
</code></pre>
<p>3）<code>sessionStorage.removeItem(key)</code>：删除数据</p>
<p>4）<code>sessionStorage.clear()</code>：删除所有数据</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;text&quot; /&gt;
&lt;button class=&quot;set&quot;&gt;存储数据&lt;/button&gt;
&lt;button class=&quot;get&quot;&gt;获取数据&lt;/button&gt;
&lt;button class=&quot;remove&quot;&gt;删除数据&lt;/button&gt;
&lt;button class=&quot;del&quot;&gt;清空所有数据&lt;/button&gt;
&lt;script&gt;
  console.log(localStorage.getItem(&#39;username&#39;))
  var ipt = document.querySelector(&#39;input&#39;)
  var set = document.querySelector(&#39;.set&#39;)
  var get = document.querySelector(&#39;.get&#39;)
  var remove = document.querySelector(&#39;.remove&#39;)
  var del = document.querySelector(&#39;.del&#39;)
  set.addEventListener(&#39;click&#39;, function () {
    // 当点击了之后，就可以把表单里面的值存储起来
    var val = ipt.value
    sessionStorage.setItem(&#39;uname&#39;, val)
    sessionStorage.setItem(&#39;pwd&#39;, val)
  })
  get.addEventListener(&#39;click&#39;, function () {
    // 当点击了之后，就可以把表单里面的值获取过来
    console.log(sessionStorage.getItem(&#39;uname&#39;))
  })
  remove.addEventListener(&#39;click&#39;, function () {
    //
    sessionStorage.removeItem(&#39;uname&#39;)
  })
  del.addEventListener(&#39;click&#39;, function () {
    // 当点击了之后，清除所有的
    sessionStorage.clear()
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>localStorage：本地储存，生命周期：永久，除非手动删除</p>
<p>1）可以多窗口/页面共享（同一浏览器可以共享）</p>
<p>2）方法：与sessionStorage相同</p>
</li>
<li><p>案例：记住用户名</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;remember&quot; /&gt; 记住用户名
&lt;script&gt;
  var username = document.querySelector(&#39;#username&#39;)
  var remember = document.querySelector(&#39;#remember&#39;)
  if (localStorage.getItem(&#39;username&#39;)) {
    username.value = localStorage.getItem(&#39;username&#39;)
    remember.checked = true
  }
  remember.addEventListener(&#39;change&#39;, function () {
    if (this.checked) {
      localStorage.setItem(&#39;username&#39;, username.value)
    } else {
      localStorage.removeItem(&#39;username&#39;)
    }
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例：ToDoList</p>
<p>1）页面刷新内容不会丢失：本地存储localStorage</p>
<p>2）文本框输入内容，按下回车生成代办事项：<code>$(&quot;element&quot;).on(&quot;keydown&quot;,function(event){if(event.keyCode===13){...}})</code></p>
<p>3）先从localStorage取数据，再将新数据push添加到数组，再存储给localStorage</p>
<p>4）点击删除按钮，内容消失：</p>
<ul>
<li>点击<a>链接删除的不是li，而是本地存储中对应的数据</li>
<li>先获取本地存储数据，删除对应数据后保存，重新渲染列表li</li>
<li>给每个<a>添加index属性，便于查找要删除的数据索引</li>
</ul>
<p>5）点击待办事项复选框，把当前数据添加到已完成事项中：点击之后获取本地存储数据，修改done属性值为当前复选框checked状态</p>
<p>6）点击已完成事项复选框，把当前数据添加到待办事项中</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;header&gt;
  &lt;section&gt;
    &lt;label for=&quot;title&quot;&gt;ToDoList&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;title&quot; name=&quot;title&quot; placeholder=&quot;添加ToDo&quot; required=&quot;required&quot; autocomplete=&quot;off&quot; /&gt;
  &lt;/section&gt;
&lt;/header&gt;
&lt;section&gt;
  &lt;h2&gt;正在进行 &lt;span id=&quot;todocount&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
  &lt;ol id=&quot;todolist&quot; class=&quot;demo-box&quot;&gt;&lt;/ol&gt;
  &lt;h2&gt;已经完成 &lt;span id=&quot;donecount&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
  &lt;ul id=&quot;donelist&quot;&gt;&lt;/ul&gt;
&lt;/section&gt;
&lt;footer&gt;Copyright &amp;copy; 2014 todolist.cn&lt;/footer&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">$(function () {
  // 1. 按下回车，把完整数据存储到本地存储里面
  // 存储的数据格式：var todolist = [{title: &quot;xxx&quot;, done: false}]
  load()
  $(&#39;#title&#39;).on(&#39;keydown&#39;, function (event) {
    if (event.keyCode === 13) {
      if ($(this).val() === &#39;&#39;) {
        alert(&#39;请输入您要的操作&#39;)
      } else {
        // 先读取本地存储原来的数据
        var local = getDate()
        // 把local数组进行更新数据，把最新的数据追加给local数组
        local.push({ title: $(this).val(), done: false })
        // 把这个数组给本地存储
        saveDate(local)
        // 2. toDoList 本地存储数据渲染加载到页面
        load()
        $(this).val(&#39;&#39;)
      }
    }
  })
  // 3. toDoList 删除操作
  $(&#39;ol, ul&#39;).on(&#39;click&#39;, &#39;a&#39;, function () {
    // 先获取本地存储
    var data = getDate()
    console.log(data)
    // 修改数据
    var index = $(this).attr(&#39;id&#39;)
    console.log(index)
    data.splice(index, 1)
    // 保存到本地存储
    saveDate(data)
    // 重新渲染页面
    // load()
    // 用fadeOut效果淡出
    $(this).parent(&#39;li&#39;).fadeOut()
  })
  // 4. toDoList 正在进行和已完成选项操作
  $(&#39;ol, ul&#39;).on(&#39;click&#39;, &#39;input&#39;, function () {
    // 先获取本地存储的数据
    var data = getDate()
    // 修改数据
    var index = $(this).siblings(&#39;a&#39;).attr(&#39;id&#39;)
    data[index].done = $(this).prop(&#39;checked&#39;)
    // 保存到本地存储
    saveDate(data)
    // 重新渲染页面
    load()
  })

  // 读取本地存储的数据
  function getDate() {
    var data = localStorage.getItem(&#39;todolist&#39;)
    if (data !== null) {
      // 本地存储里面的数据是字符串格式的 但是需要的是对象格式的
      return JSON.parse(data)
    } else {
      return []
    }
  }
  // 保存本地存储数据
  function saveDate(data) {
    localStorage.setItem(&#39;todolist&#39;, JSON.stringify(data))
  }
  // 渲染加载数据
  function load() {
    // 读取本地存储的数据
    var data = getDate()
    // 遍历之前先要清空ol里面的元素内容
    $(&#39;ol, ul&#39;).empty()
    var todoCount = 0 // 正在进行的个数
    var doneCount = 0 // 已经完成的个数
    // 遍历这个数据
    $.each(data, function (i, n) {
      if (n.done) {
        $(&#39;ul&#39;).prepend(&quot;&lt;li&gt;&lt;input type=&#39;checkbox&#39; checked=&#39;checked&#39; &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href=&#39;javascript:;&#39; id=&quot; + i + &#39; &gt;&lt;/a&gt;&lt;/li&gt;&#39;)
        doneCount++
      } else {
        $(&#39;ol&#39;).prepend(&quot;&lt;li&gt;&lt;input type=&#39;checkbox&#39; &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href=&#39;javascript:;&#39; id=&quot; + i + &#39; &gt;&lt;/a&gt;&lt;/li&gt;&#39;)
        todoCount++
      }
    })
    $(&#39;#todocount&#39;).text(todoCount)
    $(&#39;#donecount&#39;).text(doneCount)
  }
})
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-3-3-location-">3.3.3 location对象</h4>
<ol>
<li><p>用途：用于获取或设置窗体的URL，可以解析URL</p>
</li>
<li><p>URL：统一资源定位符（Uniform Resource Locator），互联网上每个文件都有唯一的URL</p>
<ul>
<li>语法：<code>protocol://host[:port]/path/[?query]#fragment</code></li>
</ul>
<p>1）protocol：通信协议，如http、https、maito等</p>
<p>2）host：主机（域名）</p>
<p>3）port：端口号，可选，省略时使用方案默认端口，如http默认端口为80</p>
<p>4）path：路径，表示主机上的一个目录或文件地址</p>
<p>5）query：参数，以键值对的形式通过&amp;符号分隔开来</p>
<p>6）fragment：片段，#后面内容常见于链接锚点</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：获取URL参数--&gt;
&lt;!--login.html--&gt;
&lt;form action=&quot;index.html&quot;&gt;
  用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;
  &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;
&lt;/form&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--index.html--&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  console.log(location.search) // ?uname=andy
  // 1.先去掉问号
  var params = location.search.substr(1) // uname=andy
  console.log(params)
  // 2. 把字符串分割为数组
  var arr = params.split(&#39;=&#39;)
  console.log(arr) // [&quot;uname&quot;, &quot;ANDY&quot;]
  // 3.把数据写入div中，decodeURIComponent可以显示中文
  var div = document.querySelector(&#39;div&#39;)
  div.innerHTML = decodeURIComponent(arr[1]) + &#39;欢迎您&#39;
&lt;/script&gt;
</code></pre>
</li>
<li><p>属性：</p>
<p>1）<code>location.href</code>：获取或设置整个URL</p>
<p>2）<code>location.host</code>：返回主机（域名）</p>
<p>3）<code>location.port</code>：返回端口号，如果未写返回空字符串&quot; &quot;</p>
<p>4）<code>location.pathname</code>：返回路径，对应的path</p>
<p>5）<code>location.search</code>：返回参数，对应的query，注意：如果参数中带有中文，需要用<code>decodeURIComponent()</code>解码</p>
<p>6）<code>location.hash</code>：返回片段，对应的fragment</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button&gt;点击&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  var btn = document.querySelector(&#39;button&#39;)
  var div = document.querySelector(&#39;div&#39;)
  btn.addEventListener(&#39;click&#39;, function () {
    // console.log(location.href);
    location.href = &#39;http://www.itcast.cn&#39;
  })
  var timer = 5
  var count_down = function () {
    if (timer == 0) {
      location.href = &#39;http://www.itcast.cn&#39;
    } else {
      div.innerHTML = &#39;您将在&#39; + timer + &#39;秒钟之后跳转到首页&#39;
      timer--
    }
  }
  count_down()
  setInterval(count_down, 1000)
&lt;/script&gt;
</code></pre>
</li>
<li><p>方法:</p>
<p>1）location.assign()：与href相同，可以跳转页面，可以后退</p>
<p>2）location.replace()：替换当前页面，但不记录历史，不能后退页面</p>
<p>3）location.reload()：重新加载页面，相当于刷新按钮/F5，如果参数为true，强制刷新Ctrl+F5（不读取缓存）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;button&gt;黑马IT(可后退)&lt;/button&gt;
&lt;button&gt;黑马IT(不可后退)&lt;/button&gt;
&lt;button&gt;刷新页面&lt;/button&gt;
&lt;script&gt;
  var btns = document.querySelectorAll(&#39;button&#39;)
  // 记录浏览历史，可以实现后退功能
  btns[0].addEventListener(&#39;click&#39;, () =&gt; {
    location.assign(&#39;http://www.itcast.cn&#39;)
  })
  // 不记录浏览历史，不可以实现后退功能
  btns[1].addEventListener(&#39;click&#39;, () =&gt; {
    location.replace(&#39;http://www.itcast.cn&#39;)
  })
  // 强制刷新页面
  btns[2].addEventListener(&#39;click&#39;, () =&gt; {
    location.reload(ture)
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-3-4-navigator-">3.3.4 navigator对象</h4>
<ol>
<li><p><code>navigator.userAgent</code>：适配不同设备，如果是移动端，可以自动跳转到H5页面；返回由客户端发送服务器的user-agent头部的值</p>
<pre class="prettyprint linenums:0"><code class="lang-js">if (navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|
wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)) {
  window.location.href = &#39;../H5/index.html&#39; //手机页面所在文件
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-3-5-history-">3.3.5 history对象</h4>
<ol>
<li><p>定义：与浏览器历史进行交互，包含用户访问过的URL</p>
</li>
<li><p>方法：</p>
<p>1）<code>back()</code>：后退</p>
<p>2）<code>forward()</code>：前进</p>
<p>3）<code>go(参数)</code>：前进后退功能，参数为1即前进1个页面，参数为-1即后退1个页面</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- index.html --&gt;
&lt;a href=&quot;list.html&quot;&gt;点击我去往列表页&lt;/a&gt;
&lt;button&gt;前进&lt;/button&gt;
&lt;script&gt;
  var btn = document.querySelector(&#39;button&#39;)
  btn.addEventListener(&#39;click&#39;, function () {
    // history.forward();
    history.go(1)
  })
&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;a href=&quot;list.html&quot;&gt;点击我去往首页&lt;/a&gt;
&lt;button&gt;后退&lt;/button&gt;
&lt;script&gt;
  var btn = document.querySelector(&#39;button&#39;)
  btn.addEventListener(&#39;click&#39;, function () {
    // history.back();
    history.go(-1)
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h3 id="3-4-">3.4 网页特效</h3>
<h4 id="3-4-1-offset-">3.4.1 offset偏移量</h4>
<ul>
<li><p>带边框：padding、边框、内容</p>
</li>
<li><p>属性：只读属性，不可赋值，无法更改元素样式</p>
<p>1）<code>element.offsetParent</code>：返回作为该元素带有定位的父级元素，如过父级元素没有定位返回body</p>
<p>2）<code>element.offsetTop</code>：返回元素相对带有定位父元素上方的偏移</p>
<p>3）<code>element.offsetLeft</code>：返回元素相对带有定位父元素左边框的偏移</p>
<p>4）<code>element.offsetWidth</code>：返回自身包括padding、边框、内容区的宽度，返回数值不带单位</p>
<p>5）<code>element.offsetHeight</code>：返回自身包括padding、边框、内容区的高度，返回数值不带单位</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .father {
    /* position: relative; */
    width: 200px;
    height: 200px;
    background-color: pink;
    margin: 150px;
  }
  .son {
    width: 100px;
    height: 100px;
    background-color: purple;
    margin-left: 45px;
  }
  .w {
    height: 200px;
    background-color: skyblue;
    margin: 0 auto 200px;
    padding: 10px;
    border: 15px solid red;
  }
&lt;/style&gt;

&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;w&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  var father = document.querySelector(&#39;.father&#39;)
  var son = document.querySelector(&#39;.son&#39;)
  // 1.可以得到元素的偏移位置，返回的不带单位的数值
  console.log(father.offsetTop)
  console.log(father.offsetLeft)
  // 它以带有定位的父亲为准，如果没有父亲或者父亲没有定位，则以body为准
  console.log(son.offsetLeft)
  var w = document.querySelector(&#39;.w&#39;)

  // 2.可以得到元素的大小：宽度和高度，包含padding + border + width
  console.log(w.offsetWidth)
  console.log(w.offsetHeight)

  // 3. 返回带有定位的父亲，否则返回的是body
  console.log(son.offsetParent) // 返回带有定位的父亲，否则返回的是body
  console.log(son.parentNode)   // 对比：返回最近一级的父亲，不管父亲有没有定位
&lt;/script&gt;
</code></pre>
</li>
<li><p>与sytle的区别：想获取元素大小位置用offset，想改变元素样式用style</p>
<p>1）offset可获取任意样式表样式值，style只能得到行内样式表的样式值</p>
<p>2）offset获得值没有单位，style获得值有单位</p>
<p>3）offsetWidth 包含 padding+border+width，style.width只包含width</p>
<p>4）offsetWidth是只读属性不能赋值，style.width可读写属性可以赋值</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .box {
    width: 200px;
    height: 200px;
    background-color: pink;
    padding: 10px;
  }
&lt;/style&gt;
&lt;div class=&quot;box&quot; style=&quot;width: 200px&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  // offset与style的区别
  var box = document.querySelector(&#39;.box&#39;)
  console.log(box.offsetWidth)    // 220
  console.log(box.style.width)    // 200px
  // box.offsetWidth = &#39;300px&#39;  // 不能这样修改
  box.style.width = &#39;300px&#39;
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例1：计算鼠标在盒子内的坐标</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .box {
    width: 300px;
    height: 300px;
    background-color: pink;
    margin: 200px;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
    // 1. 首先得到鼠标在页面中的坐标（e.pageX, e.pageY）
    // 2. 其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)
    // 3. 用鼠标距离页面的坐标减去盒子在页面中的距离，得到鼠标在盒子内的坐标
    var box = document.querySelector(&#39;.box&#39;)
    box.addEventListener(&#39;mousemove&#39;, function (e) {
      var x = e.pageX - this.offsetLeft
      var y = e.pageY - this.offsetTop
      this.innerHTML = &#39;x坐标是&#39; + x + &#39; y坐标是&#39; + y
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</li>
<li><p>案例2：模态框拖拽效果（mousedown开始拖拽事件，mouseup取消拖拽监听事件）</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .login-header {
    width: 100%;
    text-align: center;
    height: 30px;
    font-size: 24px;
    line-height: 30px;
  }
  a {
    text-decoration: none;
    color: #000000;
  }
  .login {
    display: none;
    width: 512px;
    height: 280px;
    position: fixed;
    border: #ebebeb solid 1px;
    left: 50%;
    top: 50%;
    background: #ffffff;
    box-shadow: 0px 0px 20px #ddd;
    z-index: 9999;
    transform: translate(-50%, -50%);
  }
  .login-title {
    width: 100%;
    margin: 10px 0px 0px 0px;
    text-align: center;
    line-height: 40px;
    height: 40px;
    font-size: 18px;
    position: relative;
    cursor: move;
  }
  .login-title span {
    position: absolute;
    font-size: 12px;
    right: -20px;
    top: -30px;
    background: #ffffff;
    border: #ebebeb solid 1px;
    width: 40px;
    height: 40px;
    border-radius: 20px;
  }
  .login-input-content {
    margin-top: 20px;
  }
  .login-input {
    overflow: hidden;
    margin: 0px 0px 20px 0px;
  }
  .login-input label {
    float: left;
    width: 90px;
    padding-right: 10px;
    text-align: right;
    line-height: 35px;
    height: 35px;
    font-size: 14px;
  }
  .login-input input.list-input {
    float: left;
    line-height: 35px;
    height: 35px;
    width: 350px;
    border: #ebebeb 1px solid;
    text-indent: 5px;
  }
  .login-button {
    width: 50%;
    margin: 30px auto 0px auto;
    line-height: 40px;
    font-size: 14px;
    border: #ebebeb 1px solid;
    text-align: center;
  }
  .login-button a {
    display: block;
  }
  .login-bg {
    display: none;
    width: 100%;
    height: 100%;
    position: fixed;
    top: 0px;
    left: 0px;
    background: rgba(0, 0, 0, 0.3);
  }
&lt;/style&gt;

&lt;div class=&quot;login-header&quot;&gt;&lt;a id=&quot;link&quot; href=&quot;javascript:;&quot;&gt;点击，弹出登录框&lt;/a&gt;&lt;/div&gt;
&lt;div id=&quot;login&quot; class=&quot;login&quot;&gt;
  &lt;div id=&quot;title&quot; class=&quot;login-title&quot;&gt;
    登录会员
    &lt;span&gt;&lt;a id=&quot;closeBtn&quot; href=&quot;javascript:void(0);&quot; class=&quot;close-login&quot;&gt;关闭&lt;/a&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class=&quot;login-input-content&quot;&gt;
    &lt;div class=&quot;login-input&quot;&gt;
      &lt;label&gt;用户名：&lt;/label&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; name=&quot;info[username]&quot; id=&quot;username&quot; class=&quot;list-input&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;login-input&quot;&gt;
      &lt;label&gt;登录密码：&lt;/label&gt;
      &lt;input type=&quot;password&quot; placeholder=&quot;请输入登录密码&quot; name=&quot;info[password]&quot; id=&quot;password&quot; class=&quot;list-input&quot; /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=&quot;loginBtn&quot; class=&quot;login-button&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot; id=&quot;login-button-submit&quot;&gt;登录会员&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;!-- 遮盖层 --&gt;
&lt;div id=&quot;bg&quot; class=&quot;login-bg&quot;&gt;&lt;/div&gt;

&lt;script&gt;
    // 1. 获取元素
    var login = document.querySelector(&#39;.login&#39;)
    var mask = document.querySelector(&#39;.login-bg&#39;)
    var link = document.querySelector(&#39;#link&#39;)
    var closeBtn = document.querySelector(&#39;#closeBtn&#39;)
    var title = document.querySelector(&#39;#title&#39;)
    // 2. 点击弹出层这个链接 link，让 mask 和 login 显示出来
    link.addEventListener(&#39;click&#39;, function () {
      mask.style.display = &#39;block&#39;
      login.style.display = &#39;block&#39;
    })
    // 3. 点击 closeBtn 就隐藏 mask 和 login
    closeBtn.addEventListener(&#39;click&#39;, function () {
      mask.style.display = &#39;none&#39;
      login.style.display = &#39;none&#39;
    })
    // 4. 开始拖拽
    // (1) 当我们鼠标按下，就获得鼠标在盒子内的坐标（一旦鼠标按下，这个坐标就是固定住了）
    title.addEventListener(&#39;mousedown&#39;, function (e) {
      var x = e.pageX - login.offsetLeft
      var y = e.pageY - login.offsetTop
      // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去鼠标在盒子内的坐标，就是模态框的left和top值
      document.addEventListener(&#39;mousemove&#39;, move)
      function move(e) {
        login.style.left = e.pageX - x + &#39;px&#39;
        login.style.top = e.pageY - y + &#39;px&#39;
      }
      // (3) 鼠标弹起，就让鼠标移动事件移除
      document.addEventListener(&#39;mouseup&#39;, function () {
        document.removeEventListener(&#39;mousemove&#39;, move)
      })
    })
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例3：电商详情页放大镜</p>
<p>1）鼠标经过橱窗preview_img，显示/隐藏遮挡层 mask 和放大镜大盒子 big</p>
<p>2）鼠标移动时，遮挡层mask跟着鼠标走</p>
<p>3）鼠标移动时，大图片也跟随mask移动</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;load&#39;, function () {
  var preview_img = document.querySelector(&#39;.preview_img&#39;)
  var mask = document.querySelector(&#39;.mask&#39;)
  var big = document.querySelector(&#39;.big&#39;)

  // 1. 当鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子
  preview_img.addEventListener(&#39;mouseover&#39;, function () {
    mask.style.display = &#39;block&#39;
    big.style.display = &#39;block&#39;
  })
  preview_img.addEventListener(&#39;mouseout&#39;, function () {
    mask.style.display = &#39;none&#39;
    big.style.display = &#39;none&#39;
  })

  // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走
  preview_img.addEventListener(&#39;mousemove&#39;, function (e) {
    // (1). 先计算出鼠标在盒子内的坐标
    var x = e.pageX - this.offsetLeft
    var y = e.pageY - this.offsetTop
    // (2) 减去盒子高度 300的一半是150，就是mask的最终left和top值了
    // (3) mask 移动的距离
    var maskX = x - mask.offsetWidth / 2
    var maskY = y - mask.offsetHeight / 2
    // (4) 如果x坐标小于0，就让他停在0的位置
    // 遮挡层的最大移动距离
    var maskMax = preview_img.offsetWidth - mask.offsetWidth
    if (maskX &lt;= 0) {
      maskX = 0
    } else if (maskX &gt;= maskMax) {
      maskX = maskMax
    }
    if (maskY &lt;= 0) {
      maskY = 0
    } else if (maskY &gt;= maskMax) {
      maskY = maskMax
    }
    mask.style.left = maskX + &#39;px&#39;
    mask.style.top = maskY + &#39;px&#39;

    // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
    // 大图
    var bigIMg = document.querySelector(&#39;.bigImg&#39;)
    // 大图片最大移动距离
    var bigMax = bigIMg.offsetWidth - big.offsetWidth
    // 大图片的移动距离 X Y
    var bigX = (maskX * bigMax) / maskMax
    var bigY = (maskY * bigMax) / maskMax
    bigIMg.style.left = -bigX + &#39;px&#39;
    bigIMg.style.top = -bigY + &#39;px&#39;
  })
})
</code></pre>
</li>
</ul>
<hr>
<h4 id="3-4-2-client-">3.4.2 client可视区</h4>
<ul>
<li><p>不带边框：padding、内容</p>
</li>
<li><p><code>event.clientTop</code>：返回元素上边框大小</p>
</li>
<li><p><code>event.clientLeft</code>：返回元素左边框大小</p>
</li>
<li><p><code>event.clientWidth</code>：返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</p>
</li>
<li><p><code>event.clientHeight</code>：返回自身包括padding、内容区的高度，不含边框，返回数值不带单位</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 200px;
    height: 200px;
    background-color: pink;
    border: 10px solid red;
    padding: 10px;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // client与offsetWidth最大的区别就是：不包含边框
  var div = document.querySelector(&#39;div&#39;)
  console.log(div.clientWidth)
&lt;/script&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="3-4-3-scroll-">3.4.3 scroll滚动区</h4>
<ul>
<li><p>与client的区别：scroll是内容真正宽高大小（含隐藏部分），而client只是可见部分的宽高大小</p>
</li>
<li><p>属性：</p>
<p>1）<code>event.scrollTop</code>：返回被卷去的上侧距离（无单位）</p>
<p>2）<code>event.scrollLeft</code>：返回被卷去的左侧距离（无单位）</p>
<p>3）<code>event.scrollWidth</code>：返回自身实际宽度，不含边框（无单位）</p>
<p>4）<code>event.scrollHeight</code>：返回自身实际高度，不含边框（无单位）</p>
</li>
<li><p>事件：scroll</p>
<p>1）定义：只要滚动条发生变化，就会触发该事件</p>
<p>2）语法：<code>element.addEventListener(&#39;scroll&#39;, fn)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 200px;
    height: 200px;
    background-color: pink;
    border: 10px solid red;
    padding: 10px;
    overflow: auto;
  }
&lt;/style&gt;
&lt;div&gt;
  我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 
我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容
  我是内容 我是内容 我是内容 我是内容 我是内容 我是内容 我是内容
&lt;/div&gt;
&lt;script&gt;
  // scroll 系列
  var div = document.querySelector(&#39;div&#39;)
  console.log(div.scrollHeight) // 290：自身实际高度，不含边框
  console.log(div.clientHeight) // 220：自身包括padding、内容区的高度，不含边框

  // scroll滚动事件：当滚动条发生变化会触发的事件
  div.addEventListener(&#39;scroll&#39;, function () {
    console.log(div.scrollTop)    // 在顶部：0；在底部：70
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例：淘宝粘性固定侧边栏</p>
<p>1）原理：计算页面被卷去的头部大小，滚动到指定位置后，侧边栏变为固定定位</p>
<p>2）注意：侧边栏变成固定定位时，需要修改对应的距离顶部值，不然会出现向下跳的情况，返回时也需要修改回原值</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .slider-bar {
    position: absolute;
    left: 50%;
    top: 300px;
    margin-left: 600px;
    width: 45px;
    height: 130px;
    background-color: pink;
  }
  .w {
    width: 1200px;
    margin: 10px auto;
  }
  .header {
    height: 150px;
    background-color: purple;
  }
  .banner {
    height: 250px;
    background-color: skyblue;
  }
  .main {
    height: 5000px;
    background-color: yellowgreen;
  }
  span {
    display: none;
    position: absolute;
    bottom: 0;
  }
&lt;/style&gt;

&lt;div class=&quot;slider-bar&quot;&gt;
  &lt;span class=&quot;goBack&quot;&gt;返回顶部&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;header w&quot;&gt;头部区域&lt;/div&gt;
&lt;div class=&quot;banner w&quot;&gt;banner区域&lt;/div&gt;
&lt;div class=&quot;main w&quot;&gt;主体部分&lt;/div&gt;
&lt;script&gt;
  //1. 获取元素
  var sliderbar = document.querySelector(&#39;.slider-bar&#39;)
  var banner = document.querySelector(&#39;.banner&#39;)
  // banner与顶部的距离，用于判断是否令侧边栏显示
  var bannerTop = banner.offsetTop
  // 当侧边栏固定定位之后应该变化的数值
  var sliderbarTop = sliderbar.offsetTop - bannerTop
  // 获取main 主体元素
  var main = document.querySelector(&#39;.main&#39;)
  var goBack = document.querySelector(&#39;.goBack&#39;)
  var mainTop = main.offsetTop
  // 2. 页面滚动事件 scroll
  document.addEventListener(&#39;scroll&#39;, function () {
    // window.pageYOffset 页面被卷去的头部
    // 当页面被卷去的头部大于等于banner距离页面顶端高度时，侧边栏就要改为固定定位，与页面顶部始终保持固定距
    if (window.pageYOffset &gt;= bannerTop) {
      sliderbar.style.position = &#39;fixed&#39;
      sliderbar.style.top = sliderbarTop + &#39;px&#39;
    } else {
      sliderbar.style.position = &#39;absolute&#39;
      sliderbar.style.top = &#39;300px&#39;
    }
    // 当页面滚动到main盒子，就显示 goback模块
    if (window.pageYOffset &gt;= mainTop) {
      goBack.style.display = &#39;block&#39;
    } else {
      goBack.style.display = &#39;none&#39;
    }
  })
  goBack.addEventListener(&#39;click&#39;, function () {
    animate(window, 0)
  })
  // 动画函数
  function animate(obj, target, callback) {
    clearInterval(obj.timer)
    obj.timer = setInterval(function () {
      // obj.offsetLeft 改为 window.pageYOffset
      var step = (target - window.pageYOffset) / 10
      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)
      if (window.pageYOffset == target) {
        clearInterval(obj.timer)
        callback &amp;&amp; callback()
      } else {
        window.scroll(0, window.pageYOffset + step)
      }
    }, 15)
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="3-4-4-">3.4.4 动画函数封装</h4>
<ol>
<li><p>原理：通过定时器<code>setInterval()</code>不断移动盒子位置，附加定时器停止的条件</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var div = document.querySelector(&#39;div&#39;)
var timer = setInterval(function () {
  if (div.offsetLeft &gt;= 400) {
    // 停止动画：本质是停止定时器
    clearInterval(timer)
  }
  div.style.left = div.offsetLeft + 1 + &#39;px&#39;
}, 30)
</code></pre>
<p>1）通过函数封装动画函数，里面的定时器名字最好用<code>obj.timer</code>的方式命名，同时要先清除旧定时器，可以避免重复调用定时器（后果是越来越快）</p>
<p>2）注意：盒子有绝对定位才能动起来</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    position: absolute;
    left: 0;
    width: 200px;
    height: 200px;
    text-align: center;
    line-height: 200px;
    background-color: #00e5ee;
    border-radius: 200px;
  }
&lt;/style&gt;

&lt;div&gt;大明湖&lt;/div&gt;

&lt;script&gt;
  function animate(obj, target) {
    // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
    // 解决方案：让元素只有一个定时器执行，先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer)
    obj.timer = setInterval(function () {
      if (obj.offsetLeft &gt;= target) {
        clearInterval(obj.timer)
      } else {
        obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;
      }
    }, 30)
  }
  var div = document.querySelector(&#39;div&#39;)
  // 调用函数
  animate(div, 300)
&lt;/script&gt;
</code></pre>
</li>
<li><p>缓动动画：让盒子每次移动距离变小，速度就会慢下来</p>
<p>1）算法：步长=(目标值-当前位置)/n份数</p>
<p>2）除法计算步长容易出现小数问题，需要转换为整数：<code>step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);</code></p>
<p>3）由于步长可以为负数，所以算法可以直接实现倒退效果</p>
<p>4）回调函数：如果想让元素在动画结束后执行某函数，可以将回调函数写到定时器结束语句后</p>
<ul>
<li>写法1：<code>if(callback){callback()}</code></li>
<li>写法2：<code>callback &amp;&amp; callback()</code>（短路运算a &amp;&amp; b，当a为真时返回b）</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;style&gt;
  span {
    position: absolute;
    left: 0;
    top: 200px;
    display: block;
    width: 150px;
    height: 150px;
    background-color: purple;
  }
&lt;/style&gt;
&lt;button class=&quot;btn800&quot;&gt;点击夏雨荷到800&lt;/button&gt;
&lt;span&gt;夏雨荷&lt;/span&gt;
&lt;script&gt;
  function animate(obj, target, callback) {
    clearInterval(obj.timer)
    obj.timer = setInterval(function () {
      var step = (target - obj.offsetLeft) / 10
      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)
      if (obj.offsetLeft == target) {
        // 停止动画：本质是停止定时器
        clearInterval(obj.timer)
        // 回调函数写到定时器结束里面
        if (callback) {
          callback()
        }
        // 另外写法
        // callback &amp;&amp; callback()
      } else {
        obj.style.left = obj.offsetLeft + step + &#39;px&#39;
      }
    }, 15)
  }
  var span = document.querySelector(&#39;span&#39;)
  var btn800 = document.querySelector(&#39;.btn800&#39;)
  btn800.addEventListener(&#39;click&#39;, function () {
    animate(span, 800, function () {
      span.style.backgroundColor = &#39;red&#39;
    })
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>插件：animate</p>
</li>
</ol>
<h4 id="3-4-5-">3.4.5 轮播图特效</h4>
<blockquote>
<p>轮播图插件：<a href="https://www.swiper.com.cn/">swiper</a></p>
</blockquote>
<ol>
<li><p>轮播图片：</p>
<p>1）ul&gt;li放轮播图片（最后需要复制一个第一张图），共n+1张图</p>
<p>2）ul超大宽度，li在内浮动，使ul可以装下所有图</p>
<p>3）触发动画时，ul运动，li不动</p>
<p>4）自动播放：计时器触发右箭头点击事件，鼠标移入后清除计时器</p>
</li>
<li><p>底部圆点：</p>
<p>1）ol&gt;li放小圆点，使用createElement创建圆点</p>
<p>2）添加index属性，代表图片编号：li.setAttribute(&#39;index&#39;,i)</p>
<p>3）用排他算法，令被选中的圆点具有突出效果</p>
<p>4）圆点索引变量：circle</p>
<p>5）同步左右箭头索引变量：num</p>
</li>
<li><p>左右箭头：</p>
<p>1）鼠标移动进轮播图主区域才显示箭头，离开时箭头消失</p>
<p>2）走到最前/最后时修改ul的left值，控制图片看起来像无缝衔接</p>
<p>3）箭头索引变量：num</p>
<p>4）同步底部圆点索引变量：circle</p>
</li>
<li><p>节流阀：</p>
<p>1）作用：在轮播图中，防止连续点击造成图片滚动过快，使用节流阀控制速度</p>
<p>2）算法：声明全局变量flag=true，if判断flag条件执行动画，先令flag=false，然后在动画函数传参使flag=true</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;load&#39;, function () {
  // 1. 获取元素
  var arrow_l = document.querySelector(&#39;.arrow-l&#39;)
  var arrow_r = document.querySelector(&#39;.arrow-r&#39;)
  var focus = document.querySelector(&#39;.focus&#39;)
  var focusWidth = focus.offsetWidth
  // 2. 鼠标经过focus 就显示隐藏左右按钮
  focus.addEventListener(&#39;mouseenter&#39;, function () {
    arrow_l.style.display = &#39;block&#39;
    arrow_r.style.display = &#39;block&#39;
    clearInterval(timer)
    timer = null // 清除定时器变量
  })
  focus.addEventListener(&#39;mouseleave&#39;, function () {
    arrow_l.style.display = &#39;none&#39;
    arrow_r.style.display = &#39;none&#39;
    timer = setInterval(function () {
      //手动调用点击事件
      arrow_r.click()
    }, 2000)
  })
  // 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈
  var ul = focus.querySelector(&#39;ul&#39;)
  var ol = focus.querySelector(&#39;.circle&#39;)
  // console.log(ul.children.length);
  for (var i = 0; i &lt; ul.children.length; i++) {
    // 创建一个小li
    var li = document.createElement(&#39;li&#39;)
    // 记录当前小圆圈的索引号 通过自定义属性来做
    li.setAttribute(&#39;index&#39;, i)
    // 把小li插入到ol 里面
    ol.appendChild(li)
    // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件
    li.addEventListener(&#39;click&#39;, function () {
      // 干掉所有人 把所有的小li 清除 current 类名
      for (var i = 0; i &lt; ol.children.length; i++) {
        ol.children[i].className = &#39;&#39;
      }
      // 留下我自己  当前的小li 设置current 类名
      this.className = &#39;current&#39;
      // 5. 点击小圆圈，移动图片 当然移动的是 ul
      // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值
      // 当我们点击了某个小li 就拿到当前小li 的索引号
      var index = this.getAttribute(&#39;index&#39;)
      // 当我们点击了某个小li 就要把这个li 的索引号给 num
      num = index
      // 当我们点击了某个小li 就要把这个li 的索引号给 circle
      circle = index
      // num = circle = index;
      console.log(focusWidth)
      console.log(index)
      animate(ul, -index * focusWidth)
    })
  }
  // 把ol里面的第一个小li设置类名为 current
  ol.children[0].className = &#39;current&#39;
  // 6. 克隆第一张图片(li)放到ul 最后面
  var first = ul.children[0].cloneNode(true)
  ul.appendChild(first)
  // 7. 点击右侧按钮， 图片滚动一张
  var num = 0
  // circle 控制小圆圈的播放
  var circle = 0
  // flag 节流阀
  var flag = true
  arrow_r.addEventListener(&#39;click&#39;, function () {
    if (flag) {
      flag = false // 关闭节流阀
      // 如果走到了最后复制的一张图片，此时ul要快速复原 left 改为 0
      if (num == ul.children.length - 1) {
        ul.style.left = 0
        num = 0
      }
      num++
      // 之所以会调到第二张图，是因为num=0后，又进行了num++，此时num=1
      animate(ul, -num * focusWidth, function () {
        flag = true // 打开节流阀
      })
      // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
      circle++
      // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原
      if (circle == ol.children.length) {
        circle = 0
      }
      // 调用函数
      circleChange()
    }
  })
  // 9. 左侧按钮做法
  arrow_l.addEventListener(&#39;click&#39;, function () {
    if (flag) {
      flag = false
      if (num == 0) {
        num = ul.children.length - 1
        ul.style.left = -num * focusWidth + &#39;px&#39;
      }
      num--
      animate(ul, -num * focusWidth, function () {
        flag = true
      })
      // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放
      circle--
      // 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）
      // if (circle &lt; 0) {
      //     circle = ol.children.length - 1;
      // }
      circle = circle &lt; 0 ? ol.children.length - 1 : circle
      // 调用函数
      circleChange()
    }
  })
  function circleChange() {
    // 先清除其余小圆圈的current类名
    for (var i = 0; i &lt; ol.children.length; i++) {
      ol.children[i].className = &#39;&#39;
    }
    // 留下当前的小圆圈的current类名
    ol.children[circle].className = &#39;current&#39;
  }
  // 10. 自动播放轮播图
  var timer = setInterval(function () {
    //手动调用点击事件
    arrow_r.click()
  }, 2000)
})
</code></pre>
</li>
<li><p>插件<a href="https://www.swiper.com.cn/">swiper</a>：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;load&#39;, function () {
  var swiper = new Swiper(&#39;.swiper-container&#39;, {
    spaceBetween: 30,
    centeredSlides: true,
    autoplay: {
      delay: 5000,
      disableOnInteraction: false,
    },
    pagination: {
      el: &#39;.swiper-pagination&#39;,
      clickable: true,
    },
    navigation: {
      nextEl: &#39;.swiper-button-next&#39;,
      prevEl: &#39;.swiper-button-prev&#39;,
    },
  })
})

</code></pre>
</li>
</ol>
<h4 id="3-4-6-">3.4.6 返回顶部</h4>
<ol>
<li><p>原理：将缓动动画函数中的 obj.offsetLeft 改为 window.pageYOffset</p>
</li>
<li><p>动作：window.scroll(0, window.pageYOffset + step)</p>
</li>
<li><p>调用：animate(window, 0)</p>
<pre class="prettyprint linenums:0"><code class="lang-js">function animate(obj, target, callback) {
  clearInterval(obj.timer)
  obj.timer = setInterval(function () {
    // obj.offsetLeft 改为 window.pageYOffset
    var step = (target - window.pageYOffset) / 10
    step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)
    // obj.offsetLeft 改为 window.pageYOffset
    if (window.pageYOffset == target) {
      clearInterval(obj.timer)
      callback &amp;&amp; callback()
    } else {
      window.scroll(0, window.pageYOffset + step)
    }
  }, 15)
}
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-4-7-">3.4.7 筋斗云</h4>
<ol>
<li><p>鼠标经过li，筋斗云跟到当前li：mouseenter --&gt; animate(cloud, this.offsetLeft)</p>
</li>
<li><p>鼠标离开li，筋斗云恢复原位：mouseleave --&gt; animate(cloud, current)</p>
</li>
<li><p>鼠标点击li，筋斗云留在当前li：click --&gt; current = this.offsetLeft</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  * {
    margin: 0;
    padding: 0;
  }
  ul {
    list-style: none;
  }
  body {
    background-color: black;
  }
  .c-nav {
    width: 900px;
    height: 42px;
    background: #fff url(images/rss.png) no-repeat right center;
    margin: 100px auto;
    border-radius: 5px;
    position: relative;
  }
  .c-nav ul {
    position: absolute;
  }
  .c-nav li {
    float: left;
    width: 83px;
    text-align: center;
    line-height: 42px;
  }
  .c-nav li a {
    color: #333;
    text-decoration: none;
    display: inline-block;
    height: 42px;
  }
  .c-nav li a:hover {
    color: white;
  }
  .c-nav li.current a {
    color: #0dff1d;
  }
  .cloud {
    position: absolute;
    left: 0;
    top: 0;
    width: 83px;
    height: 42px;
    background: url(images/cloud.gif) no-repeat;
  }
&lt;/style&gt;

&lt;script&gt;
  // 缓动动画函数
  function animate(obj, target, callback) {
    clearInterval(obj.timer)
    obj.timer = setInterval(function () {
      var step = (target - obj.offsetLeft) / 10
      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)
      if (obj.offsetLeft == target) {
        clearInterval(obj.timer)
        // 回调函数写到定时器结束里面
        callback &amp;&amp; callback()
      }
      obj.style.left = obj.offsetLeft + step + &#39;px&#39;
    }, 15)
  }
  // 窗口加载
  window.addEventListener(&#39;load&#39;, function () {
    // 1. 获取元素
    var cloud = document.querySelector(&#39;.cloud&#39;)
    var c_nav = document.querySelector(&#39;.c-nav&#39;)
    var lis = c_nav.querySelectorAll(&#39;li&#39;)
    // 2. 给所有的小li绑定事件
    // 这个current 做为筋斗云的起始位置
    var current = 0
    for (var i = 0; i &lt; lis.length; i++) {
      // (1) 鼠标经过把当前小li 的位置做为目标值
      lis[i].addEventListener(&#39;mouseenter&#39;, function () {
        animate(cloud, this.offsetLeft)
      })
      // (2) 鼠标离开就回到起始的位置
      lis[i].addEventListener(&#39;mouseleave&#39;, function () {
        animate(cloud, current)
      })
      // (3) 当鼠标点击，就把当前位置做为目标值
      lis[i].addEventListener(&#39;click&#39;, function () {
        current = this.offsetLeft
      })
    }
  })
&lt;/script&gt;

&lt;div id=&quot;c_nav&quot; class=&quot;c-nav&quot;&gt;
  &lt;span class=&quot;cloud&quot;&gt;&lt;/span&gt;
  &lt;ul&gt;
    &lt;li class=&quot;current&quot;&gt;&lt;a href=&quot;#&quot;&gt;首页新闻&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;师资力量&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;活动策划&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;企业文化&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;招聘信息&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司简介&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是佩奇&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;啥是佩奇&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="3-4-8-">3.4.8 移动端特效</h4>
<h5 id="3-4-8-1-">3.4.8.1 触摸屏幕</h5>
<ol>
<li><p>事件动作：</p>
<p>1）<code>touchstart</code>：手指获取元素</p>
<p>2）<code>touchmove</code>：手指移动元素</p>
<p>3）<code>touchend</code>：手指离开元素</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 100px;
    height: 100px;
    background-color: pink;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // 1. 手指触摸DOM元素事件
  var div = document.querySelector(&#39;div&#39;)
  div.addEventListener(&#39;touchstart&#39;, function () {
    console.log(&#39;我摸了你&#39;)
  })
  // 2. 手指在DOM元素身上移动事件
  div.addEventListener(&#39;touchmove&#39;, function () {
    console.log(&#39;我继续摸&#39;)
  })
  // 3. 手指离开DOM元素事件
  div.addEventListener(&#39;touchend&#39;, function () {
    console.log(&#39;轻轻的我走了&#39;)
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>事件对象：</p>
<p>1）<code>e.touches</code>：正在触摸屏幕的所有手指的列表</p>
<p>2）<code>e.targetTouches</code>：正在触摸当前DOM元素上的手指列表</p>
<p>3）<code>e.changedTouches</code>：手指状态发生改变的列表</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 100px;
    height: 100px;
    background-color: pink;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // 1. 手指触摸DOM元素事件
  var div = document.querySelector(&#39;div&#39;)
  div.addEventListener(&#39;touchstart&#39;, function (e) {
    // 得到正在触摸dom元素的第一个手指的相关信息：如手指的坐标等等
    console.log(e.targetTouches[0])
  })
  // 2. 手指在DOM元素身上移动事件
  div.addEventListener(&#39;touchmove&#39;, function () {})
  // 3. 手指离开DOM元素事件
  div.addEventListener(&#39;touchend&#39;, function (e) {
    // 当手指离开屏幕的时候，就没有了 touches 和 targetTouches 列表，但会有changedTouches
    console.log(e.changedTouches[0])
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>click事件延迟300ms：</p>
<p>1）原因：由于移动端双击手指可以放大/缩小屏幕，在第一次点击后的300ms内如果有第二次点击，则会放大屏幕</p>
<p>2）解决方案：</p>
<ul>
<li><p>禁用缩放：<meta name="viewport" content="user-scalable=no"></p>
</li>
<li><p>自己定义函数tap：如果手指触摸和离开时间小于150ms算作点击，但每次只能添加一个元素，非常麻烦</p>
</li>
<li><p><a href="https://github.com/ftlabs/fastclick">fastclick.js</a>插件：引入即可，按官方文档用法调用</p>
</li>
</ul>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;script src=&quot;fastclick.js&quot;&gt;&lt;/script&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  if (&#39;addEventListener&#39; in document) {
    document.addEventListener(
      &#39;DOMContentLoaded&#39;,
      function () {
        FastClick.attach(document.body)
      },
      false
    )
  }
  var div = document.querySelector(&#39;div&#39;)
  div.addEventListener(&#39;click&#39;, function () {
    alert(11)
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-4-8-2-">3.4.8.2 拖动元素</h5>
<ol>
<li><p>touchstart：初始坐标</p>
<p>1）手指初始坐标：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">startX = e.targetTouches[0].pageX
startY = e.targetTouches[0].pageY
</code></pre>
<p>2）元素初始坐标：</p>
<pre class="prettyprint linenums:0"><code class="lang-js">x = this.offsetLeft
y = this.offsetTop
</code></pre>
</li>
<li><p>touchmove：移动距离</p>
<p>1）手指移动距离</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var moveX = e.targetTouches[0].pageX - startX
var moveY = e.targetTouches[0].pageY - startY
</code></pre>
<p>2）元素移动距离</p>
<pre class="prettyprint linenums:0"><code class="lang-js">this.style.left = x + moveX + &#39;px&#39;
this.style.top = y + moveY + &#39;px&#39;
</code></pre>
<p>3）阻止屏幕滚动默认行为：<code>e.preventDefault()</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：手指移动盒子--&gt;
&lt;style&gt;
  div {
    position: absolute;
    left: 0;
    width: 100px;
    height: 100px;
    background-color: pink;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // （1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置
  // （2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子
  // （3） 离开手指 touchend:
  var div = document.querySelector(&#39;div&#39;)
  var startX = 0
  var startY = 0
  var x = 0 
  var y = 0
  div.addEventListener(&#39;touchstart&#39;, function (e) {
    //  获取手指初始坐标
    startX = e.targetTouches[0].pageX
    startY = e.targetTouches[0].pageY
    // 获得盒子原来的位置
    x = this.offsetLeft
    y = this.offsetTop
  })
  div.addEventListener(&#39;touchmove&#39;, function (e) {
    //  计算手指的移动距离： 手指移动之后的坐标减去手指初始的坐标
    var moveX = e.targetTouches[0].pageX - startX
    var moveY = e.targetTouches[0].pageY - startY
    // 移动盒子：盒子原来的位置 + 手指移动的距离
    this.style.left = x + moveX + &#39;px&#39;
    this.style.top = y + moveY + &#39;px&#39;
    e.preventDefault() // 阻止屏幕滚动的默认行为
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="3-4-8-3-">3.4.8.3 移动端轮播图</h5>
<ol>
<li><p>图片索引：index，由于ul一开始就往右移动了一格，最左侧的复制最后一张图被隐藏，这张图没有索引</p>
</li>
<li><p>轮播图片：</p>
<p>1）ul&gt;li放图片，第一张前复制最后一张图，最后一张图复制第一张图，共n+2张图</p>
<p>2）在移动端中，装图片的li要用百分比表示，如有5张图，li宽度为20%，此时才能设置img宽度100%，不然图片会以ul宽度为参考溢出屏幕</p>
<p>3）利用CSS3过渡+位移：transition、transform</p>
<p>4）移动距离：var translatex = -index * w;</p>
</li>
<li><p>无缝滚动：</p>
<p>1）等图片滚动完毕后在判断，即过渡完判断</p>
<p>2）监听过渡完成的事件：transitionend</p>
<p>3）到最后一张图：若index&gt;=ul.length-2，index恢复为0，取消transition=&#39;none&#39;，translateX归位</p>
<p>4）手指在第一张图往前划：若index&lt;0，index恢复为ul.length-3，取消transition=&#39;none&#39;，translateX归位</p>
</li>
<li><p>圆点跟随：利用classList添加/删除类名选择器</p>
<pre class="prettyprint linenums:0"><code class="lang-js">ol.querySelector(&#39;.current&#39;).classList.remove(&#39;current&#39;)
ol.children[index].classList.add(&#39;current&#39;)
</code></pre>
</li>
<li><p>手指滑动轮播图：</p>
<p>1）ul添加touchstart事件，获取手指初始X坐标，并停止计时器</p>
<p>2）ul添加touchmove事件，获取手指移动距离，移动ul，并取消过渡效果transition</p>
<p>3）e.preventDefault()：阻止滚动屏幕默认行为</p>
<p>4）添加flag=false全局变量，只有当手指滑动事件发生后，使flag=ture，便于后面手指松开效果触发的判断</p>
</li>
<li><p>手指离开图片回弹/跳转：</p>
<p>1）ul添加touchend事件，判断盒子移动距离的绝对值Math.abs(moveX)</p>
<ul>
<li>大于某值：跳转<ul>
<li>右划往左走：moveX&gt;0：index--</li>
<li>左划往右走：moveX&lt;0，index++</li>
</ul>
</li>
<li>小于某值：回弹<ul>
<li>index不变</li>
<li>利用CSS3过渡+位移：transition、transform</li>
</ul>
</li>
</ul>
<p>2）利用flag判断是否为手指滑动了图片再触发事件，而不是滑动了其他地方</p>
<p>3）重新启动定时器</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- 焦点图模块 --&gt;
&lt;div class=&quot;focus&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;img src=&quot;upload/focus3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;img src=&quot;upload/focus1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;img src=&quot;upload/focus2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;img src=&quot;upload/focus3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;img src=&quot;upload/focus1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!-- 小圆点 --&gt;
  &lt;ol&gt;
    &lt;li class=&quot;current&quot;&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">window.addEventListener(&#39;load&#39;, function () {
  // 1. 获取元素
  var focus = document.querySelector(&#39;.focus&#39;)
  var ul = focus.children[0]
  // 获得focus 的宽度
  var w = focus.offsetWidth
  var ol = focus.children[1]
  // 2. 利用定时器自动轮播图图片
  var index = 0
  var timer = setInterval(function () {
    index++
    var translatex = -index * w
    ul.style.transition = &#39;all .3s&#39;
    ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
  }, 2000)
  // 等着过渡完成之后，再去判断（监听过渡完成的事件：transitionend）
  ul.addEventListener(&#39;transitionend&#39;, function () {
    // 无缝滚动
    if (index &gt;= 3) {
      index = 0
      // console.log(index);
      // 去掉过渡效果，这样让的ul快速的跳到目标位置
      ul.style.transition = &#39;none&#39;
      // 利用最新的索引号乘以宽度 去滚动图片
      var translatex = -index * w
      ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
    } else if (index &lt; 0) {
      index = 2
      ul.style.transition = &#39;none&#39;
      // 利用最新的索引号乘以宽度去滚动图片
      var translatex = -index * w
      ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
    }
    // 3. 小圆点跟随变化
    // 把ol里面li带有current类名的选出来去掉类名 remove
    ol.querySelector(&#39;.current&#39;).classList.remove(&#39;current&#39;)
    // 让当前索引号的小li，加上 current（add）
    ol.children[index].classList.add(&#39;current&#39;)
  })

  // 4. 手指滑动轮播图
  // 触摸元素 touchstart： 获取手指初始坐标
  var startX = 0
  var moveX = 0 // 后面会使用这个移动距离所以要定义一个全局变量
  var flag = false
  ul.addEventListener(&#39;touchstart&#39;, function (e) {
    startX = e.targetTouches[0].pageX
    // 手指触摸的时候就停止定时器
    clearInterval(timer)
  })
  // 移动手指 touchmove：计算手指的滑动距离，并移动盒子
  ul.addEventListener(&#39;touchmove&#39;, function (e) {
    // 计算移动距离
    moveX = e.targetTouches[0].pageX - startX
    // 移动盒子：  盒子原来的位置 + 手指移动的距离
    var translatex = -index * w + moveX
    // 手指拖动的时候，不需要动画效果所以要取消过渡效果
    ul.style.transition = &#39;none&#39;
    ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
    flag = true // 如果用户手指移动过再去判断否则不做判断效果
    e.preventDefault() // 阻止滚动屏幕的行为
  })
  // 手指离开，根据移动距离去判断是回弹还是播放上一张下一张
  ul.addEventListener(&#39;touchend&#39;, function (e) {
    if (flag) {
      // (1) 如果移动距离大于50像素就播放上一张或者下一张
      if (Math.abs(moveX) &gt; 50) {
        // 如果是右滑就是 播放上一张 moveX 是正值
        if (moveX &gt; 0) {
          index--
        } else {
          // 如果是左滑就是 播放下一张 moveX 是负值
          index++
        }
        var translatex = -index * w
        ul.style.transition = &#39;all .3s&#39;
        ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
      } else {
        // (2) 如果移动距离小于50像素就回弹
        var translatex = -index * w
        ul.style.transition = &#39;all .1s&#39;
        ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
      }
    }
    // 手指离开的时候就重新开启定时器
    clearInterval(timer)
    timer = setInterval(function () {
      index++
      var translatex = -index * w
      ul.style.transition = &#39;all .3s&#39;
      ul.style.transform = &#39;translateX(&#39; + translatex + &#39;px)&#39;
    }, 2000)
  })

  // 返回顶部模块制作
  var goBack = document.querySelector(&#39;.goBack&#39;)
  var nav = document.querySelector(&#39;nav&#39;)
  window.addEventListener(&#39;scroll&#39;, function () {
    if (window.pageYOffset &gt;= nav.offsetTop) {
      goBack.style.display = &#39;block&#39;
    } else {
      goBack.style.display = &#39;none&#39;
    }
  })
  goBack.addEventListener(&#39;click&#39;, function () {
    window.scroll(0, 0)
  })
})
</code></pre>
</li>
</ol>
<h5 id="3-4-8-4-">3.4.8.4 视频插件</h5>
<ol>
<li><p><code>zy.media.js</code>：可以解决不同浏览器之间视频播放器样式不同的情况</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style type=&quot;text/css&quot;&gt;
  #modelView {
    background-color: #dddddd;
    z-index: 0;
    opacity: 0.7;
    height: 100%;
    width: 100%;
    position: relative;
  }
  .playvideo {
    padding-top: auto;
    z-index: 9999;
    position: relative;
    width: 300px;
    height: 200px;
  }
  .zy_media {
    z-index: 999999999;
  }
&lt;/style&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;zy.media.min.css&quot; /&gt;

&lt;div class=&quot;playvideo&quot;&gt;
  &lt;div class=&quot;zy_media&quot;&gt;
    &lt;video data-config=&#39;{&quot;mediaTitle&quot;: &quot;测试视频--视频&quot;}&#39;&gt;
      &lt;source src=&quot;mov.mp4&quot; type=&quot;video/mp4&quot; /&gt;
      您的浏览器不支持HTML5视频
    &lt;/video&gt;
  &lt;/div&gt;
  &lt;div id=&quot;modelView&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;zy.media.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  zymedia(&#39;video&#39;, {
    autoplay: true,
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h2 id="-4-jquery">第4章 jQuery</h2>
<blockquote>
<p>官网：<a href="https://jquery.com/">jquery.com</a></p>
</blockquote>
<h3 id="4-1-jquery-">4.1 jQuery基本概念</h3>
<h4 id="4-1-1-jquery-">4.1.1 jQuery简介</h4>
<ol>
<li>JS库：是一个封装好的特定的集合（方法和函数），如animate、hide、show等</li>
<li>常见的JS库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto</li>
<li>jQuery的意思是查询JS库，把JS中的DOM操作进行了封装，可以快速查询使用里面的功能</li>
</ol>
<hr>
<h4 id="4-1-2-">4.1.2 入口函数</h4>
<ol>
<li><p>作用：等待页面DOM加载完毕执行代码，相当于DOMContentLoaded</p>
</li>
<li><p>顶级对象<code>$</code>：<code>$</code>是jQuery的别称，可以用jQuery代替<code>$</code>符号，<code>$</code>也是jQuery的顶级对象，相当于window</p>
</li>
<li><p>语法：<code>$(document).ready(function(){...})</code>，<code>$(function() { ... })</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 等着页面DOM加载完毕再去执行js代码（以下三种写法等价）
$(document).ready(function () {
  ...
})

$(function () {
  ...
})

jQuery(function () {
  ...
})
</code></pre>
</li>
<li><p>多库共存：</p>
<p>1）若<code>$</code>符号冲突，使用jQuery代替<code>$</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 定义一个$()函数
function $(ele) {
  return document.querySelector(ele)
}
console.log($(&#39;div&#39;))
jQuery.each()
</code></pre>
<p>2）noConflick()：让jquery释放对<code>$</code>的控制权，自定义一个符号或名称</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 用￥代替$
var ￥ = $.noConflict()
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-1-3-jquery-">4.1.3 jQuery对象</h4>
<ol>
<li><p>DOM对象：用原生JS获取的对象，如：<code>document.querySelector(&#39;div&#39;)</code>，只能使用原生JS的属性和方法</p>
</li>
<li><p>jQuery对象：用jQuery方式获取过来的对象，利用<code>$</code>包装DOM元素（w.fn.init(n)），如：<code>$(div)</code>，只能使用 jQuery方法</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 1. DOM 对象：用原生js获取过来的对象就是DOM对象
var myDiv = document.querySelector(&#39;div&#39;) // myDiv 是DOM对象
var mySpan = document.querySelector(&#39;span&#39;) // mySpan 是DOM对象
console.dir(myDiv)

// 2. jQuery对象：用jquery方式获取过来的对象是jQuery对象。 本质：通过$把DOM元素进行了包装
$(&#39;div&#39;) // $(&#39;div&#39;)是一个jQuery 对象
$(&#39;span&#39;) // $(&#39;span&#39;)是一个jQuery 对象
console.dir($(&#39;div&#39;))

// 3. jQuery 对象只能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 属性和方法
myDiv.style.display = &#39;none&#39;
myDiv.hide() // myDiv是一个dom对象不能使用 jquery里面的hide方法
$(&#39;div&#39;).style.display = &#39;none&#39; // 这个$(&#39;div&#39;)是一个jQuery对象不能使用原生js的属性和方法
</code></pre>
</li>
<li><p>DOM转JQ：</p>
<p>1）DOM对象：<code>$(&#39;element&#39;)</code>，里面有引号</p>
<p>2）用原生JS获取来的DOM对象：<code>$(object)</code>，里面没有引号</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;video src=&quot;mov.mp4&quot; muted&gt;&lt;/video&gt;
&lt;script&gt;
  // (1) 直接获取视频，得到就是jQuery对象
  $(&#39;video&#39;)
  // (2) 已经使用原生js获取过来DOM对象
  var myvideo = document.querySelector(&#39;video&#39;)
  $(myvideo)
&lt;/script&gt;
</code></pre>
</li>
<li><p>JQ转DOM：</p>
<p>1）<code>$(&#39;element&#39;)[index]</code></p>
<p>2）<code>$(&#39;element&#39;).get(index)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;video src=&quot;mov.mp4&quot; muted&gt;&lt;/video&gt;
&lt;script&gt;
  // play()方法只有原生DOM才能使用，需要把jQuery对象转为DOM
  $(&#39;video&#39;)[0].play()
  $(&#39;video&#39;).get(0).play()
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-1-4-jquery-">4.1.4 jQuery方法</h4>
<ol>
<li><p><code>index()</code>：获取当前元素的索引值</p>
<p>1）如果只有一层嵌套，<code>$(this).index()</code>可以获取当前元素索引</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;
  &lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;
  &lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;
  &lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;
&lt;/div&gt;
&lt;script&gt;
  $(&#39;div a&#39;).click(function () {
    console.log($(this).index())
  })
&lt;/script&gt;
</code></pre>
<p>2）如果有多层嵌套，<code>$(this).index()</code>无法获取当前元素索引，返回值0</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;a&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;b&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  $(&#39;ul a&#39;).click(function () {
    console.log($(this).index())
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>toFixed(n)</code>：保留n位小数</p>
</li>
<li><p><code>hover([over,] out)</code>：鼠标事件</p>
<p>1）第一个位置over（可选）：相当于mouseenter触发的函数</p>
<p>2）第二个位置out：相当于mouseleave触发的函数</p>
<p>3）注意：如果里面只写一个函数，鼠标经过、离开都会触发这个函数</p>
</li>
<li><p><code>change(fn{...})</code>：表单事件，checkbox中checked属性发生变化的事件</p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&#39;input&#39;).change(function () {
  console.log($(this).prop(&#39;checked&#39;))
})
</code></pre>
</li>
</ol>
<hr>
<h3 id="4-2-jquery-api">4.2 jQuery API</h3>
<h4 id="4-2-1-jquery-">4.2.1 jQuery选择器</h4>
<blockquote>
<p>语法：<code>$(&quot;选择器&quot;)</code></p>
</blockquote>
<h5 id="4-2-1-1-">4.2.1.1 基础选择器</h5>
<ol>
<li><p>ID选择器：<code>$(&quot;#id&quot;)</code></p>
</li>
<li><p>全选择器：<code>$(&quot;*&quot;)</code></p>
</li>
<li><p>类选择器：<code>$(&quot;.class&quot;)</code></p>
</li>
<li><p>标签选择器：<code>$(&quot;div&quot;)</code></p>
</li>
<li><p>并集选择器：<code>$(&quot;div,p,li&quot;)</code></p>
</li>
<li><p>交集选择器：<code>$(&quot;li.current&quot;)</code></p>
</li>
<li><p>子代选择器：<code>$(&quot;ul&gt;li&quot;)</code>，选中最近一级子元素</p>
</li>
<li><p>后代选择器：<code>$(&quot;ul li&quot;)</code>，选中全部子元素</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：下拉菜单--&gt;
&lt;ul class=&quot;nav&quot;&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  $(function () {
    // 鼠标经过
    $(&#39;.nav&gt;li&#39;).mouseover(function () {
      $(this).children(&#39;ul&#39;).show()
    })
    // 鼠标离开
    $(&#39;.nav&gt;li&#39;).mouseout(function () {
      $(this).children(&#39;ul&#39;).hide()
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-1-2-">4.2.1.2 筛选选择器</h5>
<ol>
<li><p><code>:first</code>：获取第一个元素，例：<code>$(&quot;li:first&quot;)</code></p>
</li>
<li><p><code>:last</code>：获取最后一个元素，例：<code>$(&quot;li:last&quot;)</code></p>
</li>
<li><p><code>:eq(index)</code>：获取到的元素中索引号为index的元素，例：<code>$(&quot;li:eq(2)&quot;)</code></p>
</li>
<li><p><code>:odd</code>：获取到的元素中索引号为奇数的元素，例：<code>$(&quot;li:odd&quot;)</code></p>
</li>
<li><p><code>:even</code>：获取到的元素中索引号为偶数的元素，例：<code>$(&quot;li:even&quot;):checked</code>：获取被选中的元素（如应用在checkbox）</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
  &lt;li&gt;多个里面筛选几个&lt;/li&gt;
&lt;/ol&gt;
&lt;script&gt;
  $(function () {
    $(&#39;ul li:first&#39;).css(&#39;color&#39;, &#39;red&#39;)
    $(&#39;ul li:eq(2)&#39;).css(&#39;color&#39;, &#39;blue&#39;)
    $(&#39;ol li:odd&#39;).css(&#39;color&#39;, &#39;skyblue&#39;)
    $(&#39;ol li:even&#39;).css(&#39;color&#39;, &#39;pink&#39;)
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-1-3-">4.2.1.3 筛选方法</h5>
<ol>
<li><p><code>parent()</code>：查找最近一级父元素，例：<code>$(&quot;li&quot;).parent()</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">// 如果有多个嵌套祖先，可以在parent()中指定祖先类名进行查找
&lt;div class=&quot;one&quot;&gt;
  &lt;div class=&quot;two&quot;&gt;
    &lt;div class=&quot;three&quot;&gt;
      &lt;div class=&quot;four&quot;&gt;我不容易&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  console.log($(&#39;.four&#39;).parent().parent().parent())
  console.log($(&#39;.four&#39;).parents())
  console.log($(&#39;.four&#39;).parents(&#39;.one&#39;))
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>children(selector)</code>：查找最近一级子元素，例：<code>$(&quot;ul&quot;).children(&quot;li&quot;)</code>，相当于<code>$(&quot;ul&gt;li&quot;)</code></p>
</li>
<li><p><code>find(selector)</code>：后代选择器，包含所有孩子，例：<code>$(&quot;ul&quot;).find(&quot;li&quot;)</code>，相当于<code>$(&quot;ul li&quot;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;div class=&quot;one&quot;&gt;
  &lt;div class=&quot;two&quot;&gt;
    &lt;div class=&quot;three&quot;&gt;
      &lt;div class=&quot;four&quot;&gt;我不容易&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  // 查找最近一级子元素
  console.log($(&#39;.one&#39;).children(&#39;div&#39;))
  // 后代选择器，包含所有孩子
  console.log($(&#39;.one&#39;).find(&#39;div&#39;))
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>siblings(selector)</code>：查找兄弟节点，不包括自身，例：<code>$(&quot;.first&quot;).siblings(&quot;li&quot;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">// 应用：排他思想
&lt;button&gt;快速&lt;/button&gt;
&lt;button&gt;快速&lt;/button&gt;
&lt;button&gt;快速&lt;/button&gt;
&lt;script&gt;
  $(function () {
    // 1. 隐式迭代，给所有的按钮都绑定了点击事件
    $(&#39;button&#39;).click(function () {
      // 2. 当前的元素变化背景颜色
      $(this).css(&#39;background&#39;, &#39;pink&#39;)
      // 3. 其余的兄弟去掉背景颜色
      $(this).siblings(&#39;button&#39;).css(&#39;background&#39;, &#39;&#39;)
    })
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>nextAll([expr])</code>：查找当前元素之后所有的同辈元素，例：<code>$(&quot;.first&quot;).nextAll()</code></p>
</li>
<li><p><code>prevtAll([expr])</code>：查找当前元素之前所有的同辈元素，例：<code>$(&quot;.last&quot;).prevtAll()</code></p>
</li>
<li><p><code>hasClass(class)</code>：检查当前元素是否含有某个特定类，返回true，例：<code>$(&quot;div&quot;).hasClass(&quot;protected&quot;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;current&quot;&gt;俺有current&lt;/div&gt;
&lt;div&gt;俺没有current&lt;/div&gt;
&lt;script&gt;
  $(function () {
    // 判断是否有某个类名
    console.log($(&#39;div:first&#39;).hasClass(&#39;current&#39;))
    console.log($(&#39;div:last&#39;).hasClass(&#39;current&#39;))
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>eq(index)</code>：等同于:eq(index)，例：<code>$(&quot;li&quot;).eq(2)</code>，相当于<code>$(&quot;li:eq(2)&quot;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul&gt;
  &lt;li&gt;我是ol 的li&lt;/li&gt;
  &lt;li&gt;我是ol 的li&lt;/li&gt;
  &lt;li&gt;我是ol 的li&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  $(function () {
    var index = 2
    // (1) 可以利用选择器的方式选择
    $(&#39;ul li:eq(2)&#39;).css(&#39;color&#39;, &#39;blue&#39;)
    $(&#39;ul li:eq(&#39; + index + &#39;)&#39;).css(&#39;color&#39;, &#39;blue&#39;)
    // (2) 可以利用选择方法的方式选择（更推荐这种写法）
    $(&#39;ul li&#39;).eq(2).css(&#39;color&#39;, &#39;blue&#39;)
    $(&#39;ul li&#39;).eq(index).css(&#39;color&#39;, &#39;blue&#39;)
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-2-2-jquery-">4.2.2 jQuery样式操作</h4>
<blockquote>
<p>隐式迭代：遍历内部DOM元素的过程，不再需要for循环修改样式了</p>
</blockquote>
<h5 id="4-2-2-1-css-">4.2.2.1 CSS方法</h5>
<ol>
<li><p>只写属性名，返回属性值：<code>$(&#39;element&#39;).css(&#39;属性&#39;)</code></p>
</li>
<li><p>修改单个样式：<code>$(&#39;element&#39;).css(&#39;属性&#39;, &#39;值&#39;)</code></p>
<p>1）属性名一定要加引号</p>
<p>2）属性值如果是数字不用加引号和单位</p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&quot;div&quot;).css(&quot;background&quot;, &quot;pink&quot;)
</code></pre>
</li>
<li><p>以对象形式修改多个样式：<code>$(&#39;element&#39;).css({属性1:值1, 属性2:值2, ...})</code></p>
<p>1）属性名不用加引号，复合属性必须用驼峰命名法</p>
<p>2）属性值如果不是数字需要加引号</p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&#39;div&#39;).css({
  width: 400,
  height: 400,
  backgroundColor: &#39;red&#39;,
})
</code></pre>
</li>
</ol>
<h5 id="4-2-2-2-">4.2.2.2 类样式方法</h5>
<ul>
<li><p>里面写的类名不用加“.”</p>
</li>
<li><p>添加类：<code>$(&quot;element&quot;).addClass(&quot;classname&quot;)</code>,不影响原类名，类似JS的classList操作，而原生JS的element.className会覆盖原类名</p>
</li>
<li><p>删除类：<code>$(&quot;element&quot;).removeClass(&quot;classname&quot;)</code></p>
</li>
<li><p>切换类：<code>$(&quot;element&quot;).toggleClass(&quot;classname&quot;)</code>，若类名存在则删除，若类名不存在则添加上</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;style&gt;
  div {
    width: 150px;
    height: 150px;
    background-color: pink;
    margin: 100px auto;
    transition: all 0.5s;
  }
  .current {
    background-color: red;
    transform: rotate(360deg);
  }
&lt;/style&gt;

&lt;div class=&quot;current&quot;&gt;&lt;/div&gt;

&lt;script&gt;
  $(function () {
    // 1. 添加类 addClass()
    $(&#39;div&#39;).click(function () {
      $(this).addClass(&quot;current&quot;);
    })
    // 2. 删除类 removeClass()
    $(&#39;div&#39;).click(function () {
      $(this).removeClass(&#39;current&#39;)
    })
    // 3. 切换类 toggleClass()
    $(&#39;div&#39;).click(function () {
      $(this).toggleClass(&#39;current&#39;)
    })
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例：Tab栏切换</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：Tab栏切换--&gt;
&lt;style&gt;
  * {
    margin: 0;
    padding: 0;
  }
  li {
    list-style-type: none;
  }
  .tab {
    width: 978px;
    margin: 100px auto;
  }
  .tab_list {
    height: 39px;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
  }
  .tab_list li {
    float: left;
    height: 39px;
    line-height: 39px;
    padding: 0 20px;
    text-align: center;
    cursor: pointer;
  }
  .tab_list .current {
    background-color: #c81623;
    color: #fff;
  }
  .item_info {
    padding: 20px 0 0 20px;
  }
  .item {
    display: none;
  }
&lt;/style&gt;

&lt;div class=&quot;tab&quot;&gt;
  &lt;div class=&quot;tab_list&quot;&gt;
    &lt;ul&gt;
      &lt;li class=&quot;current&quot;&gt;商品介绍&lt;/li&gt;
      &lt;li&gt;规格与包装&lt;/li&gt;
      &lt;li&gt;售后保障&lt;/li&gt;
      &lt;li&gt;商品评价（50000）&lt;/li&gt;
      &lt;li&gt;手机社区&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;div class=&quot;tab_con&quot;&gt;
    &lt;div class=&quot;item&quot; style=&quot;display: block&quot;&gt;商品介绍模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;规格与包装模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;售后保障模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;商品评价（50000）模块内容&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;手机社区模块内容&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  $(function () {
    // 1.点击上部的li，当前li添加current类，其余兄弟移除类
    $(&#39;.tab_list li&#39;).click(function () {
      // 链式编程操作
      $(this).addClass(&#39;current&#39;).siblings().removeClass(&#39;current&#39;)
      // 2.点击的同时，得到当前li的索引号
      var index = $(this).index()
      // 3.让下部里面相应索引号的item显示，其余的item隐藏
      $(&#39;.tab_con .item&#39;).eq(index).show().siblings().hide()
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="4-2-3-jquery-">4.2.3 jQuery动态效果</h4>
<h5 id="4-2-3-1-">4.2.3.1 显示隐藏</h5>
<ol>
<li><p><code>show(speed,callback)</code>：显示</p>
</li>
<li><p><code>hide(speed,callback)</code>：隐藏</p>
</li>
<li><p><code>togggle(speed,callback)</code>：切换</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 150px;
    height: 300px;
    background-color: pink;
  }
&lt;/style&gt;

&lt;button&gt;显示&lt;/button&gt;
&lt;button&gt;隐藏&lt;/button&gt;
&lt;button&gt;切换&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;

&lt;script&gt;
  $(function () {
    $(&#39;button&#39;)
      .eq(0)
      .click(function () {
        $(&#39;div&#39;).show(1000, function () {
          alert(1)
        })
      })
    $(&#39;button&#39;)
      .eq(1)
      .click(function () {
        $(&#39;div&#39;).hide(1000, function () {
          alert(1)
        })
      })
    $(&#39;button&#39;)
      .eq(2)
      .click(function () {
        $(&#39;div&#39;).toggle(1000)
      })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-3-2-">4.2.3.2 滑动</h5>
<ol>
<li><p><code>slideDown(speed,callback)</code>：下滑，一般和display: none配合</p>
</li>
<li><p><code>slideUp(speed,callback)</code>：上滑，一般和display: none配合</p>
</li>
<li><p><code>slideToggle(speed,callback)</code>：切换滑动</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 150px;
    height: 300px;
    background-color: pink;
    display: none;
  }
&lt;/style&gt;

&lt;button&gt;下拉滑动&lt;/button&gt;
&lt;button&gt;上拉滑动&lt;/button&gt;
&lt;button&gt;切换滑动&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;

&lt;script&gt;
  $(function () {
    $(&#39;button&#39;)
      .eq(0)
      .click(function () {
        // 下滑动 slideDown()
        $(&#39;div&#39;).slideDown()
      })
    $(&#39;button&#39;)
      .eq(1)
      .click(function () {
        // 上滑动 slideUp()
        $(&#39;div&#39;).slideUp(500)
      })
    $(&#39;button&#39;)
      .eq(2)
      .click(function () {
        // 滑动切换 slideToggle()
        $(&#39;div&#39;).slideToggle(500)
      })
  })
&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：下拉菜单--&gt;
&lt;ul class=&quot;nav&quot;&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  $(function () {
    $(&#39;.nav&gt;li&#39;).hover(function () {
      // 注意：这里有个问题，如果鼠标快速滑动，会造成动画效果卡顿（后面可以用stop()解决）
      $(this).children(&#39;ul&#39;).slideToggle()
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-3-3-">4.2.3.3 淡入淡出</h5>
<ol>
<li><p><code>fadeIn(speed,callback)</code>：淡入</p>
</li>
<li><p><code>fadeOut(speed,callback)</code>：淡出</p>
</li>
<li><p><code>fadeToggle(speed,callback)</code>：淡入淡出切换</p>
</li>
<li><p><code>fadeTo(speed,opacity,[easing],callback)</code>：修改透明度，速度和透明度参数必须写</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 150px;
    height: 300px;
    background-color: pink;
    display: none;
  }
&lt;/style&gt;

&lt;button&gt;淡入效果&lt;/button&gt;
&lt;button&gt;淡出效果&lt;/button&gt;
&lt;button&gt;淡入淡出切换&lt;/button&gt;
&lt;button&gt;修改透明度&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;

&lt;script&gt;
  $(function () {
    $(&#39;button&#39;)
      .eq(0)
      .click(function () {
        // 淡入 fadeIn()
        $(&#39;div&#39;).fadeIn(1000)
      })
    $(&#39;button&#39;)
      .eq(1)
      .click(function () {
        // 淡出 fadeOut()
        $(&#39;div&#39;).fadeOut(1000)
      })
    $(&#39;button&#39;)
      .eq(2)
      .click(function () {
        // 淡入淡出切换 fadeToggle()
        $(&#39;div&#39;).fadeToggle(1000)
      })
    $(&#39;button&#39;)
      .eq(3)
      .click(function () {
        //  修改透明度 fadeTo() 这个速度和透明度要必须写
        $(&#39;div&#39;).fadeTo(1000, 0.5)
      })
  })
&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：图片高亮显示--&gt;
&lt;style&gt;
  * {
    margin: 0;
    padding: 0;
  }
  ul {
    list-style: none;
  }
  body {
    background: #000;
  }
  .wrap {
    margin: 100px auto 0;
    width: 630px;
    height: 394px;
    padding: 10px 0 0 10px;
    background: #000;
    overflow: hidden;
    border: 1px solid #fff;
  }
  .wrap li {
    float: left;
    margin: 0 10px 10px 0;
  }
  .wrap img {
    display: block;
    border: 0;
  }
&lt;/style&gt;
&lt;script&gt;
  $(function () {
    //鼠标进入的时候，其他的li标签透明度：0.5
    $(&#39;.wrap li&#39;).hover(
      function () {
        $(this).siblings().stop().fadeTo(400, 0.5)
      },
      function () {
        // 鼠标离开，其他li 透明度改为 1
        $(this).siblings().stop().fadeTo(400, 1)
      }
    )
  })
&lt;/script&gt;
&lt;div class=&quot;wrap&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-3-4-">4.2.3.4 效果函数参数</h5>
<ol>
<li><p>speed：动画速度</p>
<p>1）预设字符：slow、normal、fast</p>
<p>2）毫秒数值：如1000，即为1秒</p>
</li>
<li><p>easing：切换效果</p>
<p>1）swing：先快再慢（默认）</p>
<p>2）linear：匀速运动</p>
</li>
</ol>
<h5 id="4-2-3-4-">4.2.3.4 动画停止排队</h5>
<ol>
<li><p>语法：<code>stop()</code></p>
</li>
<li><p>作用：如果不加stop()，鼠标多次经过触发按钮的动画事件，会反复执行</p>
</li>
<li><p>写到效果/动画函数的前面</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;!--案例：下拉菜单--&gt;
&lt;ul class=&quot;nav&quot;&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  $(function () {
    $(&#39;.nav&gt;li&#39;).hover(function () {
      // 解决了鼠标快速滑动，造成动画效果卡顿的问题
      $(this).children(&#39;ul&#39;).slideToggle()
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-3-5-">4.2.3.5 自定义动画</h5>
<ol>
<li><p>语法：<code>animate(params,[speed],[easing],[callback])</code>，params：想要更改的样式属性，以对象形式传递</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    position: absolute;
    width: 200px;
    height: 200px;
    background-color: pink;
  }
&lt;/style&gt;
&lt;button&gt;动起来&lt;/button&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  $(function () {
    $(&#39;button&#39;).click(function () {
      $(&#39;div&#39;).animate(
        {
          left: 500,
          top: 300,
          opacity: 0.4,
          width: 500,
        },
        500
      )
    })
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>案例：王者荣耀手风琴效果</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0;
    padding: 0;
  }
  img {
    display: block;
  }
  ul {
    list-style: none;
  }
  .king {
    width: 852px;
    margin: 100px auto;
    background: url(https://game.gtimg.cn/images/yxzj/web201605/top_banner/bg_header.png) no-repeat;
    overflow: hidden;
    padding: 10px;
  }
  .king ul {
    overflow: hidden;
  }
  .king li {
    position: relative;
    float: left;
    width: 69px;
    height: 69px;
    margin-right: 10px;
  }
  .king li.current {
    width: 224px;
  }
  .king li.current .big {
    display: block;
  }
  .king li.current .small {
    display: none;
  }
  .big {
    width: 224px;
    display: none;
  }
  .small {
    position: absolute;
    top: 0;
    left: 0;
    width: 69px;
    height: 69px;
    border-radius: 5px;
  }
&lt;/style&gt;
&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(function () {
    // 鼠标经过某个小li 有两步操作：
    $(&#39;.king li&#39;).mouseenter(function(){
      // 1.当前小li宽度变为 224px，同时里面的小图片淡出，大图片淡入
      $(this)
        .stop()
        .animate({
          width: 224,
        })
        .find(&#39;.small&#39;)
        .stop()
        .fadeOut()
        .siblings(&#39;.big&#39;)
        .stop()
        .fadeIn()
      // 2.其余兄弟小li宽度变为69px，小图片淡入，大图片淡出
      $(this)
        .siblings(&#39;li&#39;)
        .stop()
        .animate({
          width: 69,
        })
        .find(&#39;.small&#39;)
        .stop()
        .fadeIn()
        .siblings(&#39;.big&#39;)
        .stop()
        .fadeOut()
    })
  })
&lt;/script&gt;

&lt;div class=&quot;king&quot;&gt;
  &lt;ul&gt;
    &lt;li class=&quot;current&quot;&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/116/116.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/116/116-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/117/117.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/117/117-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/118/118.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/118/118-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/119/119.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/119/119-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/120/120.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/120/120-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/121/121.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/121/121-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a href=&quot;#&quot;&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/123/123.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
        &lt;img src=&quot;https://game.gtimg.cn/images/yxzj/img201606/heroimg/123/123-freehover.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-2-4-jquery-">4.2.4 jQuery属性操作</h4>
<ol>
<li><p><code>prop()</code></p>
<p>1）获取固有属性：<code>prop(&quot;属性&quot;)</code></p>
<p>2）设置固有属性：<code>prop(&quot;属性&quot;, &quot;属性值&quot;)</code></p>
</li>
<li><p><code>attr()</code></p>
<p>1）获取自定义属性：<code>attr(&quot;属性&quot;)</code>，类似原生JS中的getAttribute()</p>
<p>2）设置自定义属性：<code>attr(&quot;属性&quot;,&quot;属性值&quot;)</code>，类似原生JS中的setAttribute()</p>
</li>
<li><p><code>data()</code></p>
<p>1）设置缓存属性：<code>data(&quot;属性&quot;,&quot;属性值&quot;)</code>，缓存在内存，浏览器刷新后消失</p>
<p>2）获取缓存属性：<code>data(&quot;属性&quot;)</code>，注意：获取H5定义的“data-属性名”不用加“data-&quot;</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked /&gt;
&lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt;
&lt;span&gt;123&lt;/span&gt;
&lt;script&gt;
  $(function () {
    //1. prop()：获取元素固有的属性值
    console.log($(&#39;a&#39;).prop(&#39;href&#39;))
    $(&#39;a&#39;).prop(&#39;title&#39;, &#39;我们都挺好&#39;)
    $(&#39;input&#39;).change(function () {
      console.log($(this).prop(&#39;checked&#39;))
    })

    // 2. attr()：获取元素的自定义属性
    console.log($(&#39;div&#39;).attr(&#39;index&#39;))
    $(&#39;div&#39;).attr(&#39;index&#39;, 4)
    console.log($(&#39;div&#39;).attr(&#39;data-index&#39;))

    // 3. data()：缓存在内存，浏览器刷新后消失
    $(&#39;span&#39;).data(&#39;uname&#39;, &#39;andy&#39;)    // 为span设置uname属性，值为andy
    console.log($(&#39;span&#39;).data(&#39;uname&#39;))
    // 获取H5定义的“data-属性名”不用加“data-&quot;
    console.log($(&#39;div&#39;).data(&#39;index&#39;))
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-2-5-jquery-">4.2.5 jQuery文本属性</h4>
<ol>
<li><p>获取设置文本内容：<code>text()</code>，相当于原生JS的innerText</p>
</li>
<li><p>获取设置元素内容：<code>html()</code>，相当于原生JS的innerHTML</p>
</li>
<li><p>获取设置表单值：val()，例：清空表单值：<code>$(&#39;element&#39;).val(&#39;&#39;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;div&gt;
  &lt;span&gt;我是内容&lt;/span&gt;
&lt;/div&gt;
&lt;input type=&quot;text&quot; value=&quot;请输入内容&quot; /&gt;
&lt;script&gt;
  // 1. 获取设置元素内容 html()
  console.log($(&#39;div&#39;).html())
  $(&#39;div&#39;).html(&#39;123&#39;)
  // 2. 获取设置元素文本内容 text()
  console.log($(&#39;div&#39;).text())
  $(&#39;div&#39;).text(&#39;123&#39;)
  // 3. 获取设置表单值 val()
  console.log($(&#39;input&#39;).val())
  $(&#39;input&#39;).val(&#39;123&#39;)
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-2-6-jquery-">4.2.6 jQuery元素操作</h4>
<h5 id="4-2-6-1-">4.2.6.1 遍历元素</h5>
<ol>
<li><p>隐式迭代（默认）：只能统一修改样式，无法差异化</p>
</li>
<li><p>语法1：<code>$(&quot;element&quot;).each(function(index, domEle){...})</code></p>
<p>1）index：索引号（JQ已自动编号）</p>
<p>2）domEle：每个DOM元素对象，不是JQ对象</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2&lt;/div&gt;
&lt;div&gt;3&lt;/div&gt;
&lt;script&gt;
  $(function () {
    var sum = 0
    // each() 方法遍历元素
    var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
    $(&#39;div&#39;).each(function (i, domEle) {
      // 第一个参数：索引号；第二个参数：dom元素对象
      $(domEle).css(&#39;color&#39;, arr[i])
      sum += parseInt($(domEle).text())
    })
    console.log(sum)
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p>语法2：<code>$.each($(&quot;element&quot;),function(index, domEle){...})</code></p>
<p>1）区别：用于遍历、处理数据</p>
<p>2）如果element是对象，index输出属性名，domEle输出属性值</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2&lt;/div&gt;
&lt;div&gt;3&lt;/div&gt;
&lt;script&gt;
  $(function () {
    // $.each()方法遍历元素
    $.each($(&#39;div&#39;), function (i, ele) {
      console.log(i)
      console.log(ele)
    })
    $.each(arr, function (i, ele) {
      console.log(i)
      console.log(ele)
    })
    $.each(
      {
        name: &#39;andy&#39;,
        age: 18,
      },
      function (i, ele) {
        console.log(i)   // 属性名：name age
        console.log(ele) // 属性值：andy  18
      }
    )
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h5 id="4-2-6-2-">4.2.6.2 创建元素</h5>
<ol>
<li><code>$(&quot;html标签&quot;)</code>：例：$(&quot;<li>我是后来创建的li</li>&quot;)</li>
</ol>
<h5 id="4-2-6-3-">4.2.6.3 添加元素</h5>
<ol>
<li><p>内部添加：</p>
<p>1）添加到最前面：<code>$(&quot;element&quot;).prepend(jQuery元素)</code></p>
<p>2）添加到最后面：<code>$(&quot;element&quot;).append(jQuery元素)</code></p>
</li>
<li><p>外部添加：</p>
<p>1）添加到前面：<code>$(&quot;element&quot;).before(jQuery元素)</code></p>
<p>2）添加到后面：<code>$(&quot;element&quot;).after(jQuery元素)</code></p>
</li>
<li><p>删除元素：</p>
<p>1）删除匹配的元素：<code>$(&quot;element&quot;).remove()</code></p>
<p>2）删除匹配的元素里面的子节点：<code>$(&quot;element&quot;).empty()</code></p>
<p>3）清空匹配的元素内容：<code>$(&quot;element&quot;).html(&quot;&quot;)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;ul&gt;
  &lt;li&gt;原先的li&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt;
&lt;script&gt;
  $(function () {
    // 1. 创建元素
    var li = $(&#39;&lt;li&gt;我是后来创建的li&lt;/li&gt;&#39;)
    // 2. 添加元素
    // (1) 内部添加
    $(&#39;ul&#39;).append(li) //内部添加并且放到内容的最后面
    $(&#39;ul&#39;).prepend(li) // 内部添加并且放到内容的最前面
    // (2) 外部添加
    var div = $(&#39;&lt;div&gt;我是后妈生的&lt;/div&gt;&#39;)
    $(&#39;.test&#39;).after(div)
    $(&#39;.test&#39;).before(div)
    // 3. 删除元素
    $(&#39;ul&#39;).remove() // 可以删除匹配的元素 自杀
    $(&#39;ul&#39;).empty() // 可以删除匹配的元素里面的子节点 孩子
    $(&#39;ul&#39;).html(&#39;&#39;) // 可以删除匹配的元素里面的子节点 孩子
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<hr>
<h4 id="4-2-7-jquery-">4.2.7 jQuery大小操作</h4>
<ul>
<li><p>注意：若不填参数则返回数字值；若参数为数字则修改相应值，可以不写单位</p>
</li>
<li><p><code>width()</code> / <code>height()</code>：元素本身宽、高</p>
</li>
<li><p><code>innderWidth()</code> / <code>innerHeight()</code>：包含padding</p>
</li>
<li><p><code>outerWidth()</code> / <code>outerHeight()</code>：包含padding、border</p>
</li>
<li><p><code>outerWidth(ture)</code> / <code>outerHeight(ture)</code>：包含padding、border、margin</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 200px;
    height: 200px;
    background-color: pink;
    padding: 10px;
    border: 15px solid red;
    margin: 20px;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  $(function () {
    // 1. width() / height() 获取设置元素 width和height大小
    console.log($(&#39;div&#39;).width())
    // 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小
    console.log($(&#39;div&#39;).innerWidth())
    // 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小
    console.log($(&#39;div&#39;).outerWidth())
    // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin
    console.log($(&#39;div&#39;).outerWidth(true))
  })
&lt;/script&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="4-2-8-jquery-">4.2.8 jQuery位置操作</h4>
<ol>
<li><p><code>offset()</code>：元素相对于文档的偏移坐标，与父级无关</p>
<p>1）属性：top、left</p>
<p>2）括号内填写数字可以修改数值</p>
</li>
<li><p><code>position()</code>：元素相对于父级的偏移坐标，没有父级则以文档为参考</p>
<p>1）属性：top、left</p>
<p>2）只能获取，不能修改</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  .father {
    width: 400px;
    height: 400px;
    background-color: pink;
    margin: 100px;
    overflow: hidden;
    position: relative;
  }
  .son {
    width: 150px;
    height: 150px;
    background-color: purple;
    position: absolute;
    left: 10px;
    top: 10px;
  }
&lt;/style&gt;
&lt;div class=&quot;father&quot;&gt;
  &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  $(function () {
    // 1. offset：获取设置距离文档的位置（偏移）
    console.log($(&#39;.son&#39;).offset())        // {top: 200, left: 200}
    console.log($(&#39;.son&#39;).offset().top)    // 200
    $(&#39;.son&#39;).offset({
      top: 200,
      left: 200,
    })
    // 2. position：获取距离带有定位父级位置（偏移），如果没有带有定位的父级，则以文档为准
    // 这个方法只能获取不能设置偏移
    console.log($(&#39;.son&#39;).position())    // {top: 100, left: 100}
  })
&lt;/script&gt;
</code></pre>
</li>
<li><p><code>scrollTop()</code> / <code>scrollLeft()</code>：元素被卷去的头部和左侧</p>
<p>1）配合页面滚动事件：<code>$(window).scroll(function(){...})</code></p>
<p>2）页面被卷去的头部：<code>$(document).scrollTop()</code></p>
<p>3）返回顶部动画：<code>$(&quot;body, html&quot;).stop().animate({scrollTop:0})</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  body {
    height: 2000px;
  }
  .back {
    position: fixed;
    width: 50px;
    height: 50px;
    background-color: pink;
    right: 30px;
    bottom: 100px;
    display: none;
  }
  .container {
    width: 900px;
    height: 500px;
    background-color: skyblue;
    margin: 400px auto;
  }
&lt;/style&gt;

&lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt;
&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  $(function () {
    $(document).scrollTop(100)
    // 页面滚动事件
    var boxTop = $(&#39;.container&#39;).offset().top
    $(window).scroll(function () {
      console.log($(document).scrollTop())
      if ($(document).scrollTop() &gt;= boxTop) {
        $(&#39;.back&#39;).fadeIn()
      } else {
        $(&#39;.back&#39;).fadeOut()
      }
    })
    // 返回顶部
    $(&#39;.back&#39;).click(function () {
      $(&#39;body, html&#39;).stop().animate({
        scrollTop: 0,
      })
    })
  })
&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-js">// 案例：电梯导航
$(function () {
  // 当点击了小li，此时不需要执行，页面滚动事件里面的li的背景选择，添加current
  // 节流阀（互斥锁）
  var flag = true
  // 1.显示隐藏电梯导航
  var toolTop = $(&#39;.recommend&#39;).offset().top
  toggleTool()
  function toggleTool() {
    if ($(document).scrollTop() &gt;= toolTop) {
      $(&#39;.fixedtool&#39;).fadeIn()
    } else {
      $(&#39;.fixedtool&#39;).fadeOut()
    }
  }
  $(window).scroll(function () {
    toggleTool()
    // 3. 页面滚动到某个内容区域，左侧电梯导航小li相应添加和删除current类名
    if (flag) {
      $(&#39;.floor .w&#39;).each(function (i, ele) {
        if ($(document).scrollTop() &gt;= $(ele).offset().top) {
          console.log(i)
          $(&#39;.fixedtool li&#39;).eq(i).addClass(&#39;current&#39;).siblings().removeClass()
        }
      })
    }
  })
  // 2. 点击电梯导航页面可以滚动到相应内容区域
  $(&#39;.fixedtool li&#39;).click(function () {
    flag = false
    console.log($(this).index())
    // 当每次点击小li，就需要计算出页面要去往的位置
    // 选出对应索引号的内容区的盒子，计算它的.offset().top
    var current = $(&#39;.floor .w&#39;).eq($(this).index()).offset().top
    // 页面动画滚动效果
    $(&#39;body, html&#39;)
      .stop()
      .animate(
        {
          scrollTop: current,
        },
        function () {
          flag = true
        }
      )
    // 点击之后，让当前的小li添加current类名，姐妹移除current类名
    $(this).addClass(&#39;current&#39;).siblings().removeClass()
  })
})
</code></pre>
</li>
</ol>
<hr>
<h3 id="4-3-jquery-">4.3 jQuery事件</h3>
<h4 id="4-3-1-">4.3.1 单事件注册</h4>
<ol>
<li><p><code>$(&quot;element&quot;).事件动作(fn(){...})</code>：每次只能绑定一个事件</p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&#39;div&#39;).click(function () {
  $(this).css(&#39;background&#39;, &#39;purple&#39;)
})
</code></pre>
</li>
</ol>
<h4 id="4-3-2-on-">4.3.2 事件处理: on()</h4>
<ol>
<li><p>可以绑定多个事件处理程序</p>
<p>1）语法：<code>$(&quot;element&quot;).on(events, [selector], fn)</code></p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&#39;div&#39;).on({
  mouseenter: function () {
    $(this).css(&#39;background&#39;, &#39;skyblue&#39;)
  },
  click: function () {
    $(this).css(&#39;background&#39;, &#39;purple&#39;)
  },
  mouseleave: function () {
    $(this).css(&#39;background&#39;, &#39;blue&#39;)
  },
})
</code></pre>
<p>2）若多个事件处理方法相同可合并写</p>
<pre class="prettyprint linenums:0"><code class="lang-js">$(&#39;div&#39;).on(&#39;mouseenter mouseleave&#39;, function () {
  $(this).toggleClass(&#39;current&#39;)
})
</code></pre>
</li>
<li><p>可以实现事件委托/委派</p>
<p>1）定义：把原来加在子元素身上的绑定事件绑在父元素身上</p>
<p>2）注意：旧方法bind()、live()、delegate()已经被on()替代</p>
<pre class="prettyprint linenums:0"><code class="lang-js">// click绑定在ul上，但触发的对象是里面的li
$(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function () {
  alert(11)
})
</code></pre>
</li>
<li><p>给未来动态创建的元素绑定事件</p>
<p>1）绑定尚未创建的子元素：<code>$(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;,fn{...} )</code></p>
<p>2）创建子元素：<code>var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;)</code></p>
<p>3）添加子元素：<code>$(&quot;ol&quot;).append(li)</code></p>
<p>4）注意：此时$(&quot;ol li&quot;).click()是无效的，无法给动态创建的元素添加事件</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;ol&gt;&lt;/ol&gt;
&lt;script&gt;
  // 错误写法：单事件注册无法给动态创建的元素添加事件
  // $(&#39;ol li&#39;).click(function () {
  //   alert(11)
  // })
  // 正确写法：事件处理on()
  $(&#39;ol&#39;).on(&#39;click&#39;, &#39;li&#39;, function () {
    alert(11)
  })
  var li = $(&#39;&lt;li&gt;我是后来创建的&lt;/li&gt;&#39;)
  $(&#39;ol&#39;).append(li)
&lt;/script&gt;
</code></pre>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--案例：微博发布效果--&gt;
&lt;style&gt;
  ul {
    list-style: none;
  }
  .box {
    width: 600px;
    margin: 100px auto;
    border: 1px solid #000;
    padding: 20px;
  }
  textarea {
    width: 450px;
    height: 160px;
    outline: none;
    resize: none;
  }
  ul {
    width: 450px;
    padding-left: 80px;
  }
  ul li {
    line-height: 25px;
    border-bottom: 1px dashed #cccccc;
    display: none;
  }
  input {
    float: right;
  }
  ul li a {
    float: right;
  }
&lt;/style&gt;

&lt;script&gt;
  $(function () {
    // 1.点击发布按钮，动态创建一个小li，放入文本框的内容和删除按钮，并且加到ul中
    $(&#39;.btn&#39;).on(&#39;click&#39;, function () {
      var li = $(&#39;&lt;li&gt;&lt;/li&gt;&#39;)
      li.html($(&#39;.txt&#39;).val() + &quot;&lt;a href=&#39;javascript:;&#39;&gt; 删除&lt;/a&gt;&quot;)
      $(&#39;ul&#39;).prepend(li)
      li.slideDown()
      $(&#39;.txt&#39;).val(&#39;&#39;)
    })
    // 2.点击删除按钮，可以删除当前的微博留言li
    $(&#39;ul&#39;).on(&#39;click&#39;, &#39;a&#39;, function () {
      // this是a, a的parent是li
      $(this)
        .parent()
        .slideUp(function () {
          $(this).remove()
        })
    })
  })
&lt;/script&gt;

&lt;div class=&quot;box&quot; id=&quot;weibo&quot;&gt;
  &lt;span&gt;微博发布&lt;/span&gt;
  &lt;textarea name=&quot;&quot; class=&quot;txt&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
  &lt;button class=&quot;btn&quot;&gt;发布&lt;/button&gt;
  &lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</li>
</ol>
<h4 id="4-3-3-one-">4.3.3 单次触发: one()</h4>
<ol>
<li><p><code>$(&quot;element&quot;).one(events,[selector],fn)</code>：只能触发一次事件</p>
<pre class="prettyprint linenums:0"><code class="lang-js">&lt;p&gt;我是P&lt;/p&gt;
&lt;script&gt;
  $(function () {
    // one()：只能触发事件一次
    $(&#39;p&#39;).one(&#39;click&#39;, function () {
      alert(11)
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h4 id="4-3-4-off-">4.3.4 事件解绑: off()</h4>
<ul>
<li><p>off()可以移除通过on()添加的事件处理程序</p>
</li>
<li><p>解绑所有事件：<code>$(&quot;element&quot;).off()</code></p>
</li>
<li><p>解绑指定事件：<code>$(&quot;element&quot;).off(events)</code></p>
</li>
<li><p>解除事件委托：<code>$(&quot;element&quot;).off(events, [selector])</code></p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;我们都是好孩子&lt;/li&gt;
  &lt;li&gt;我们都是好孩子&lt;/li&gt;
  &lt;li&gt;我们都是好孩子&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  $(function () {
    $(&#39;div&#39;).on({
      click: function () {
        console.log(&#39;我点击了&#39;)
      },
      mouseover: function () {
        console.log(&#39;我鼠标经过了&#39;)
      },
    })
    $(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function () {
      alert(11)
    })
    // 事件解绑 off
    $(&#39;div&#39;).off()                 // 解除div身上的所有事件
    $(&#39;div&#39;).off(&#39;click&#39;)         // 解除div身上的点击事件
    $(&#39;ul&#39;).off(&#39;click&#39;, &#39;li&#39;)    // 解除ul身上的事件委托
  })
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h4 id="4-3-5-trigger-">4.3.5 自动触发: trigger()</h4>
<ol>
<li><p><code>$(&quot;element&quot;).事件()</code>：默认方法</p>
</li>
<li><p><code>$(&quot;element&quot;).trigger(&quot;事件&quot;)</code>：触发元素的默认行为</p>
</li>
<li><p><code>$(&quot;element&quot;).triggerHandler(&quot;事件&quot;)</code>：不会触发元素的默认行为，例：表单获得焦点后会有光标闪烁，可以用此方法取消光标闪烁</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;div&gt;&lt;/div&gt;
&lt;input type=&quot;text&quot; /&gt;
&lt;script&gt;
  $(function () {
    $(&#39;div&#39;).on(&#39;click&#39;, function () {
      alert(11)
    })
    // 自动触发事件
    // 1. 元素.事件()：会触发元素的默认行为
    $(&#39;div&#39;).click()
    // 2. 元素.trigger(&quot;事件&quot;)：会触发元素的默认行为
    $(&#39;div&#39;).trigger(&#39;click&#39;)
    // 3. 元素.triggerHandler(&quot;事件&quot;) ：不会触发元素的默认行为
    // 表单获得焦点后会有光标闪烁，可以用此方法取消光标闪烁
    $(&#39;input&#39;).triggerHandler(&#39;focus&#39;, function () {
      $(this).val(&#39;你好吗&#39;)
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h4 id="4-3-6-event">4.3.6 事件对象: event</h4>
<ol>
<li><p><code>$(&quot;element&quot;).on( events,[selector],fn(event){...})</code>：使用方法与原生JS相同</p>
<pre class="prettyprint linenums:0"><code class="lang-html">&lt;style&gt;
  div {
    width: 100px;
    height: 100px;
    background-color: pink;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  $(function () {
    $(document).on(&#39;click&#39;, function () {
      console.log(&#39;点击了document&#39;)
    })
    $(&#39;div&#39;).on(&#39;click&#39;, function (event) {
      console.log(&#39;点击了div&#39;)
      event.stopPropagation()
    })
  })
&lt;/script&gt;
</code></pre>
</li>
</ol>
<h4 id="4-3-7-extend">4.3.7 对象拷贝: extend</h4>
<ol>
<li><p>语法：<code>.extend([deep],target,object1,[objectN])</code></p>
</li>
<li><p>参数：</p>
<p>1）deep：可选，默认false浅拷贝，true深拷贝</p>
<ul>
<li>浅拷贝：把原来对象里面的复杂数据类型地址拷贝给目标对象，修改目标对象也会同时修改原对象</li>
<li>深拷贝：把里面的数据完全复制一份给目标对象，如果里面有不冲突的属性会合并到一起 </li>
</ul>
<p>2）target：要拷贝的目标对象</p>
<p>3）object1：待拷贝到第一个对象的对象</p>
<pre class="prettyprint linenums:0"><code class="lang-js">var targetObj = {
  id: 0,
  msg: {
    sex: &#39;男&#39;,
  },
}
var obj = {
  id: 1,
  name: &#39;andy&#39;,
  msg: {
    age: 18,
  },
}
// 1. 浅拷贝把原来对象里面的复杂数据类型地址拷贝给目标对象
$.extend(targetObj, obj)
console.log(targetObj)     // 覆盖targetObj：{id: 1, msg: {age: 18}, name: &#39;andy&#39;}
targetObj.msg.age = 20
console.log(targetObj)     // {id: 1, msg: {age: 20}, name: &#39;andy&#39;}
console.log(obj)         // 跟随targetObj变化：{id: 1, msg: {age: 20}, name: &#39;andy&#39;}

// 2. 深拷贝把里面的数据完全复制一份给目标对象，如果里面有不冲突的属性，会合并到一起
$.extend(true, targetObj, obj)
console.log(targetObj)     // 覆盖targetObj：{id: 1, msg: {age: 18}, name: &#39;andy&#39;}
targetObj.msg.age = 20
console.log(targetObj)     // {id: 1, msg: {sex: &#39;男&#39;, age: 20}, name: &#39;andy&#39;}
console.log(obj)         // 不跟随targetObj变化：{id: 1, msg: {age: 18}, name: &#39;andy&#39;}
</code></pre>
</li>
</ol>
<hr>
<h3 id="4-4-jquery-">4.4 jQuery插件</h3>
<ol>
<li><p>网站：</p>
<p>1）jQuery插件库：<a href="www.jq22.com">www.jq22.com</a></p>
<p>2）jQuery之家：<a href="www.htmleaf.com">www.htmleaf.com</a></p>
</li>
<li><p>瀑布流插件：<a href="http://www.htmleaf.com/jQuery/pubuliuchajian">http://www.htmleaf.com/jQuery/pubuliuchajian</a></p>
</li>
<li><p>图片懒加载：<a href="https://www.jq22.com/jquery-info11629">https://www.jq22.com/jquery-info11629</a></p>
<p>1）作用：页面滑动到可视区域再显示图片</p>
<p>2）注意：此插件需要写到DOM元素的最后面</p>
</li>
<li><p>全屏滚动：<a href="github.com/alvarotrigo/fullPage.js">github.com/alvarotrigo/fullPage.js</a></p>
</li>
<li>Bootstrap插件：<a href="https://v3.bootcss.com/javascript/">https://v3.bootcss.com/javascript/</a></li>
</ol>
<hr>
<h2 id="-5-ajax">第5章 Ajax</h2>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>


<SCRIPT type="text/javascript" >
// <!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
    setTimeout(function(){
    	$('#tree').ztree_toc(conf);
    },500)
});
//-->
</SCRIPT>