<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Jason的Vue笔记</title>
    <link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css" />
    <link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css" />
    <link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css" />
    <style>
      pre {
        counter-reset: line-numbering;
        border: solid 1px #d9d9d9;
        border-radius: 0;
        background: #fff;
        padding: 0;
        line-height: 23px;
        margin-bottom: 30px;
        white-space: pre;
        overflow-x: auto;
        word-break: inherit;
        word-wrap: inherit;
      }

      pre a::before {
        content: counter(line-numbering);
        counter-increment: line-numbering;
        padding-right: 1em; /* space after numbers */
        width: 25px;
        text-align: right;
        opacity: 0.7;
        display: inline-block;
        color: #aaa;
        background: #eee;
        margin-right: 16px;
        padding: 2px 10px;
        font-size: 13px;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      pre a:first-of-type::before {
        padding-top: 10px;
      }

      pre a:last-of-type::before {
        padding-bottom: 10px;
      }

      pre a:only-of-type::before {
        padding: 10px;
      }

      .highlight {
        background-color: #ffffcc;
      } /* RIGHT */
    </style>
  </head>
  <body>
    <div>
      <div style="width: 25%">
        <ul id="tree" class="ztree" style="width: 100%"></ul>
      </div>
      <div id="readme" style="width: 70%; margin-left: 20%">
        <article class="markdown-body">
          <h1 id="vue">Vue</h1>
          <h2 id="-1-vue-">第1章 Vue基本用法</h2>
          <h3 id="1-1-">1.1 基础理论</h3>
          <h4 id="1-1-1-mvvm-">1.1.1 MVVM模型</h4>
          <ol>
            <li>M：模型(Model) ：data中的数据</li>
            <li>V：视图(View) ：模板代码，vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用</li>
            <li>VM：视图模型(ViewModel)：Vue实例，data中所有的属性，最后都出现在了vm身上</li>
          </ol>
          <h4 id="1-1-2-vue-">1.1.2 Vue重要原则</h4>
          <ol>
            <li><p>被Vue管理的函数，最好写成普通函数（不要写成箭头函数），这样this的指向才是 vm 或 组件实例对象</p></li>
            <li><p>不被Vue所管理的函数（定时器、ajax、Promise等），最好写成箭头函数，这样this的指向才是 vm 或 组件实例对象</p></li>
            <li>
              <p>在Vue-CLI中，如果出现import语句，程序默认先执行import语句，而将import中间的代码后置执行</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// test1.js
console.log(&#39;test1&#39;)

// test2.js
console.log(&#39;test2&#39;)

// index.js
import &#39;/.test1&#39;
console.log(100)
console.log(200)
import &#39;./test2&#39;

// 执行结果
&#39;test1&#39;
&#39;test2&#39;
&#39;100&#39;
&#39;200&#39;
</code></pre>
            </li>
          </ol>
          <h4 id="1-1-3-vue-">1.1.3 Vue基本结构</h4>
          <ol>
            <li>
              <p>引入Vue：<code>&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>准备容器：<code>&lt;div id=&quot;root&quot;&gt;</code></p>
            </li>
            <li>
              <p>阻止提示：<code>Vue.config.productionTip = false</code></p>
            </li>
            <li>
              <p>创建实例：</p>
              <p>1）el（element缩写）：指定当前Vue实例为哪个容器服务</p>
              <ul>
                <li>写法1：<code>el: &#39;#root&#39;</code></li>
                <li>写法2：<code>const v = new Vue(...), v.$mount(&#39;#root&#39;)</code></li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-js">//el的两种写法
const v = new Vue({
    el:&#39;#root&#39;, // 第一种写法
    data:{
        name:&#39;尚硅谷&#39;
    }
})

v.$mount(&#39;#root&#39;) // 第二种写法
</code></pre>
              <p>2）data：存储数据，数据供el所指定的容器去使用</p>
              <ul>
                <li>写法1：对象型：<code>data: { name:&#39;尚硅谷&#39; }</code></li>
                <li>写法2：函数型（脚手架必用）：<code>data() { return { name:&#39;尚硅谷&#39;, }}</code></li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-js">//data的两种写法
new Vue({
  el: &#39;#root&#39;,
  // 第一种写法：对象式
  data:{
        name:&#39;尚硅谷&#39;
    }
  // 第二种写法：函数式
  data() {
    console.log(&#39;@@@&#39;, this) //此处的this是Vue实例对象
    return {
      name: &#39;尚硅谷&#39;,
    }
  },
})
</code></pre>
            </li>
            <li>
              <p>完整的HTML单页写法：</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- 引入vue.js --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;!-- 准备好一个容器 --&gt;
&lt;div id=&quot;demo&quot;&gt;
  &lt;h1&gt;Hello，{{name.toUpperCase()}}，{{address}}&lt;/h1&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
  //创建Vue实例
  new Vue({
    el: &#39;#demo&#39;, //el（element缩写）用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。
    data: {
      //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。
      name: &#39;atguigu&#39;,
      address: &#39;北京&#39;,
    },
  })
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-1-4-">1.1.4 模板语法</h4>
          <ol>
            <li><p>插值语法：<code>{{xxx}}</code>，用于解析标签体内容，里面要写js表达式</p></li>
            <li>
              <p>指令语法：用于解析标签（包括：标签属性、标签体内容、绑定事件等）</p>
              <ul>
                <li>语法：<code>v-bind</code>、<code>v-model</code>、<code>v-for</code>、<code>v-text</code>等等</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h1&gt;插值语法&lt;/h1&gt;
  &lt;h3&gt;你好，{{name}}&lt;/h3&gt;
  &lt;hr /&gt;
  &lt;h1&gt;指令语法&lt;/h1&gt;
  &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去{{school.name}}学习1&lt;/a&gt;
  &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去{{school.name}}学习2&lt;/a&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;jack&#39;,
    school: {
      name: &#39;尚硅谷&#39;,
      url: &#39;http://www.atguigu.com&#39;,
    },
  },
})
</code></pre>
            </li>
            <li>
              <p>注意：js表达式和js语句的区别</p>
              <p>1）js表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">a
a+b
demo(1)
x === y ? &#39;a&#39; : &#39;b&#39;
</code></pre>
              <p>2）js语句：<code>if(){}</code>、<code>for(){}</code></p>
            </li>
          </ol>
          <hr />
          <h3 id="1-2-">1.2 数据绑定与代理</h3>
          <h4 id="1-2-1-v-bind-model">1.2.1 数据绑定 v-bind/model</h4>
          <ol>
            <li>
              <p>单向绑定(<code>v-bind</code>)：数据只能从data流向页面</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;text&quot; :value=&quot;name&quot; /&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
  },
})
</code></pre>
            </li>
            <li>
              <p>双向绑定(<code>v-model</code>)：数据不仅能从data流向页面，还可以从页面流向data</p>
              <p>1）一般都应用在表单类元素上（如：input、select等）</p>
              <p>2）<code>v-model:value</code> 可以简写为 v-model，因为v-model默认收集的就是value值</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt;
</code></pre>
              <p>3）注意：v-model绑定的值不能是<code>props</code>传过来的值，因为<code>props</code>是不可以修改的！</p>
            </li>
            <li>
              <p><code>v-model</code>的三个修饰符：</p>
              <p>1）<code>lazy</code>：失去焦点再收集数据，适合用于文本框textarea</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;
</code></pre>
              <p>2）<code>number</code>：输入字符串转为有效的数字</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot; /&gt;
</code></pre>
              <p>3）<code>trim</code>：输入首尾空格过滤</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot; /&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-2-2-">1.2.2 数据代理</h4>
          <h5 id="1-2-2-1-js-">1.2.2.1 原JS的数据代理</h5>
          <ol>
            <li>
              <p>语法：<code>Object.defineProperty (obj, prop, descriptor )</code></p>
            </li>
            <li>
              <p>descriptor说明：以对象的形式书写，对于obj初始时内部定义的属性，descriptor中后三项默认都是true</p>
              <p>1）<code>value</code>：设置属性值，默认为undefined</p>
              <p>2）<code>writable</code>: 布尔值，值是否可以重写，默认为false</p>
              <p>3）<code>enumerable</code>: 布尔值，目标属性是否可以被枚举，默认为 false，即Object.keys()是否可以遍历出该属性</p>
              <p>4）<code>configurable</code>：布尔值，目标属性是否可以被删除或是否可以再次修改特性，默认为false</p>
            </li>
            <li>
              <p><code>get函数(getter)</code>：当有人读取对象的新增属性时，get函数(getter)就会被调用，且返回值就是新增属性的值</p>
            </li>
            <li>
              <p><code>set函数(setter)</code>：当有人修改对象的新增属性时，set函数(setter)就会被调用，且会收到修改的具体值</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">let number = 18
let person = {
  name: &#39;张三&#39;,
  sex: &#39;男&#39;,
}
Object.defineProperty(person, &#39;age&#39;, {
  get() {
    console.log(&#39;有人读取age属性了&#39;)
    return number
  },
  // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
  set(value) {
    console.log(&#39;有人修改了age属性，且值是&#39;, value)
    number = value
  },
})
</code></pre>
            </li>
          </ol>
          <h5 id="1-2-2-2-vue-">1.2.2.2 Vue的数据代理</h5>
          <ol>
            <li><p>目的：通过vm对象来代理data对象中属性的操作（读/写）</p></li>
            <li>
              <p>原理：</p>
              <p>1）通过<code>Object.defineProperty()</code>把data对象中所有属性添加到<code>vm</code>上</p>
              <p>2）为每一个添加到vm上的属性，都指定一个getter/setter</p>
              <p>3）在getter/setter内部去操作（读/写）data中对应的属性</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
  &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
    address: &#39;宏福科技园&#39;,
  },
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="1-3-methods">1.3 事件处理 methods</h3>
          <h4 id="1-3-1-v-on-">1.3.1 基本用法 v-on/@</h4>
          <ol>
            <li>
              <p>语法：</p>
              <p>1）HTML标签：用<code>v-on:xxx</code> 或 <code>@xxx</code> 绑定事件，其中xxx是事件名</p>
              <p>2）Vue实例：配置在methods对象中，最终会在vm上</p>
            </li>
            <li>
              <p>注意：</p>
              <p>1）methods中配置的函数，不要用箭头函数！否则this就不是vm了</p>
              <p>2）methods中配置的函数，都是被Vue所管理的函数，this 的指向是vm 或 组件实例对象</p>
              <p>3）<code>@click=&quot;demo&quot;</code> 和 <code>@click=&quot;demo($event)&quot;</code> 效果一致，但后者可以传参</p>
            </li>
            <li>
              <p>事件对象：<code>$event</code></p>
              <p>1）等同于原生JS函数参数中的<code>event</code></p>
              <p>2）常用：<code>e.target.value</code>，取input输入框中的值</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;body&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt;
    &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt;
    &lt;button @click=&quot;showInfo1&quot;&gt;点我提示信息1（不传参）&lt;/button&gt;
    &lt;!-- 如果需要传参，可以用$event保留函数中的event对象 --&gt;
    &lt;button @click=&quot;showInfo2($event,66)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示
  const vm = new Vue({
    el: &#39;#root&#39;,
    data: {
      name: &#39;尚硅谷&#39;,
    },
    // 固定写法：methods
    methods: {
      showInfo1(event) {
        // console.log(event.target.innerText)
        // console.log(this) //此处的this是vm
        alert(&#39;同学你好！&#39;)
      },
      showInfo2(event, number) {
        console.log(event, number)
        // console.log(event.target.innerText)
        // console.log(this) //此处的this是vm
        alert(&#39;同学你好！！&#39;)
      },
    },
  })
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-3-2-">1.3.2 事件修饰符</h4>
          <ol>
            <li>
              <p><code>prevent</code>：阻止默认事件（常用）</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
  },
  methods: {
    showInfo(e) {
      alert(&#39;同学你好！&#39;)
      // console.log(e.target)
    },
    showMsg(msg) {
      console.log(msg)
    },
    demo() {
      for (let i = 0; i &lt; 100000; i++) {
        console.log(&#39;#&#39;)
      }
      console.log(&#39;累坏了&#39;)
    },
  },
})
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;
</code></pre>
            </li>
            <li>
              <p><code>stop</code>：阻止事件冒泡（常用）</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;
  &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
  &lt;!-- 修饰符可以连续写 --&gt;
  &lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;
&lt;/div&gt;
</code></pre>
            </li>
            <li>
              <p><code>once</code>：事件只触发一次（常用）</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
</code></pre>
            </li>
            <li>
              <p><code>capture</code>：使用事件的捕获模式</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;
  div1
  &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;div2&lt;/div&gt;
&lt;/div&gt;
</code></pre>
            </li>
            <li>
              <p><code>self</code>：只有event.target是当前操作的元素时才触发事件（与阻止冒泡stop相同）</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
  &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
&lt;/div&gt;
</code></pre>
            </li>
            <li>
              <p><code>passive</code>：事件的默认行为立即执行，无需等待事件回调执行完毕</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- 事件：scroll：滚动条，鼠标和键盘都可以操作；wheel：只有鼠标滚轮才能操作 --&gt;
&lt;!-- 效果：如果不加passive，会等待demo函数计算完毕后，滚动条才会移动，加上passive可以不用等demo计算完，滚动条便可以移动 --&gt;
&lt;!-- 注意：也并非所有动作都收到passive的影响，scroll不加passive也一样优先被滚动 --&gt;
&lt;!-- &lt;ul @wheel=&quot;demo&quot; class=&quot;list&quot;&gt; --&gt;
&lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-3-3-">1.3.3 键盘事件</h4>
          <ol>
            <li>
              <p>按键别名：</p>
              <p>1）回车 =&gt; <code>enter</code></p>
              <p>2）删除 =&gt; <code>delete</code> (捕获“删除”和“退格”键)</p>
              <p>3）退出 =&gt; <code>esc</code></p>
              <p>4）空格 =&gt; <code>space</code></p>
              <p>5）换行 =&gt; <code>tab</code> (特殊，必须配合keydown去使用)</p>
              <p>6）上 =&gt; <code>up</code></p>
              <p>7）下 =&gt; <code>down</code></p>
              <p>8）左 =&gt; <code>left</code></p>
              <p>9）右 =&gt; <code>right</code></p>
            </li>
            <li>
              <p>未提供别名的按键:</p>
              <p>1）方法1：用按键原始的key值去绑定，但要转为kebab-case，例：CapsLock要写成<code>caps-lock</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;text&quot; placeholder=&quot;按下CapsLock提示输入&quot; @keydown.caps-lock=&quot;showInfo&quot; /&gt;
</code></pre>
              <p>2）方法2：<code>Vue.config.keyCodes.自定义键名 = 键码</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.keyCodes.huiche = 13
</code></pre>
              <p>3）废除方法：使用键码指定按键，如 @keydown.13</p>
            </li>
            <li>
              <p>系统修饰键：</p>
              <p>1）按键：ctrl、alt、shift、meta</p>
              <p>2）配合<code>keyup</code>：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- 系统修饰键盘如果配合keyup使用，可以在后面加一个按键，指定需要同时按下的键，如果不指定，配合任何按键同时按下均可 --&gt;
&lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.ctrl.y=&quot;showInfo&quot; /&gt;
</code></pre>
              <p>3）配合<code>keydown</code>：正常触发事件</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot; /&gt;
</code></pre>
            </li>
            <li>
              <p>案例完整代码：</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot; /&gt;
  &lt;!-- 系统修饰键盘如果配合keyup使用，可以在后面加一个按键，指定需要同时按下的键，如果不指定，配合任何按键同时按下均可 --&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keyup.ctrl.y=&quot;showInfo&quot; /&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
Vue.config.keyCodes.huiche = 13 //定义了一个别名按键
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
  },
  methods: {
    showInfo(e) {
      // e.key：按键名称；e.keyCode：按键编码
      // console.log(e.key, e.keyCode)
      console.log(e.target.value)
    },
  },
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="1-4-computed">1.4 计算属性 computed</h3>
          <ol>
            <li><p>定义：要用的属性不存在，要通过已有属性计算得来</p></li>
            <li>
              <p>与method区别：</p>
              <p>1）内部有缓存机制（复用），效率更高、调试方便</p>
              <p>2）如果多次调用，无需多次get，直接读取缓存，除非数据发生了变化，再重新get一次</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- method实现 --&gt;
&lt;div id=&quot;root&quot;&gt;
  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  全名：&lt;span&gt;{{fullName()}}&lt;/span&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  Vue.config.productionTip = false
  new Vue({
    el: &#39;#root&#39;,
    data: {
      firstName: &#39;张&#39;,
      lastName: &#39;三&#39;,
    },
    methods: {
      // 只要vue中的数据发生改变，就会重新调用该函数，重新解析模板
      fullName() {
        console.log(&#39;@---fullName&#39;)
        return this.firstName + &#39;-&#39; + this.lastName
      },
    },
  })
&lt;/script&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- computed实现 --&gt;
&lt;div id=&quot;root&quot;&gt;
  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  Vue.config.productionTip = false
  const vm = new Vue({
    el: &#39;#root&#39;,
    data: {
      firstName: &#39;张&#39;,
      lastName: &#39;三&#39;,
      x: &#39;你好&#39;,
    },
    methods: {
      demo() {},
    },
    // 计算属性
    computed: {
      fullName: {
        // get作用：当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
        // get调用：1.初次读取fullName时。2.所依赖的数据发生变化时。
        get() {
          console.log(&#39;get被调用了&#39;)
          // console.log(this) //此处的this是vm
          return this.firstName + &#39;-&#39; + this.lastName
        },
        // set调用：当fullName被修改时
        // set不是必须要写的，除非存在fullName有被修改的需求
        set(value) {
          console.log(&#39;set&#39;, value)
          const arr = value.split(&#39;-&#39;)
          this.firstName = arr[0]
          this.lastName = arr[1]
        },
      },
    },
  })
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>原理：底层借助了<code>Objcet.defineproperty</code>方法提供的<code>getter</code>和<code>setter</code></p>
              <ul>
                <li>get函数执行时间：初次读取时会执行一次，当依赖的数据发生改变时会被再次调用</li>
              </ul>
            </li>
            <li>
              <p>注意：</p>
              <p>1）计算属性最终会出现在vm上，直接读取使用即可</p>
              <p>2）如果计算属性要被修改，必须写<code>set</code>函数去响应修改，且<code>set</code>中要引起计算时依赖的数据发生改变</p>
              <p>3）允许套娃：在计算属性中下方定义的属性可以利用上方定义的属性进行计算</p>
            </li>
            <li>
              <p>简写：只写<code>get</code>，但只读不改</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">computed: {
  //完整写法
  fullName: {
    get() {
      console.log(&#39;get被调用了&#39;)
      return this.firstName + &#39;-&#39; + this.lastName
    },
    set(value) {
      console.log(&#39;set&#39;, value)
      const arr = value.split(&#39;-&#39;)
      this.firstName = arr[0]
      this.lastName = arr[1]
    },
  },
},
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">computed: {
  //简写（只读不改）
  fullName() {
    console.log(&#39;get被调用了&#39;)
    return this.firstName + &#39;-&#39; + this.lastName
  },
},
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="1-5-watch">1.5 监视属性 watch</h3>
          <ol>
            <li><p>定义：当被监视的属性变化时, 回调函数自动调用, 进行相关操作（监视的属性必须存在，才能进行监视！）</p></li>
            <li>
              <p>写法：</p>
              <p>1）new Vue时传入watch配置</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    isHot: true,
  },
  computed: {
    info() {
      return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
    },
  },
  methods: {
    changeWeather() {
      this.isHot = !this.isHot
    },
  },
  // 监视属性
  watch: {
    isHot: {
      immediate: true,
      handler(newValue, oldValue) {
        console.log(&#39;isHot被修改了&#39;, newValue, oldValue)
      },
    },
  },
})
// 必须创建实例才能用
vm.$watch(&#39;isHot&#39;, {
  immediate: true, //初始化时让handler调用一下
  //handler什么时候调用？当isHot发生改变时。
  handler(newValue, oldValue) {
    console.log(&#39;isHot被修改了&#39;, newValue, oldValue)
  },
})
</code></pre>
              <p>2）通过vm.$watch监视</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    isHot: true,
  },
  computed: {
    info() {
      return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
    },
  },
  methods: {
    changeWeather() {
      this.isHot = !this.isHot
    },
  },
// 监视属性
vm.$watch(&#39;isHot&#39;, {
  immediate: true,
  handler(newValue, oldValue) {
    console.log(&#39;isHot被修改了&#39;, newValue, oldValue)
  },
})
</code></pre>
            </li>
            <li>
              <p>参数：</p>
              <p>1）<code>immediate</code>：布尔值，默认false，初始化时是否让handler调用一下</p>
              <p>2）<code>handler(newValue,oldValue){...}</code>：回调函数，当监视的属性改变时被调用</p>
              <p>3）<code>deep</code>: true，深度监视模式，注意：如果不用deep，也可以单写 obj.attr，但很麻烦</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
  &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
  &lt;hr /&gt;
  &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt;
  &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;
  &lt;h3&gt;b的值是:{{numbers.b}}&lt;/h3&gt;
  &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;
  &lt;button @click=&quot;numbers = {a:666,b:888}&quot;&gt;彻底替换掉numbers&lt;/button&gt;
  {{numbers.c.d.e}}
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    isHot: true,
    numbers: {
      a: 1,
      b: 1,
      c: {
        d: {
          e: 100,
        },
      },
    },
  },
  computed: {
    info() {
      return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
    },
  },
  methods: {
    changeWeather() {
      this.isHot = !this.isHot
    },
  },
  watch: {
    isHot: {
      handler(newValue, oldValue) {
        console.log(&#39;isHot被修改了&#39;, newValue, oldValue)
      },
    },
    // 监视多级结构中某个属性的变化（勿忘外面加引号，这样写太麻烦）
    /* &#39;numbers.a&#39;:{
            handler(){
                console.log(&#39;a被改变了&#39;)
            }
        } */
    // 监视多级结构中所有属性的变化
    numbers: {
      deep: true,
      handler() {
        console.log(&#39;numbers改变了&#39;)
      },
    },
  },
})
</code></pre>
            </li>
            <li>
              <p>简写：<code>attibute(newValue, oldValue){...}</code>，注意：无法配置<code>immediate</code>、<code>deep</code>等参数</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 写法1
watch: {
  isHot(newValue,oldValue){
    console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)
  }
},

// 写法2
vm.$watch(&#39;isHot&#39;,(newValue,oldValue)=&gt;{
    console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)
})
</code></pre>
            </li>
            <li>
              <p>与computed区别：</p>
              <p>1）computed能完成的功能，watch都可以完成</p>
              <p>2）watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
  全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    firstName: &#39;张&#39;,
    lastName: &#39;三&#39;,
    fullName: &#39;张-三&#39;,
  },
  watch: {
    // 监视firstName
    firstName(val) {
      // 改变姓时，延迟一秒再改变全名，这个用compute无法实现
      // 这里定时器之所以可用箭头函数，因为定时器不是vue管理的，而是js引擎调用的
      setTimeout(() =&gt; {
        console.log(this) // 必须使用箭头函数，this才能指向vue，否则指向windows了
        this.fullName = val + &#39;-&#39; + this.lastName
      }, 1000)
    },
    // 监视lastName
    lastName(val) {
      this.fullName = this.firstName + &#39;-&#39; + val
    },
  },
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="1-6-">1.6 绑定样式</h3>
          <h4 id="1-6-1-class-">1.6.1 class样式</h4>
          <ol>
            <li>
              <p>字符串写法：<code>:class=&quot;mood&quot;</code>，类名不确定，要动态获取</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;{{name}}&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// vue
methods: {
  changeMood() {
    const arr = [&#39;happy&#39;, &#39;sad&#39;, &#39;normal&#39;]
    const index = Math.floor(Math.random() * 3)
    this.mood = arr[index]
  },
},
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-css">/* css */
.happy {
  border: 4px solid red;
  background-color: rgba(255, 255, 0, 0.644);
  background: linear-gradient(30deg, yellow, pink, orange, yellow);
}

.sad {
  border: 4px dashed rgb(2, 197, 2);
  background-color: gray;
}

.normal {
  background-color: skyblue;
}
</code></pre>
            </li>
            <li>
              <p>数组写法：<code>:class=&quot;classArr&quot;</code>，要绑定多个样式，个数不确定，名字也不确定</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;{{name}}&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">data: {
  classArr: [&#39;atguigu1&#39;, &#39;atguigu2&#39;, &#39;atguigu3&#39;],
},
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-css">.atguigu1 {
  background-color: yellowgreen;
}
.atguigu2 {
  font-size: 30px;
  text-shadow: 2px 2px 10px red;
}
.atguigu3 {
  border-radius: 20px;
}
</code></pre>
            </li>
            <li>
              <p>对象写法：<code>:class=&quot;classObj&quot;</code>，要绑定多个样式，个数确定，名字也确定，但不确定用不用</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;{{name}}&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">data: {
  classObj: {
    atguigu1: false,
    atguigu2: false,
    atguigu3: true,
  },
},
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-css">.atguigu1 {
  background-color: yellowgreen;
}
.atguigu2 {
  font-size: 30px;
  text-shadow: 2px 2px 10px red;
}
.atguigu3 {
  border-radius: 20px;
}
</code></pre>
            </li>
          </ol>
          <h4 id="1-6-2-style-">1.6.2 style样式</h4>
          <ol>
            <li>
              <p>对象写法：<code>:style=&quot;styleObj&quot;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;{{name}}&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">data: {
  styleObj: {
    fontSize: &#39;40px&#39;,
    color: &#39;red&#39;,
  },
},
</code></pre>
            </li>
            <li>
              <p>数组写法：<code>:style=&quot;styleArr&quot;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--等同于：&lt;div class=&quot;basic&quot; :style=&quot;[styleObj,styleObj2]&quot;&gt;{{name}}&lt;/div&gt;）--&gt;
&lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;{{name}}&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">data: {
  styleArr: [
    {
      fontSize: &#39;40px&#39;,
      color: &#39;red&#39;,
    },
    {
      backgroundColor: &#39;orange&#39;,
    },
  ],
},
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="1-7-v-if-show">1.7 条件渲染 v-if/show</h3>
          <h4 id="1-7-1-v-if">1.7.1 v-if</h4>
          <blockquote>
            <p>v-if 适用：切换频率较低的场景，不展示的DOM元素直接被移除</p>
          </blockquote>
          <ol>
            <li>
              <p>写法：</p>
              <p>1）<code>v-if=&quot;表达式&quot;</code></p>
              <p>2）<code>v-else-if=&quot;表达式&quot;</code></p>
              <p>3）<code>v-else=&quot;表达式&quot;</code></p>
            </li>
            <li>
              <p>注意：v-if 可以和 v-else-if、v-else一起使用，但要求结构不能被“打断”</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
    n: 0,
  },
})
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt;
&lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;!-- 使用v-if做条件渲染(不展示的DOM元素直接被移除) --&gt;
&lt;h2 v-if=&quot;false&quot;&gt;欢迎来到{{name}}，DOM元素已经被移除&lt;/h2&gt;
&lt;h2 v-if=&quot;1 === 1&quot;&gt;欢迎来到{{name}}&lt;/h2&gt;
&lt;div v-if=&quot;n === 1&quot;&gt;Angular&lt;/div&gt;
&lt;!-- v-else和v-else-if --&gt;
&lt;div v-else-if=&quot;n === 2&quot;&gt;React&lt;/div&gt;
&lt;div v-else-if=&quot;n === 3&quot;&gt;Vue&lt;/div&gt;
&lt;div v-else&gt;超出范围了……&lt;/div&gt;
&lt;!-- template只能与v-if配合使用 --&gt;
&lt;template v-if=&quot;n === 1&quot;&gt;
  &lt;h2&gt;你好&lt;/h2&gt;
  &lt;h2&gt;尚硅谷&lt;/h2&gt;
  &lt;h2&gt;北京&lt;/h2&gt;
&lt;/template&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-7-2-v-show">1.7.2 v-show</h4>
          <blockquote>
            <p>v-show 适用：切换频率较高的场景，不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
          </blockquote>
          <ol>
            <li>
              <p>写法：<code>v-show=&quot;表达式&quot;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
    n: 0,
  },
})
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt;
&lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;h2 v-show=&quot;false&quot;&gt;欢迎来到{{name}}，但是用样式隐藏了&lt;/h2&gt;
&lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到{{name}}，你能看见这条&lt;/h2&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="1-8-v-for">1.8 列表渲染 v-for</h3>
          <h4 id="1-8-1-v-for">1.8.1 v-for</h4>
          <blockquote>
            <p>v-for 作用：展示列表数据</p>
          </blockquote>
          <ol>
            <li>
              <p>语法：<code>v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</code></p>
              <p>1）key：将每个数据绑定唯一标识</p>
              <p>2）index：默认生成的索引值，从0开始</p>
            </li>
            <li>
              <p>可遍历：</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">new Vue({
  el: &#39;#root&#39;,
  data: {
    persons: [
      { id: &#39;001&#39;, name: &#39;张三&#39;, age: 18 },
      { id: &#39;002&#39;, name: &#39;李四&#39;, age: 19 },
      { id: &#39;003&#39;, name: &#39;王五&#39;, age: 20 },
    ],
    car: {
      name: &#39;奥迪A8&#39;,
      price: &#39;70万&#39;,
      color: &#39;黑色&#39;,
    },
    str: &#39;hello&#39;,
  },
})
</code></pre>
              <p>1）数组</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul&gt;
    &lt;!-- key的意思是将每个数据绑定唯一标识，绑定的内容保证每项都是不同的即可 --&gt;
    &lt;!-- index是默认生成的索引值，从0开始 --&gt;
    &lt;li v-for=&quot;(item, index) of persons&quot; :key=&quot;index&quot;&gt;
        {{item.name}}-{{item.age}}-{{index}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
              <p>2）对象</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul&gt;
    &lt;li v-for=&quot;(value, key) of car&quot; :key=&quot;key&quot;&gt;
        {{key}}-{{value}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
              <p>3）字符串</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul&gt;
    &lt;li v-for=&quot;(char, index) of str&quot; :key=&quot;index&quot;&gt;
        {{char}}-{{index}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
              <p>4）指定次数</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;ul&gt;
    &lt;li v-for=&quot;(number, index) of 5&quot; :key=&quot;index&quot;&gt;
        {{index}}-{{number}}
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-8-2-key-">1.8.2 key的内部原理</h4>
          <ol>
            <li><p>虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较</p></li>
            <li>
              <p>对比规则：</p>
              <p>1）旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
              <ul>
                <li>若虚拟DOM中内容没变, 直接使用之前的真实DOM</li>
                <li>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</li>
              </ul>
              <p>2）旧虚拟DOM中未找到与新虚拟DOM相同的key：创建新的真实DOM，随后渲染到到页面</p>
            </li>
            <li>
              <p>用index作为key可能会引发的问题：</p>
              <p>1）对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低</p>
              <p>2）如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题</p>
            </li>
            <li>
              <p>开发中如何选择key：</p>
              <p>1）最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值</p>
              <p>2）如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，可使用index作为key</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;!-- 遍历数组 --&gt;
  &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;
  &lt;button @click.once=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt;
  &lt;ul&gt;
    &lt;!-- key在DOM中看不到，因为被Vue内部使用了 --&gt;

    &lt;!-- 错误写法：这样会导致新增用户后面的输入框内容不随数据移动 --&gt;
    &lt;!-- &lt;li v-for=&quot;(p, index) of persons&quot; :key=&quot;index&quot;&gt; --&gt;

    &lt;!-- 正确写法：每条数据单独对应的id可以保证输入框的key跟随数据移动 --&gt;
    &lt;li v-for=&quot;(p, index) of persons&quot; :key=&quot;p.id&quot;&gt;
      {{p.name}}-{{p.age}}
      &lt;input type=&quot;text&quot; /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
  Vue.config.productionTip = false
  new Vue({
    el: &#39;#root&#39;,
    data: {
      persons: [
        { id: &#39;001&#39;, name: &#39;张三&#39;, age: 18 },
        { id: &#39;002&#39;, name: &#39;李四&#39;, age: 19 },
        { id: &#39;003&#39;, name: &#39;王五&#39;, age: 20 },
      ],
    },
    methods: {
      add() {
        const p = { id: &#39;004&#39;, name: &#39;老刘&#39;, age: 40 }
        // unshift：插入数组最前面
        this.persons.unshift(p)
      },
    },
  })
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-8-3-filter">1.8.3 列表过滤 filter</h4>
          <ol>
            <li>
              <p>语法：<code>arr.filter(callback(element[,index[,array]]))</code>，返回一个新数组，不会改变原数组</p>
              <p>1）callback：用来测试数组的每个元素的函数；返回 true 表示该元素通过测试，保留该元素，false 则不保留</p>
              <p>2）element：数组中当前正在处理的元素</p>
              <p>3）index(可选)：正在处理的元素在数组中的索引</p>
              <p>4）array(可选)：调用了 filter 的数组本身</p>
            </li>
            <li>
              <p>案例：按名称筛选人员列表</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of filPerons&quot; :key=&quot;index&quot;&gt;
            {{p.name}}-{{p.age}}-{{p.sex}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
              <p>1）用watch实现：<code>handler(val) ==&gt; indexOf(val)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">new Vue({
    el:&#39;#root&#39;,
    data:{
        keyWord:&#39;&#39;,
        persons:[
            {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
            {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
            {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
            {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;}
        ],
        filPerons:[]
    },
    watch:{
        keyWord:{
            immediate:true,
            handler(val){
                this.filPerons = this.persons.filter((p)=&gt;{
                    // 注意：所有字符串中都包含空字符串&#39;&#39;，且索引值在第0位
                    return p.name.indexOf(val) !== -1
                })
            }
        }
    }
})
</code></pre>
              <p>2）用computed实现：<code>indexOf(this.keyword)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">new Vue({
    el:&#39;#root&#39;,
    data:{
        keyWord:&#39;&#39;,
        persons:[
            {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
            {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
            {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
            {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;}
        ]
    },
    computed:{
        filPerons(){
            return this.persons.filter((p)=&gt;{
                // 注意：所有字符串中都包含空字符串&#39;&#39;，且索引值在第0位
                return p.name.indexOf(this.keyWord) !== -1
            })
        }
    }
}) 
</code></pre>
            </li>
          </ol>
          <h4 id="1-8-4-sort">1.8.4 列表排序 sort</h4>
          <ol>
            <li>
              <p>语法：<code>arr.sort((firstItem, secondItem) =&gt; firstItem.attr - secondItem.attr)</code></p>
            </li>
            <li>
              <p>如果是带筛选功能，一定要先筛选，再排序</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
    &lt;button @click=&quot;sortType = 2&quot;&gt;年龄升序&lt;/button&gt;
    &lt;button @click=&quot;sortType = 1&quot;&gt;年龄降序&lt;/button&gt;
    &lt;button @click=&quot;sortType = 0&quot;&gt;原顺序&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of filPerons&quot; :key=&quot;p.id&quot;&gt;
            {{p.name}}-{{p.age}}-{{p.sex}}
            &lt;input type=&quot;text&quot;&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false
    new Vue({
        el:&#39;#root&#39;,
        data:{
            keyWord:&#39;&#39;,
            sortType:0, //0:原顺序 1:降序 2:升序
            persons:[
                {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:30,sex:&#39;女&#39;},
                {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:31,sex:&#39;女&#39;},
                {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:18,sex:&#39;男&#39;},
                {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:19,sex:&#39;男&#39;}
            ]
        },
        computed:{
            filPerons(){
                // 注意：先筛选，后排序，必须对筛选后的结果进行排序，所以不能直接返回结果，而要把筛选后结果暂存在arr里
                const arr = this.persons.filter((p)=&gt;{
                    return p.name.indexOf(this.keyWord) !== -1
                })
                //判断一下是否需要排序
                if(this.sortType){
                    // p1, p2 代表：firstItem, secondItem
                    arr.sort((p1,p2)=&gt;{
                        return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age
                    })
                }
                return arr
            }
        }
    }) 
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="1-8-5-set">1.8.5 列表更新 $set</h4>
          <ol>
            <li>
              <p>修改Obj格式的数据</p>
              <p>1）用索引修改数组中的对象的属性，Vue可以识别，例：<code>this.persons[0].name = &#39;马老师&#39;</code></p>
              <p>2）直接修改其中一整条对象数据会导致DOM被修改但Vue不渲染页面</p>
              <ul>
                <li>
                  <p>无效方法：用索引直接修改</p>
                  <pre class="prettyprint linenums:0"><code class="lang-js">this.persons[0] = {id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;}
</code></pre>
                </li>
                <li>
                  <p>解决方案：splice</p>
                  <pre class="prettyprint linenums:0"><code class="lang-js">this.persons.splice(0,1,{id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;})
</code></pre>
                </li>
              </ul>
              <p>3）完整案例代码</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;p.id&quot;&gt;
            {{p.name}}-{{p.age}}-{{p.sex}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
    el:&#39;#root&#39;,
    data:{
        persons:[
            {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:30,sex:&#39;女&#39;},
            {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:31,sex:&#39;女&#39;},
            {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:18,sex:&#39;男&#39;},
            {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:19,sex:&#39;男&#39;}
        ]
    },
    methods: {
        updateMei(){
            // 方法1：用索引修改数组中的对象的属性
            // this.persons[0].name = &#39;马老师&#39; //奏效
            // this.persons[0].age = 50 //奏效
            // this.persons[0].sex = &#39;男&#39; //奏效

            // 无效方法：用索引直接修改一整条对象
            // this.persons[0] = {id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;} 

            // 方法2：splice
            this.persons.splice(0,1,{id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;})
        }
    }
}) 
</code></pre>
            </li>
            <li>
              <p>修改Arr格式的数据</p>
              <p>1）用索引值的方法替换数组值，Vue不会识别</p>
              <p>2）解决方案1：<code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p>
              <p>3）解决方案2：<code>vm.$set(arr, index, value)</code></p>
            </li>
            <li>
              <p>使用<code>$set</code>更新数据</p>
              <p>1）方法1：<code>this.$set(target, propertyName/index, value)</code></p>
              <p>2）方法2：<code>Vue.set(target, propertyName/index, value)</code>，不能给 vm 或 vm._data 添加属性，只能给vm的data中的某一个对象添加属性</p>
              <p>3）方法3：<code>vm.$set(target, propertyName/index, value)</code>，不能给 vm 或 vm._data 添加属性，只能给vm的data中的某一个对象添加属性</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h1&gt;学生信息&lt;/h1&gt;
  &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br /&gt;
  &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br /&gt;
  &lt;button @click=&quot;student.sex = &#39;未知&#39; &quot;&gt;修改性别&lt;/button&gt; &lt;br /&gt;
  &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br /&gt;
  &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br /&gt;
  &lt;button @click.once=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br /&gt;
  &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br /&gt;
  &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br /&gt;
  &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt;
  &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt;
  &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：{{student.sex}}&lt;/h3&gt;
  &lt;h3&gt;爱好：&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;{{h}}&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h3&gt;朋友们：&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;{{f.name}}--{{f.age}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    student: {
      name: &#39;tom&#39;,
      age: 18,
      hobby: [&#39;抽烟&#39;, &#39;喝酒&#39;, &#39;烫头&#39;],
      friends: [
        { name: &#39;jerry&#39;, age: 35 },
        { name: &#39;tony&#39;, age: 36 },
      ],
    },
  },
  methods: {
    addSex() {
      // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
      this.$set(this.student, &#39;sex&#39;, &#39;男&#39;)
    },
    addFriend() {
      this.student.friends.unshift({ name: &#39;jack&#39;, age: 70 })
    },
    updateFirstFriendName() {
      // 用索引值的方法替换数组值，Vue不会识别，但如果用索引修改数组中的对象的属性，Vue可以识别
      this.student.friends[0].name = &#39;张三&#39;
    },
    addHobby() {
      this.student.hobby.push(&#39;学习&#39;)
    },
    updateHobby() {
      // this.student.hobby.splice(0,1,&#39;开车&#39;)
      // Vue.set(this.student.hobby,0,&#39;开车&#39;)
      this.$set(this.student.hobby, 0, &#39;开车&#39;)
    },
    removeSmoke() {
      this.student.hobby = this.student.hobby.filter((h) =&gt; {
        return h !== &#39;抽烟&#39;
      })
    },
  },
})
</code></pre>
            </li>
          </ol>
          <h3 id="1-9-">1.9 表单数据</h3>
          <h4 id="1-9-1-input-">1.9.1 input输入框</h4>
          <ol>
            <li>
              <p><code>&lt;input type=&quot;text&quot;/&gt;</code>：v-model收集的是value值，用户输入的就是value值</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot; /&gt;
</code></pre>
            </li>
            <li>
              <p><code>&lt;input type=&quot;radio&quot;/&gt;</code>：v-model收集的是value值，且要给标签配置value值</p>
              <pre
                class="prettyprint linenums:0"
              ><code class="lang-html">性别： 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot; /&gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot; /&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// vue
sex: &#39;female&#39;,
</code></pre>
            </li>
            <li>
              <p><code>&lt;input type=&quot;checkbox&quot;/&gt;</code>：</p>
              <p>1）没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
              <p>2）配置了input的value属性：</p>
              <ul>
                <li>
                  <p>v-model的初始值是数组，那么收集的的就是value组成的数组</p>
                  <pre
                    class="prettyprint linenums:0"
                  ><code class="lang-html">爱好： 学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot; /&gt; 打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot; /&gt; 吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot; /&gt;
</code></pre>
                  <pre class="prettyprint linenums:0"><code class="lang-js">// vue
hobby: [], // 如果是多选框checkbox，要配合数组，否则一勾全勾上了
</code></pre>
                </li>
                <li>
                  <p>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
                  <pre class="prettyprint linenums:0"><code class="lang-html">&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot; /&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt;
</code></pre>
                  <pre class="prettyprint linenums:0"><code class="lang-js">// vue
agree: &#39;&#39;, // 如果是单选框checkbox，不用配合数组，只收集true、false
</code></pre>
                </li>
              </ul>
            </li>
          </ol>
          <h4 id="1-9-2-select-">1.9.2 select下拉框</h4>
          <ol>
            <li>
              <p>与<code>option</code>选项搭配：</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;select v-model=&quot;userInfo.city&quot;&gt;
  &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
  &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
  &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
  &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;
  &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;
&lt;/select&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// Vue
city: &#39;beijing&#39;,
</code></pre>
            </li>
            <li>
              <p>案例完整代码</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;form @submit.prevent=&quot;demo&quot;&gt;
    &lt;!--收集的是value值，不用配value，因为用户输入的就是value值--&gt;
    账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
    密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
    年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
    &lt;!--收集的是value值，要配value值--&gt;
    性别： 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot; /&gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
    &lt;!--配置了value属性，v-model初始值是数组，收集的是数组--&gt;
    爱好： 学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot; /&gt; 打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot; /&gt; 吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.
hobby&quot; value=&quot;eat&quot; /&gt; &lt;br /&gt;&lt;br /&gt;
    所属校区
    &lt;select v-model=&quot;userInfo.city&quot;&gt;
      &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
      &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
      &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
      &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;
      &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;
    &lt;/select&gt;
    &lt;br /&gt;&lt;br /&gt;
    其他信息：
    &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br /&gt;&lt;br /&gt;
    &lt;!--没有配置value属性，收集的是checked布尔值--&gt;
    &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot; /&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt;
    &lt;button&gt;提交&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    userInfo: {
      account: &#39;&#39;,
      password: &#39;&#39;,
      age: 18,
      sex: &#39;female&#39;,
      hobby: [], // 如果是多选框checkbox，要配合数组，否则一勾全勾上了
      city: &#39;beijing&#39;,
      other: &#39;&#39;,
      agree: &#39;&#39;, // 如果是单选框checkbox，不用配合数组，只收集true、false
    },
  },
  methods: {
    demo() {
      console.log(JSON.stringify(this.userInfo))
    },
  },
})
</code></pre>
            </li>
          </ol>
          <h3 id="1-10-vue-filter">1.10 过滤器 Vue.filter</h3>
          <blockquote>
            <p>对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理），并没有改变原本的数据, 是产生新的对应的数据</p>
          </blockquote>
          <h4 id="1-10-1-">1.10.1 注册过滤器</h4>
          <ol>
            <li>
              <p>全局过滤器：<code>Vue.filter(name,callback)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.filter(&#39;mySlice&#39;, function (value) {
  return value.slice(0, 4)
})
</code></pre>
            </li>
            <li>
              <p>局部过滤器：<code>new Vue{filters:{...}}</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">filters: {
  timeFormater(value, str = &#39;YYYY年MM月DD日 HH:mm:ss&#39;) {
    return dayjs(value).format(str)
  },
},
</code></pre>
            </li>
          </ol>
          <h4 id="1-10-2-">1.10.2 使用过滤器</h4>
          <ol>
            <li>
              <p><code>{{ xxx | 过滤器名}}</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root2&quot;&gt;
  &lt;h2&gt;{{msg | mySlice}}&lt;/h2&gt;
&lt;/div&gt;
&lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt;
</code></pre>
            </li>
            <li>
              <p><code>v-bind:属性 = &quot;xxx | 过滤器名&quot;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h3 :x=&quot;msg | mySlice&quot;&gt;尚硅谷&lt;/h3&gt;
</code></pre>
            </li>
            <li>
              <p>过滤器也可以接收额外参数、多个过滤器也可以串联</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h3&gt;现在是：{{time | timeFormater(&#39;YYYY_MM_DD&#39;) | mySlice}}&lt;/h3&gt;
</code></pre>
            </li>
            <li>
              <p>完整案例代码</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;
  &lt;!-- 计算属性实现 --&gt;
  &lt;h3&gt;现在是：{{fmtTime}}&lt;/h3&gt;
  &lt;!-- methods实现 --&gt;
  &lt;h3&gt;现在是：{{getFmtTime()}}&lt;/h3&gt;
  &lt;!-- 过滤器实现 --&gt;
  &lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt;
  &lt;!-- 过滤器实现（传参） --&gt;
  &lt;!-- 多个过滤器可以并联 --&gt;
  &lt;h3&gt;现在是：{{time | timeFormater(&#39;YYYY_MM_DD&#39;) | mySlice}}&lt;/h3&gt;
  &lt;!-- 给标签动态绑定属性，例：绑定属性x，值为&#39;你好，尚&#39; --&gt;
  &lt;h3 :x=&quot;msg | mySlice&quot;&gt;尚硅谷&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&quot;root2&quot;&gt;
  &lt;h2&gt;{{msg | mySlice}}&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
//全局过滤器
Vue.filter(&#39;mySlice&#39;, function (value) {
  return value.slice(0, 4)
})
// root1
new Vue({
  el: &#39;#root&#39;,
  data: {
    time: 1621561377603, //时间戳
    msg: &#39;你好，尚硅谷&#39;,
  },
  computed: {
    fmtTime() {
      return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)
    },
  },
  methods: {
    getFmtTime() {
      return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)
    },
  },
  //局部过滤器
  filters: {
    timeFormater(value, str = &#39;YYYY年MM月DD日 HH:mm:ss&#39;) {
      // console.log(&#39;@&#39;,value)
      return dayjs(value).format(str)
    },
  },
})
// root2
new Vue({
  el: &#39;#root2&#39;,
  data: {
    msg: &#39;hello,atguigu!&#39;,
  },
})
</code></pre>
            </li>
          </ol>
          <h3 id="1-11-v-xxx">1.11 内置指令 v-xxx</h3>
          <h4 id="1-11-1-">1.11.1 基础指令</h4>
          <ol>
            <li>v-bind: 单向绑定解析表达式，可简写为: xxx</li>
            <li>v-model: 双向数据绑定</li>
            <li>v-for: 遍历数组/对象/字符串</li>
            <li>v-on: 绑定事件监听，可简写为@</li>
            <li>v-if: 条件渲染（动态控制节点是否存存在）</li>
            <li>v-else: 条件渲染（动态控制节点是否存存在）</li>
            <li>v-show: 条件渲染(动态控制节点是否展示)</li>
          </ol>
          <h4 id="1-11-2-v-text">1.11.2 v-text</h4>
          <ol>
            <li><p>作用：向其所在的节点中渲染文本内容</p></li>
            <li><p>区别：v-text会替换掉节点中的内容，{{xxx}}则不会</p></li>
            <li>
              <p>注意：文字中的html标签不会被解析，而是直接显示</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;div&gt;你好，{{name}}&lt;/div&gt;
  &lt;div v-text=&quot;name&quot;&gt;我被替换了&lt;/div&gt;
  &lt;div v-text=&quot;str&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
    str: &#39;&lt;h3&gt;你好啊！&lt;/h3&gt;&#39;, // 这里&lt;h3&gt;不会被当成html标签解析，而是直接显示出来
  },
})
</code></pre>
            </li>
          </ol>
          <h4 id="1-11-3-v-html">1.11.3 v-html</h4>
          <ol>
            <li><p>作用：向指定节点中渲染包含html结构的内容</p></li>
            <li>
              <p>区别：</p>
              <p>1）v-html会替换掉节点中所有的内容，{{xxx}}则不会</p>
              <p>2）v-html可以识别html结构</p>
            </li>
            <li>
              <p>注意：</p>
              <p>1）v-html有安全性问题</p>
              <p>2）在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击</p>
              <p>3）一定要在可信的内容上使用v-html，永不要用在用户提交的内容上</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;div&gt;你好，{{name}}&lt;/div&gt;
  &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;
  &lt;div v-html=&quot;str2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
    str: &#39;&lt;h3&gt;你好啊！&lt;/h3&gt;&#39;,
    // 可用 document.cookie 获取当前网站的 cookie，但如果标记了 HttpOnly 则无法读取
    str2: &#39;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;&#39;,
  },
})
</code></pre>
            </li>
          </ol>
          <h4 id="1-11-4-v-cloak">1.11.4 v-cloak</h4>
          <ol>
            <li><p>定义：本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性</p></li>
            <li><p>作用：使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题</p></li>
            <li>
              <p>效果：如果需要vue加载的资源速度很慢，可以加上此属性，等vue加载完成后再显示，不然直接显示模板符号很丑</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8080/resource/5s/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">console.log(1)
Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
  },
})
</code></pre>
            </li>
          </ol>
          <h4 id="1-11-5-v-once">1.11.5 v-once</h4>
          <ol>
            <li><p>定义：v-once所在节点在初次动态渲染后，就视为静态内容了</p></li>
            <li>
              <p>作用：以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2 v-once&gt;初始化的n值是:{{n}}&lt;/h2&gt;
  &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt;
  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js"> Vue.config.productionTip = false
 new Vue({
   el: &#39;#root&#39;,
   data: {
     n: 1,
   },
 })
</code></pre>
            </li>
          </ol>
          <h4 id="1-11-6-v-pre">1.11.6 v-pre</h4>
          <ol>
            <li><p>定义：跳过其所在节点的编译过程</p></li>
            <li>
              <p>作用：没有使用指令语法、没有使用插值语法的节点，会加快编译</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt;
  &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt;
  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    n: 1,
  },
})
</code></pre>
            </li>
          </ol>
          <h3 id="1-12-directives">1.12 自定义指令 directives</h3>
          <ol>
            <li>
              <p>局部指令：</p>
              <p>1）<code>new Vue({directives:{指令名: 回调函数}})</code></p>
              <p>2）<code>new Vue({directives:{指令名: 配置对象}})</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2&gt;{{name}}&lt;/h2&gt;
  &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
  &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; --&gt;
  &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
  &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
  &lt;hr /&gt;
  &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot; /&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    name: &#39;尚硅谷&#39;,
    n: 1,
  },
  // 自定义指令：局部指令
  directives: {
    big(element, binding) {
      console.log(&#39;big&#39;, this) //注意此处的this是window
      element.innerText = binding.value * 10
    },

    // 对象式
    fbind: {
      //指令与元素成功绑定时（一上来）
      bind(element, binding) {
        element.value = binding.value
      },
      //指令所在元素被插入页面时
      inserted(element, binding) {
        element.focus()
      },
      //指令所在的模板被重新解析时
      update(element, binding) {
        element.value = binding.value
      },
    },
  },
})
</code></pre>
            </li>
            <li>
              <p>全局指令：</p>
              <p>1）<code>Vue.directive(指令名, 回调函数)</code></p>
              <p>2）<code>Vue.directive(指令名, 配置对象)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//定义全局指令
Vue.directive(&#39;big&#39;, function (element, binding) {
  console.log(&#39;big&#39;, this)
  element.innerText = binding.value * 10
})

Vue.directive(&#39;fbind&#39;, {
  //指令与元素成功绑定时（一上来）
  bind(element, binding) {
    element.value = binding.value
  },
  //指令所在元素被插入页面时
  inserted(element, binding) {
    element.focus()
  },
  //指令所在的模板被重新解析时
  update(element, binding) {
    element.value = binding.value
  },
})
</code></pre>
            </li>
            <li>
              <p>回调：</p>
              <p>1）<code>bind</code>：指令与元素成功绑定时调用</p>
              <p>2）<code>inserted</code>：指令所在元素被插入页面时调用</p>
              <p>3）<code>update</code>：指令所在模板结构被重新解析时调用</p>
              <p>4）参数：</p>
              <ul>
                <li><code>element</code>：指令所在的DOM元素</li>
                <li><code>binding</code>：绑定对象，内部包含很多属性，最重要的是value，代表自定义方法绑定的值</li>
              </ul>
            </li>
            <li>
              <p>注意：</p>
              <p>1）指令定义时不加<code>v-</code>，但使用时要加<code>v-</code></p>
              <p>2）指令名如果是多个单词，要使用<code>kebab-case</code>命名方式，不要用camelCase命名，且要加单引号</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">&#39;big-number&#39;(element,binding){
    element.innerText = binding.value * 10
},
</code></pre>
            </li>
          </ol>
          <h3 id="1-13-">1.13 生命周期函数</h3>
          <blockquote>
            <p>生命周期回调函数、生命周期函数、生命周期钩子，Vue在关键时刻调用的一些特殊名称的函数。</p>
          </blockquote>
          <p><img src="./src/生命周期.png" alt="生命周期" /></p>
          <ol>
            <li>
              <p><code>beforeCreate()</code>：无法通过vm访问到data数据、method中的方法</p>
            </li>
            <li>
              <p><code>created()</code>：可以通过vm访问到data数据、method中的方法</p>
            </li>
            <li>
              <p><code>beforeMounted()</code>：页面呈现的是未经Vue编译的DOM结构，所有对DOM的操作都不奏效</p>
            </li>
            <li>
              <p><code>mounted()</code>：Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted</p>
              <p>1）等价写法：<code>vm.$mount(&#39;#root&#39;)</code></p>
              <p>2）页面呈现经过Vue编译的DOM，对DOM的操作有效</p>
              <p>3）适用：开启定时器、发送ajax请求、订阅消息、绑定自定义事件</p>
            </li>
            <li>
              <p><code>beforeUpdate()</code>：此时数据是新的，但页面是旧的，页面尚未与数据保持一致</p>
            </li>
            <li>
              <p><code>updated()</code>：此时数据、页面都是新的，两者保持同步</p>
            </li>
            <li>
              <p><code>beforeDestroy()</code>：vm中所有的data、methods、指令等都处于可用状态，马上要执行销毁过程</p>
              <p>1）适用：关闭定时器、取消订阅消息、解绑自定义事件</p>
              <p>2）注意：此时不要调用method中的方法了</p>
            </li>
            <li>
              <p><code>destroyed()</code>：销毁后借助Vue开发者工具看不到任何信息</p>
              <p>1）等价写法：vm.$destroy()</p>
              <p>2）销毁后自定义事件会失效，但原生DOM事件依然有效</p>
              <p>3）一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了</p>
            </li>
            <li>
              <p>注意：</p>
              <p>1）生命周期函数中的this指向是 vm 或 组件实例对象vc</p>
              <p>2）生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot; :x=&quot;n&quot;&gt;
  &lt;!-- 这里面的内容也可以用template生成，但是会忽略上面的div中的所有属性，改成template里写的属性 --&gt;
  &lt;h2 v-text=&quot;n&quot;&gt;&lt;/h2&gt;
  &lt;h2&gt;当前的n值是：{{n}}&lt;/h2&gt;
  &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;
  &lt;button @click=&quot;bye&quot;&gt;点我销毁vm&lt;/button&gt;
  &lt;hr /&gt;
  &lt;img src=&quot;./src/生命周期.png&quot; height=&quot;1000px&quot; /&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
new Vue({
  el: &#39;#root&#39;,
  // template: `
  //     &lt;div id=&quot;root&quot; :x=&quot;n&quot;&gt;
  //         &lt;h2&gt;当前的n值是：{{n}}&lt;/h2&gt;
  //         &lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;
  //         &lt;button @click=&quot;bye&quot;&gt;点我销毁vm&lt;/button&gt;
  //     &lt;/div&gt;
  // `,
  data: {
    n: 1,
  },
  methods: {
    add() {
      console.log(&#39;add&#39;)
      this.n++
    },
    bye() {
      console.log(&#39;bye&#39;)
      this.$destroy()
    },
  },
  watch: {
    n() {
      console.log(&#39;n变了&#39;)
    },
  },
  // 创建流程 -------------------------------
  beforeCreate() {
    console.log(&#39;beforeCreate&#39;)
  },
  created() {
    console.log(&#39;created&#39;)
  },
  // 挂载流程 -------------------------------
  beforeMount() {
    console.log(&#39;beforeMount&#39;)
    // console.log(this) // 指向Vue
    // debugger // 打断点，需要打开控制台后刷新才能卡断点
  },
  mounted() {
    // 等价写法：vm.$mount(&#39;#root&#39;)
    console.log(&#39;mounted&#39;, this.$el instanceof HTMLElement) // 判断此时是不是真是的DOM元素
  },
  // 更新流程 -------------------------------
  beforeUpdate() {
    console.log(&#39;beforeUpdate&#39;)
  },
  updated() {
    console.log(&#39;updated&#39;)
  },
  // 销毁流程 -------------------------------
  beforeDestroy() {
    console.log(&#39;beforeDestroy&#39;)
    // 在这里不要调用methods中的方法了
  },
  destroyed() {
    // 等价写法：vm.$destroy()
    console.log(&#39;destroyed&#39;)
  },
})
</code></pre>
            </li>
            <li>
              <p>技巧：可以在生命周期函数中写debugger用于打断点，需要打开控制台后刷新生效</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">beforeMount() {
  console.log(&#39;beforeMount&#39;)
  // console.log(this) // 指向Vue
  debugger // 打断点，需要打开控制台后刷新才能卡断点
},
</code></pre>
            </li>
            <li>
              <p>演示案例</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h2 :style=&quot;{opacity}&quot;&gt;欢迎学习Vue&lt;/h2&gt;
  &lt;button @click=&quot;opacity = 1&quot;&gt;透明度设置为1&lt;/button&gt;
  &lt;button @click=&quot;stop&quot;&gt;点我停止变换&lt;/button&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
new Vue({
  el: &#39;#root&#39;,
  data: {
    opacity: 1,
  },
  methods: {
    stop() {
      this.$destroy()
    },
  },
  //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted
  mounted() {
    console.log(&#39;mounted&#39;, this)
    this.timer = setInterval(() =&gt; {
      console.log(&#39;setInterval&#39;)
      this.opacity -= 0.01
      if (this.opacity &lt;= 0) this.opacity = 1
    }, 16)
  },
  beforeDestroy() {
    clearInterval(this.timer)
    console.log(&#39;vm即将驾鹤西游了&#39;)
  },
})
</code></pre>
            </li>
          </ol>
          <h3 id="1-14-vuecomponent">1.14 组件 VueComponent</h3>
          <h4 id="1-14-1-">1.14.1 非单文件组件</h4>
          <h5 id="1-14-1-1-">1.14.1.1 定义组件(创建组件)</h5>
          <ol>
            <li>
              <p>语法：</p>
              <p>1）完整版：<code>const 组件名 = Vue.extend(options)</code></p>
              <p>2）简写版：<code>const 组件名 = options</code></p>
            </li>
            <li>
              <p>参数：</p>
              <p>1）<code>el</code>：不写，最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器</p>
              <p>2）<code>data</code>：必须写成函数，避免组件被复用时，数据存在引用关系</p>
            </li>
            <li>
              <p>组件命名规则：</p>
              <p>1）一个单词：</p>
              <ul>
                <li>第一种写法(首字母小写)：school</li>
                <li>第二种写法(首字母大写)：School</li>
              </ul>
              <p>2）多个单词：</p>
              <ul>
                <li>第一种写法(<code>kebab-case</code>命名)：my-school</li>
                <li>第二种写法(<code>CamelCase</code>命名)：MySchool (需要Vue脚手架支持)</li>
              </ul>
              <p>3）注意：</p>
              <ul>
                <li>组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行</li>
                <li>可以使用name配置项指定组件在开发者工具中呈现的名字</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;h1&gt;{{msg}}&lt;/h1&gt;
  &lt;school&gt;&lt;/school&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 定义组件：完整写法
const s = Vue.extend({
   name: &#39;atguigu&#39;, // 如果定义了name，在Vue开发工具里面就永远叫这个名字，但页面标签不是这个名
   template: `
     &lt;div&gt;
        &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
     &lt;/div&gt;
`,
   data() {
     return {
       name: &#39;尚硅谷&#39;,
       address: &#39;北京&#39;,
     }
   },
 })

new Vue({
  el: &#39;#root&#39;,
  data: {
    msg: &#39;欢迎学习Vue!&#39;,
  },
  components: {
    // 定义组件绑定的标签名称
    school: s, // 这步Vue会自动绑定Vue.extend(options)
  },
})
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 定义组件：简写形式
const s = {
  name: &#39;atguigu&#39;, // 如果定义了name，在Vue开发工具里面就永远叫这个名字，但页面标签不是这个名
  template: `
    &lt;div&gt;
       &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
       &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
    &lt;/div&gt;
`,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京&#39;,
    }
  },
}

new Vue({
  el: &#39;#root&#39;,
  data: {
    msg: &#39;欢迎学习Vue!&#39;,
  },
  components: {
    // 定义组件绑定的标签名称
    school: s, // 这步Vue会自动绑定Vue.extend(options)
  },
})
</code></pre>
            </li>
          </ol>
          <h5 id="1-14-1-2-">1.14.1.2 注册组件</h5>
          <ol>
            <li><p>局部注册：new Vue时传入components选项</p></li>
            <li>
              <p>全局注册：<code>Vue.component(&#39;组件名&#39;,组件)</code></p>
            </li>
            <li>
              <p>注意：可以分别指定标签和组件名称，<code>components: { 标签名：组件名 }</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;hello&gt;&lt;/hello&gt;
  &lt;hr /&gt;
  &lt;h1&gt;{{msg}}&lt;/h1&gt;
  &lt;hr /&gt;
  &lt;!-- 编写组件标签 --&gt;
  &lt;school&gt;&lt;/school&gt;
  &lt;hr /&gt;
  &lt;!-- 编写组件标签 --&gt;
  &lt;student&gt;&lt;/student&gt;
&lt;/div&gt;
&lt;div id=&quot;root2&quot;&gt;
  &lt;hello&gt;&lt;/hello&gt;
  &lt;!-- 由于student组件是在root中局部注册的，在root2中无效 --&gt;
  &lt;student&gt;&lt;/student&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 创建student组件
const student = Vue.extend({
  template: `
        &lt;div&gt;
            &lt;h2&gt;学生姓名：{{studentName}}&lt;/h2&gt;
            &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
        &lt;/div&gt;
    `,
  data() {
    return {
      studentName: &#39;张三&#39;,
      age: 18,
    }
  },
})
// 创建hello组件
const hello = Vue.extend({
  template: `
        &lt;div&gt;    
            &lt;h2&gt;你好啊！{{name}}&lt;/h2&gt;
        &lt;/div&gt;
    `,
  data() {
    return {
      name: &#39;Tom&#39;,
    }
  },
})

// 全局注册组件
Vue.component(&#39;hello&#39;, hello)

// 创建vm
new Vue({
  el: &#39;#root&#39;,
  data: {
    msg: &#39;你好啊！&#39;,
  },
  // 局部注册组件
  components: {
    school,
    student,
  },
})
new Vue({
  el: &#39;#root2&#39;,
})
</code></pre>
            </li>
          </ol>
          <h5 id="1-14-1-3-">1.14.1.3 使用组件(写组件标签)</h5>
          <ol>
            <li>写法1：<code>&lt;school&gt;&lt;/school&gt;</code></li>
            <li>写法2：<code>&lt;school/&gt;</code>，但不用使用脚手架时，<code>&lt;school/&gt;</code>会导致后续组件不能渲染</li>
          </ol>
          <h5 id="1-14-1-4-">1.14.1.4 组件嵌套</h5>
          <ul>
            <li>
              <p>可以在下一个组件定义时使用已经定义好的组件</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
// 定义student组件
const student = Vue.extend({
  name: &#39;student&#39;,
  template: `
        &lt;div&gt;
            &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;    
            &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;    
        &lt;/div&gt;
    `,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      age: 18,
    }
  },
})

//定义school组件
const school = Vue.extend({
  name: &#39;school&#39;,
  template: `
        &lt;div&gt;
            &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;    
            &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;    
            &lt;student&gt;&lt;/student&gt;
        &lt;/div&gt;
    `,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京&#39;,
    }
  },
  // 注册组件（局部）：由于在template中使用了student，必须注册
  components: {
    student,
  },
})

//定义hello组件
const hello = Vue.extend({
  template: `&lt;h1&gt;{{msg}}&lt;/h1&gt;`,
  data() {
    return {
      msg: &#39;欢迎来到尚硅谷学习！&#39;,
    }
  },
})

//定义app组件
const app = Vue.extend({
  template: `
        &lt;div&gt;    
            &lt;hello&gt;&lt;/hello&gt;
            &lt;school&gt;&lt;/school&gt;
        &lt;/div&gt;
    `,
  // 注册组件（局部）：由于在template中使用了student、hello，必须注册
  components: {
    school,
    hello,
  },
})

// 创建vm
new Vue({
  template: &#39;&lt;app&gt;&lt;/app&gt;&#39;,
  el: &#39;#root&#39;,
  // 注册组件（局部）：由于嵌套组件已经相互在内部注册，直接注册最终的app即可
  components: { app },
})
</code></pre>
            </li>
          </ul>
          <h5 id="1-14-1-5-">1.14.1.5 组件的本质</h5>
          <ol>
            <li><p>组件本质是一个名为<code>VueComponent</code>的构造函数，且不是程序员定义的，是<code>Vue.extend</code>生成的</p></li>
            <li>
              <p>只需要写组件标签，Vue解析时会帮我们创建school组件的实例对象：<code>new VueComponent(options)</code></p>
            </li>
            <li>
              <p>每次调用<code>Vue.extend</code>，返回的都是一个全新的<code>VueComponent</code></p>
            </li>
            <li>
              <p>this指向（data函数、methods中的函数、watch中的函数、computed中的函数）</p>
              <p>1）组件配置：指向<code>VueComponent</code>实例对象<code>vc</code></p>
              <p>2）<code>new Vue(options)</code>配置：指向Vue实例对象<code>vm</code></p>
            </li>
            <li>
              <p>内置关系：<code>VueComponent.prototype.__proto__</code> === <code>Vue.prototype</code></p>
              <ul>
                <li>作用：让组件实例对象 vc 可以访问到 Vue原型上的属性、方法</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;div id=&quot;root&quot;&gt;
  &lt;school&gt;&lt;/school&gt;
&lt;/div&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">Vue.config.productionTip = false
// 在Vue上定义x属性
Vue.prototype.x = 99
//定义school组件
const school = Vue.extend({
  name: &#39;school&#39;,
  template: `
        &lt;div&gt;
            &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;    
            &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;    
            &lt;button @click=&quot;showX&quot;&gt;点我输出x&lt;/button&gt;
        &lt;/div&gt;
    `,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京&#39;,
    }
  },
  methods: {
    showX() {
      // 访问x属性
      console.log(this.x)
    },
  },
})
//创建一个vm
const vm = new Vue({
  el: &#39;#root&#39;,
  data: {
    msg: &#39;你好&#39;,
  },
  components: { school },
})
</code></pre>
            </li>
          </ol>
          <h4 id="1-14-2-">1.14.2 单文件组件</h4>
          <h5 id="1-14-2-1-">1.14.2.1 组件结构</h5>
          <ol>
            <li>HTML标签：<code>&lt;template&gt;&lt;/template&gt;</code></li>
            <li>Vue.js代码：<code>&lt;script&gt; export default {...} &lt;/script&gt;</code></li>
            <li>CSS样式：<code>&lt;style&gt;&lt;/style&gt;</code></li>
          </ol>
          <h5 id="1-14-2-2-">1.14.2.2 整体结构</h5>
          <ol>
            <li>
              <p>组件：</p>
              <p>1）School.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;h2&gt;学校名称：{{ name }}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{ address }}&lt;/h2&gt;
    &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;School&#39;, // Vue开发者工具中显示的名称，最好和文件名保持一致
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京昌平&#39;,
    }
  },
  methods: {
    showName() {
      alert(this.name)
    },
  },
}
&lt;/script&gt;

&lt;style&gt;
.demo {
  background-color: orange;
}
&lt;/style&gt;
</code></pre>
              <p>2）Student.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
     export default {
        name:&#39;Student&#39;,
        data(){
            return {
                name:&#39;张三&#39;,
                age:18
            }
        }
    }
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>入口：</p>
              <p>1）App.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;School&gt;&lt;/School&gt;
    &lt;Student&gt;&lt;/Student&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//引入组件
import School from &#39;./School.vue&#39;
import Student from &#39;./Student.vue&#39;

export default {
  name: &#39;App&#39;,
  components: {
    School,
    Student
  }
}
&lt;/script&gt;
</code></pre>
              <p>2）main.js</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import App from &#39;./App.vue&#39;    // 浏览器不支持此语法，需要搭建cil脚手架

new Vue({
  el: &#39;#root&#39;,
  template: `&lt;App&gt;&lt;/App&gt;`,
  components: { App },
})
</code></pre>
              <p>3）index.html：不能直接运行，这是因为浏览器不支持main.js的模块化语法，需要搭建脚手架执行</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;练习一下单文件组件的语法&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 准备一个容器 --&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h2 id="-2-vue-cli">第2章 Vue-CLI</h2>
          <h3 id="2-0-">2.0 项目上线流程</h3>
          <h4 id="-">文件结构</h4>
          <ol>
            <li>
              <p><code>src/</code>文件夹：存放最主要的前端文件</p>
              <p>1）<code>components/</code>文件夹：存放一般组件，包含<code>各组件.vue</code></p>
              <p>2）<code>store/</code>文件夹：Vuex，包含<code>index.js</code>、<code>各组件.js</code></p>
              <p>3）<code>router/</code>文件夹：vue路由配置，包含<code>index.js</code></p>
              <p>4）<code>pages/</code>文件夹：存放路由组件，包含<code>各组件.vue</code></p>
              <p>5）<code>assets/</code>文件夹：存放静态资源，如logo.png</p>
              <p>5）<code>App.vue</code>：父组件，对各个组件的汇总</p>
              <p>6）<code>main.js</code>：入口文件</p>
            </li>
            <li>
              <p><code>public/</code>文件夹：存放html主页及css样式文件</p>
              <p>1）<code>css/</code>文件夹：存放引入的<code>各样式.css</code></p>
              <p>2）<code>index.html</code>：主页面，在此文件中引入第三方样式，路径用&lt;%= BASE_URL %&gt;css/xxx.css</p>
              <p>3）<code>favicon.ico</code>：页签图标</p>
            </li>
            <li>
              <p><code>node_modules/</code>文件夹：存放第三方库</p>
            </li>
            <li>
              <p><code>dist/</code>文件夹：存放打包后的前端文件，复制到express服务器的static文件夹进行部署</p>
            </li>
            <li>
              <p><code>.gitignore</code>：git版本管制忽略的配置文件</p>
            </li>
            <li>
              <p><code>babel.config.js</code>：babel的配置文件（以前叫<code>.babelrc</code>），如果使用第三方UI组件库，需要根据官方说明进行配置</p>
            </li>
            <li>
              <p><code>package.json</code>：应用包配置文件</p>
            </li>
            <li>
              <p><code>package-lock.json</code>：包版本控制文件</p>
            </li>
            <li>
              <p><code>README.md</code>：应用描述文件</p>
            </li>
            <li>
              <p><code>vue.config.js</code>：脚手架配置文件，用于配置代理等</p>
            </li>
          </ol>
          <h4 id="-">前端配置</h4>
          <ol>
            <li>
              <p>创建项目：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">vue create projectName
</code></pre>
            </li>
            <li>
              <p>打包项目：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm run build
</code></pre>
            </li>
            <li><p>将生成的<code>dist</code>文件夹中的内容放入express中的<code>static</code>文件夹</p></li>
          </ol>
          <h4 id="-">后端配置</h4>
          <ol>
            <li>
              <p>项目初始化：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm init -y
</code></pre>
            </li>
            <li>
              <p>安装express服务器：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i express
</code></pre>
            </li>
            <li>
              <p>配置express服务器：<code>server.js</code>，如果使用history模式则需要用<code>connect-history-api-fallback</code>插件</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const express = require(&#39;express&#39;)
// 引入history相关插件
const history = require(&#39;connect-history-api-fallback&#39;)

const app = express()
// 全局中间件：挂载history相关插件
app.use(history())
// 托管静态资源
app.use(express.static(__dirname + &#39;/static&#39;))
// 配置GET请求等等
app.get(...)
......
// 启动服务器
app.listen(8080, (err) =&gt; {
  if(!err) console.log(&#39;服务器成功启动了!&#39;)
})
</code></pre>
            </li>
            <li><p>新建<code>static</code>文件夹，将前端打包好的<code>dis</code>t文件夹中全部内容放入其中</p></li>
            <li>
              <p>开启服务器</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">node server.js
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-1-">2.1 初始化脚手架</h3>
          <blockquote>
            <p>官网：<a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
          </blockquote>
          <h4 id="2-1-1-">2.1.1 脚手架版本</h4>
          <ol>
            <li><p>vue.js：完整版的Vue，包含核心功能+模板解析器</p></li>
            <li><p>vue.runtime.xxx.js：运行版的Vue，只包含核心功能；没有模板解析器</p></li>
            <li>
              <p>不能使用template配置项，需要使用<code>render</code>函数接收到的<code>createElement</code>函数去指定具体内容</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">render(createElement) { return createElement(APP) }
// 简写
render: h =&gt; h(APP)
</code></pre>
            </li>
          </ol>
          <h4 id="2-1-2-">2.1.2 使用步骤</h4>
          <blockquote>
            <p>查看服务器上全部可用版本：npm view 包名 versions</p>
          </blockquote>
          <ol>
            <li>
              <p>全局安装</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i @vue/cli -g
</code></pre>
            </li>
            <li>
              <p>创建项目：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">vue create projectName
</code></pre>
            </li>
            <li>
              <p>启动项目：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm run serve
</code></pre>
            </li>
            <li>
              <p>提示：vue inspect &gt; 自定义输出文件名.js，可以查看到Vue脚手架的默认配置</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">vue inspect &gt; config.js
</code></pre>
            </li>
          </ol>
          <h4 id="2-1-3-">2.1.3 项目文件结构</h4>
          <table>
            <thead>
              <tr>
                <th style="text-align: left">类别</th>
                <th style="text-align: left">文件</th>
                <th style="text-align: left">备注</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align: left">第三方库</td>
                <td style="text-align: left">node_modules/</td>
                <td style="text-align: left">第三方库</td>
              </tr>
              <tr>
                <td style="text-align: left">第三方库</td>
                <td style="text-align: left">package.json</td>
                <td style="text-align: left">应用包配置文件</td>
              </tr>
              <tr>
                <td style="text-align: left">第三方库</td>
                <td style="text-align: left">package-lock.json</td>
                <td style="text-align: left">包版本控制文件</td>
              </tr>
              <tr>
                <td style="text-align: left">public/</td>
                <td style="text-align: left">favicon.ico</td>
                <td style="text-align: left">页签图标</td>
              </tr>
              <tr>
                <td style="text-align: left">public/</td>
                <td style="text-align: left">index.html</td>
                <td style="text-align: left">主页面，在此文件中引入第三方样式，路径用&lt;%= BASE_URL %&gt;css/xxx.css</td>
              </tr>
              <tr>
                <td style="text-align: left">public/</td>
                <td style="text-align: left">其他资源文件夹</td>
                <td style="text-align: left">若想引入第三方样式，建立css文件夹，存放css文件</td>
              </tr>
              <tr>
                <td style="text-align: left">src/</td>
                <td style="text-align: left">assets/</td>
                <td style="text-align: left">存放静态资源，如logo.png</td>
              </tr>
              <tr>
                <td style="text-align: left">src/</td>
                <td style="text-align: left">components/</td>
                <td style="text-align: left">存放组件，如HelloWorld.vue</td>
              </tr>
              <tr>
                <td style="text-align: left">src/</td>
                <td style="text-align: left">App.vue</td>
                <td style="text-align: left">汇总所有组件</td>
              </tr>
              <tr>
                <td style="text-align: left">src/</td>
                <td style="text-align: left">main.js</td>
                <td style="text-align: left">入口文件</td>
              </tr>
              <tr>
                <td style="text-align: left">其他文件</td>
                <td style="text-align: left">.gitignore</td>
                <td style="text-align: left">git版本管制忽略的配置文件</td>
              </tr>
              <tr>
                <td style="text-align: left">其他文件</td>
                <td style="text-align: left">babel.config.js</td>
                <td style="text-align: left">babel的配置文件（以前叫<code>.babelrc</code>），如果使用第三方UI组件库，需要根据官方说明进行配置</td>
              </tr>
              <tr>
                <td style="text-align: left">其他文件</td>
                <td style="text-align: left">README.md</td>
                <td style="text-align: left">应用描述文件</td>
              </tr>
              <tr>
                <td style="text-align: left">其他文件</td>
                <td style="text-align: left">vue.config.js</td>
                <td style="text-align: left">脚手架配置文件，用于配置代理等</td>
              </tr>
            </tbody>
          </table>
          <ol>
            <li>
              <p>组件：src/components/School.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
    &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;School&#39;,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京昌平&#39;
    }
  },
  methods: {
    showName() {
      alert(this.name)
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
.demo {
  background-color: orange;
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>组件：src/components/Student.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Student&#39;,
  data() {
    return {
      name: &#39;张三&#39;,
      age: 18
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>汇总组件：src/App.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue"> &lt;template&gt;
  &lt;div&gt;
    &lt;img src=&quot;./assets/logo.png&quot; alt=&quot;logo&quot; /&gt;
    &lt;School&gt;&lt;/School&gt;
    &lt;Student&gt;&lt;/Student&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//引入组件
import School from &#39;./components/School&#39;
import Student from &#39;./components/Student&#39;

export default {
  name: &#39;App&#39;,
  components: {
    School,
    Student
  }
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>入口文件：src/main.js</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//引入Vue
import Vue from &#39;vue&#39;
//引入App组件，它是所有组件的父组件
import App from &#39;./App.vue&#39;
//关闭vue的生产提示
Vue.config.productionTip = false

//创建Vue实例对象vm
new Vue({
  el: &#39;#app&#39;,
  // render函数：将App组件放入容器中
  // render(createElement) {
  //   return createElement(APP)
  // },
  // 简写：h代表createElement
  render: (h) =&gt; h(App),
})
</code></pre>
            </li>
            <li>
              <p>主页面：public/index.html</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
  &lt;!-- 开启移动端的理想视口 --&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt;
  &lt;!-- 配置页签图标 --&gt;
  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot; /&gt;
  &lt;!-- 引入第三方样式 --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot; /&gt;
  &lt;!-- 配置网页标题 --&gt;
  &lt;title&gt;硅谷系统&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- 当浏览器不支持js时noscript中的元素就会被渲染 --&gt;
  &lt;noscript&gt;
    &lt;strong&gt;We&#39;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;
  &lt;/noscript&gt;
  &lt;!-- 容器 --&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;!-- built files will be auto injected --&gt;
&lt;/body&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-2-ref-">2.2 ref属性</h3>
          <ol>
            <li>
              <p>作用：相当于id，类似于<code>document.getElementById(&#39;id&#39;)</code></p>
            </li>
            <li>
              <p>使用：<code>this.$refs.refName</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- ref相当于id，类似于document.getElementById(&#39;id&#39;) --&gt;
    &lt;!-- &lt;h1 v-text=&quot;msg&quot; id=&quot;title&quot;&gt;&lt;/h1&gt; --&gt;
    &lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;
    &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt;
    &lt;School ref=&quot;sch&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
//引入School组件
import School from &#39;./components/School&#39;

export default {
  name: &#39;App&#39;,
  components: { School },
  data() {
    return {
      msg: &#39;欢迎学习Vue！&#39;
    }
  },
  methods: {
    showDOM() {
      // console.log(document.getElementById(&#39;title&#39;)) // 等价于id写法
      console.log(this.$refs.title) //真实DOM元素
      console.log(this.$refs.btn)   //真实DOM元素
      console.log(this.$refs.sch)   //School组件的实例对象（vc），这里如果用id无法获取vc
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-3-mixin">2.3 混入 mixin</h3>
          <blockquote>
            <p>作用：可以把多个组件共用的配置提取成一个混入对象</p>
          </blockquote>
          <ol>
            <li>
              <p>注意：</p>
              <p>1）如果data中的属性名与mixins中的冲突，以data中的为准</p>
              <p>2）如果mixin.js有mounted()，生命周期钩子不会冲突，全都加载一遍（先加载组件身上的）</p>
              <p>3）关于mounted()加载次数的问题：看Vue开发工具中一共有几层，就加载几遍</p>
            </li>
            <li>
              <p>创建：<code>minin.js</code>，<code>export const XXX = { data:{...}, methods:{...} }</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 分别暴露写法，引入时要用 import {hunhe,hunhe2,...} from &#39;./mixin.js&#39;
export const hunhe = {
  methods: {
    showName() {
      alert(this.name)
    },
  },
  mounted() {
    console.log(&#39;挂载minxin中的mounted！&#39;)
  },
}
export const hunhe2 = {
  data() {
    return {
      x: 100,
      y: 200,
    }
  },
}
</code></pre>
            </li>
            <li>
              <p>全局混入：<code>main.js</code>，所有vm、vc身上都有了</p>
              <p>1）导入：<code>import {xxx} from &#39;../mixin&#39;</code></p>
              <p>2）挂载：<code>Vue.mixin(xxx)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//引入Vue
import Vue from &#39;vue&#39;
//引入App
import App from &#39;./App.vue&#39;
import { hunhe, hunhe2 } from &#39;./mixin&#39;
//关闭Vue的生产提示
Vue.config.productionTip = false

// 全局混合，所有vm、vc身上都有了
Vue.mixin(hunhe)
Vue.mixin(hunhe2)

//创建vm
new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
})
</code></pre>
            </li>
            <li>
              <p>局部混入：组件.vue</p>
              <p>1）导入：<code>import {xxx} from &#39;../mixin&#39;</code></p>
              <p>2）挂载：<code>export default {..., mixins:[xxx]}</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--School.vue--&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h2 @click=&quot;showName&quot;&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//局部混入
import {hunhe,hunhe2} from &#39;../mixin&#39;

export default {
  name: &#39;School&#39;,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京&#39;,
      x: 666
      // 如果data中的属性名与mixins中的冲突，以data中的为准
    }
  },
  //挂载混入
  mixins:[hunhe,hunhe2],
  // 注意：即使mixin.js有mounted，但生命周期钩子不会冲突，全都加载一遍
  mounted() {
    console.log(&#39;这里是内部挂载！&#39;)
  }
}
&lt;/script&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--Student.vue--&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h2 @click=&quot;showName&quot;&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//局部混入
import {hunhe,hunhe2} from &#39;../mixin&#39;

export default {
  name: &#39;Student&#39;,
  data() {
    return {
      name: &#39;张三&#39;,
      sex: &#39;男&#39;
    }
  },
  //挂载混入
  mixins:[hunhe,hunhe2]
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-4-plugins">2.4 插件 plugins</h3>
          <blockquote>
            <p>作用：用于增强Vue，包含<code>install</code>方法的一个对象，<code>install</code>的第一个参数是<code>Vue</code>，第二个以后的参数是插件使用者传递的数据</p>
          </blockquote>
          <ol>
            <li>
              <p>创建 plugins.js：<code>export default { install(Vue, arg1, arg2, arg3) {...} }</code></p>
            </li>
            <li>
              <p>传入Vue后，可以在内部创建各种全局指令</p>
              <p>1）全局过滤器：<code>Vue.filter()</code></p>
              <p>2）全局指令：<code>Vue.directive()</code></p>
              <p>3）全局混入：<code>Vue.mixin()</code></p>
              <p>4）全局方法：<code>Vue.prototype.xxx</code></p>
              <ul>
                <li><code>Vue.prototype.$myMethod = function () {...}</code></li>
                <li><code>Vue.prototype.$myProperty = xxxx</code></li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-js">// plugins.js
export default {
  // 插件第一个参数默认是Vue,后面可以自定义需要传入的参数
  install(Vue, x, y, z) {
    console.log(x, y, z)
    //全局过滤器
    Vue.filter(&#39;mySlice&#39;, function(value) {
      return value.slice(0, 4)
    })
    //全局指令
    Vue.directive(&#39;fbind&#39;, {
      //指令与元素成功绑定时（一上来）
      bind(element, binding) {
        element.value = binding.value
      },
      //指令所在元素被插入页面时
      inserted(element) {
        element.focus()
      },
      //指令所在的模板被重新解析时
      update(element, binding) {
        element.value = binding.value
      },
    })
    //定义全局混入
    Vue.mixin({
      data() {
        return {
          x: 100,
          y: 200,
        }
      },
    })
    //给Vue原型上添加一个方法（vm和vc就都能用了）
    Vue.prototype.hello = () =&gt; {
      alert(&#39;你好啊&#39;)
    }
  },
}
</code></pre>
            </li>
            <li>
              <p>使用：main.js</p>
              <p>1）导入：<code>import plugins from &#39;./plugins&#39;</code></p>
              <p>2）应用：<code>Vue.use(plugins, arg1, arg2, arg3)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// main.js
// 引入Vue
import Vue from &#39;vue&#39;
// 引入App
import App from &#39;./App.vue&#39;
// 引入插件
import plugins from &#39;./plugins&#39;
// 关闭Vue的生产提示
Vue.config.productionTip = false

// 应用（使用）插件
Vue.use(plugins,1,2,3)
// 创建vm
new Vue({
    el:&#39;#app&#39;,
    render: h =&gt; h(App)
})
</code></pre>
            </li>
            <li>
              <p>剩余文件</p>
              <p>1）组件：components/School.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;!--全局过滤器--&gt;
        &lt;h2&gt;学校名称：{{name | mySlice}}&lt;/h2&gt;
        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
        &lt;!--全局方法--&gt;
        &lt;button @click=&quot;test&quot;&gt;点我测试一个hello方法&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;School&#39;,
        data() {
            return {
                name:&#39;尚硅谷atguigu&#39;,
                address:&#39;北京&#39;,
            }
        },
        methods: {
            test(){
                this.hello()
            }
        },
    }
&lt;/script&gt;
</code></pre>
              <p>2）组件：components/Student.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
        &lt;!--全局指令--&gt;
        &lt;input type=&quot;text&quot; v-fbind:value=&quot;name&quot;&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;Student&#39;,
        data() {
            return {
                name:&#39;张三&#39;,
                sex:&#39;男&#39;
            }
        },
    }
&lt;/script&gt;
</code></pre>
              <p>3）汇总组件：src/App.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;School/&gt;
        &lt;hr&gt;
        &lt;Student/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import School from &#39;./components/School&#39;
    import Student from &#39;./components/Student&#39;

    export default {
        name:&#39;App&#39;,
        components:{School,Student}
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-5-scoped-">2.5 scoped样式</h3>
          <blockquote>
            <p>作用：让样式在局部生效，防止不同组件之间的css样式名称冲突</p>
          </blockquote>
          <ol>
            <li>
              <p>使用：除了App.vue中的style，其他组件的style都要加<code>scoped</code></p>
            </li>
            <li>
              <p>参数：<code>lang</code></p>
              <p>1）默认：<code>lang=&quot;css&quot;</code></p>
              <p>2）可以指定样式语言，如：<code>lang=&quot;less&quot;</code></p>
              <p>3）由于webpeck版本是4.46.0，需要安装 <code>less-loader@7</code> 版本才行</p>
            </li>
            <li>
              <p>文件代码</p>
              <p>1）组件：components/School.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;h2 class=&quot;title&quot;&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;School&#39;,
  data() {
    return {
      name: &#39;尚硅谷atguigu&#39;,
      address: &#39;北京&#39;
    }
  }
}
&lt;/script&gt;
&lt;!--scope作用：防止不同组件之间的css样式名称冲突--&gt;
&lt;style scoped&gt;
.demo {
  background-color: skyblue;
}
&lt;/style&gt;
</code></pre>
              <p>2）组件：components/Student.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;h2 class=&quot;title&quot;&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2 class=&quot;atguigu&quot;&gt;学生性别：{{sex}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Student&#39;,
  data() {
    return {
      name: &#39;张三&#39;,
      sex: &#39;男&#39;
    }
  }
}
&lt;/script&gt;
&lt;!--可以指定style用哪种语言进行定义，如果使用less，需要安装less-loader--&gt;
&lt;style lang=&quot;less&quot; scoped&gt;
.demo {
  background-color: pink;
  .atguigu {
    font-size: 40px;
  }
}
&lt;/style&gt;
</code></pre>
              <p>3）汇总组件：src/App.vue，App的style不要加scope，会导致样式冲突！</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1 class=&quot;title&quot;&gt;你好啊&lt;/h1&gt;
    &lt;School /&gt;
    &lt;Student /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Student from &#39;./components/Student&#39;
import School from &#39;./components/School&#39;

export default {
  name: &#39;App&#39;,
  components: { School, Student }
}
&lt;/script&gt;

&lt;!--注意：App的style不要加scope，会导致样式冲突--&gt;
&lt;!--错误写法--&gt;
&lt;style scoped&gt;
.title {
  color: red;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-6-">2.6 本地与会话储存</h3>
          <ol>
            <li>
              <p>本地储存语法：(会话储存改为<code>sessionStorage</code>即可)</p>
              <p>1）储存数据：<code>localStorage.setItem(&#39;key&#39;, &#39;value&#39;)</code></p>
              <p>2）读取数据：<code>localStorage.getItem(&#39;key&#39;)</code>，获取不到数据返回null</p>
              <p>3）删除数据：<code>localStorage.removeItem(&#39;key&#39;)</code></p>
              <p>4）清空数据：<code>localStorage.clear()</code></p>
            </li>
            <li>
              <p>vue在data中设置：</p>
              <p>1）读取本地储存中的数据：<code>localStorage.getItem()</code></p>
              <p>2）如果本地无数据，要设置为空数组，否则为null</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">data() {
  return {
    todos: JSON.parse(localStorage.getItem(&#39;todos&#39;)) || []
  }
},
</code></pre>
            </li>
            <li>
              <p>watch监视数据：<code>localStorage.setItem()</code>，当数据改变时，需要实时更新</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">watch: {
  todos: {
    // 必须用深度监视，否则勾选后checked属性不发生变化
    deep: true,
    handler(value) {
      localStorage.setItem(&#39;todos&#39;, JSON.stringify(value))
    }
  }
}
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-7-">2.7 组件间通信</h3>
          <h4 id="2-7-1-">2.7.1 任意组件间通信</h4>
          <h5 id="2-7-1-1-globaleventbus">2.7.1.1 全局事件总线 GlobalEventBus</h5>
          <blockquote>
            <p>一种组件间通信的方式，适用于任意组件间通信。</p>
          </blockquote>
          <ol>
            <li>
              <p>安装：main.js</p>
              <p>1）方法1：麻烦，不常用</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
Vue.config.productionTip = false

//安装全局事件总线
const Demo = Vue.extend({})
const d = new Demo()
Vue.prototype.x = d
</code></pre>
              <p>2）方法2：常用方法</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
Vue.config.productionTip = false

new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
  beforeCreate() {
    Vue.prototype.$bus = this //安装全局事件总线
  },
})
</code></pre>
            </li>
            <li>
              <p>接收数据：<code>$bus.$on</code>，A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身</p>
              <p>1）定义处理接收到数据的函数：<code>methods: { demo(data){...}}</code></p>
              <p>2）挂载全局事件：<code>mounted() { this.$bus.$on(&#39;xxx&#39;, this.demo)}</code></p>
            </li>
            <li>
              <p>提供数据：<code>$bus.$emit</code></p>
              <ul>
                <li>语法：<code>methods: { sendData函数() { this.$bus.$emit(&#39;xxx&#39;, 数据) }</code></li>
              </ul>
            </li>
            <li>
              <p>解绑事件：<code>$bus.$off</code></p>
              <ul>
                <li>语法：<code>beforeDestroy() {this.$bus.$off(&#39;xxx&#39;) }</code></li>
                <li>作用：在销毁vc之前取消事件挂载，释放名称给其他人用</li>
              </ul>
            </li>
            <li>
              <p>完整案例代码：</p>
              <p>1）组件：Student.vue，提供数据：<code>$bus.$emit</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;student&quot;&gt;
    &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
    &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Student&#39;,
  data() {
    return {
      name: &#39;张三&#39;,
      sex: &#39;男&#39;
    }
  },
  mounted() {
  },
  methods: {
    sendStudentName() {
      // 全局事件总线：提供数据
      this.$bus.$emit(&#39;hello&#39;, this.name)
    }
  }
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.student {
  background-color: pink;
  padding: 5px;
  margin-top: 30px;
}
&lt;/style&gt;
</code></pre>
              <p>2）组件：School.vue，接收数据：<code>$bus.$on</code>、解绑事件：<code>$bus.$off</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;school&quot;&gt;
    &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;School&#39;,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京&#39;
    }
  },
  mounted() {
    // 全局事件总线：接收数据
    this.$bus.$on(&#39;hello&#39;, data =&gt; {
      console.log(&#39;我是School组件，收到了数据&#39;, data)
    })
  },
  // 全局事件总线：解绑事件
  beforeDestroy() {
    // 注意：要在销毁vc之前取消事件hello的挂载，释放hello名称给其他人用
    this.$bus.$off(&#39;hello&#39;)
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.school {
  background-color: skyblue;
  padding: 5px;
}
&lt;/style&gt;
</code></pre>
              <p>3）汇总组件：App.vue，与正常无区别</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;h1&gt;{{msg}}&lt;/h1&gt;
        &lt;School/&gt;
        &lt;Student/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Student from &#39;./components/Student&#39;
    import School from &#39;./components/School&#39;

    export default {
        name:&#39;App&#39;,
        components:{School,Student},
        data() {
            return {
                msg:&#39;你好啊！&#39;,
            }
        }
    }
&lt;/script&gt;

&lt;style scoped&gt;
    .app{
        background-color: gray;
        padding: 5px;
    }
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="2-7-1-2-pubsub">2.7.1.2 消息订阅与发布 pubsub</h5>
          <blockquote>
            <p>一种组件间通信的方式，适用于任意组件间通信。</p>
          </blockquote>
          <ol>
            <li>
              <p>安装与引入</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i pubsub-js
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">import pubsub from &#39;pubsub-js&#39;
</code></pre>
            </li>
            <li>
              <p>接收数据（订阅）：<code>pubsub.subscribe</code></p>
              <p>1）A组件接收数据，在A组件订阅消息，回调留在A组件自身</p>
              <p>2）挂载pubId：<code>this.pubId = pubsub.subscribe(&#39;函数名&#39;,this.函数)</code></p>
              <p>3）原理：每次pubsub时会生成不同的id，根据id号才能取消订阅</p>
              <p>4）接收由<code>pubsub.publish</code>提供的数据，第一个参数默认是<code>msgName</code>, 第二个参数才是数据，如果不想要第一个参数，要用“<code>_</code>”占位，否则报错</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 接收数据组件
deleteTodo(_, id) {
  this.todos = this.todos.filter(todo =&gt; todo.id !== id)
},

// 提供数据组件
pubsub.publish(&#39;deleteTodo&#39;,id)
</code></pre>
            </li>
            <li>
              <p>提供数据（发布）：<code>pubsub.publish(&#39;函数名&#39;, 数据)</code></p>
              <p>1）定义提供数据的函数：<code>methods: { sendData函数() { pubsub.publish(&#39;函数名&#39;, 数据) }</code></p>
            </li>
            <li>
              <p>取消订阅：<code>pubsub.unsubscribe(唯一对应的id值)</code></p>
              <p>1）语法：<code>beforeDestroy() { pubsub.unsubscribe(this.pubId) }</code></p>
            </li>
            <li>
              <p>完整案例代码：</p>
              <p>1）子组件：Student.vue，提供数据：<code>pubsub.publish</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;student&quot;&gt;
    &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
    &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import pubsub from &#39;pubsub-js&#39;
export default {
  name: &#39;Student&#39;,
  data() {
    return {
      name: &#39;张三&#39;,
      sex: &#39;男&#39;
    }
  },
  mounted() {
  },
  methods: {
    sendStudentName() {
      // 全局事件总线：提供数据
      // this.$bus.$emit(&#39;hello&#39;,this.name)

      // 消息订阅与发布：提供数据
      pubsub.publish(&#39;hello&#39;, 666)
    }
  }
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.student {
  background-color: pink;
  padding: 5px;
  margin-top: 30px;
}
&lt;/style&gt;
</code></pre>
              <p>2）子组件：School.vue，接收数据：<code>pubsub.subscribe</code>、取消订阅：<code>pubsub.unsubscribe</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;school&quot;&gt;
    &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 第三方插件：pubsub-js（所有框架可用，包括angular、react）
import pubsub from &#39;pubsub-js&#39;
export default {
  name: &#39;School&#39;,
  data() {
    return {
      name: &#39;尚硅谷&#39;,
      address: &#39;北京&#39;
    }
  },
  mounted() {
    // 全局事件总线：接收数据
    /* this.$bus.$on(&#39;hello&#39;,(data)=&gt;{
          console.log(&#39;我是School组件，收到了数据&#39;,data)
       }) */

    // 消息订阅与发布：接收数据
    // 每次pubsub时会生成不同的id，根据id号才能取消订阅，所以要挂到this上
    this.pubId = pubsub.subscribe(&#39;hello&#39;, (msgName, data) =&gt; {
      // 注意：如果是箭头函数，this指向vc；如果是正常函数，this是undefined
      console.log(this)
      // 参数：msgName：消息名称；data：数据
      console.log(&#39;有人发布了hello消息，hello消息的回调执行了&#39;, msgName, data)
    })
  },
  beforeDestroy() {
    // 全局事件总线：解绑事件
    // this.$bus.$off(&#39;hello&#39;)

    // 消息订阅与发布：取消订阅
    pubsub.unsubscribe(this.pubId)
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.school {
  background-color: skyblue;
  padding: 5px;
}
&lt;/style&gt;
</code></pre>
              <p>3）汇总组件：App.vue，与正常无区别</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;h1&gt;{{msg}}&lt;/h1&gt;
    &lt;School /&gt;
    &lt;Student /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Student from &#39;./components/Student&#39;
import School from &#39;./components/School&#39;

export default {
  name: &#39;App&#39;,
  components: { School, Student },
  data() {
    return {
      msg: &#39;你好啊！&#39;
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.app {
  background-color: gray;
  padding: 5px;
}
&lt;/style&gt;
</code></pre>
              <p>4）入口文件：main.js，与正常无区别</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//引入Vue
import Vue from &#39;vue&#39;
//引入App
import App from &#39;./App.vue&#39;
//关闭Vue的生产提示
Vue.config.productionTip = false

//创建vm
new Vue({
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-7-2-">2.7.2 父传子</h4>
          <h5 id="2-7-2-1-props-">2.7.2.1 props配置</h5>
          <ol>
            <li>
              <p>传递数据：在App.vue中配置</p>
              <p>1）例：<code>&lt;Student name=&quot;李四&quot; sex=&quot;女&quot; :age=&quot;18&quot; /&gt;</code></p>
              <p>2）注意：默认传递字符串，如果是数字要在age前加冒号</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 这里如果age是数字，需要用v-bind绑定，这样的话直接解析引号里面的内容 --&gt;
    &lt;Student name=&quot;李四&quot; sex=&quot;女&quot; :age=&quot;18&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Student from &#39;./components/Student&#39;

export default {
  name: &#39;App&#39;,
  components: { Student }
}
&lt;/script&gt;

</code></pre>
            </li>
            <li>
              <p>接收数据：在子组件中配置</p>
              <p>1）第一种方式（只接收）：<code>props:[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]</code></p>
              <p>2）第二种方式（限制类型）：<code>props:{name:String, age:Number, sex:String}</code></p>
              <p>3）第三种方式（限制类型、限制必要性、指定默认值）</p>
              <ul>
                <li><code>type</code>：类型，如String、Number</li>
                <li><code>required</code>：布尔值，是否必须输入</li>
                <li><code>default</code>：仅required为false时生效，指定默认值</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{msg}}&lt;/h1&gt;
    &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
    &lt;!--这里没有直接使用接收到的age，而是在data中定义了myAge进行进一步加工--&gt;
    &lt;h2&gt;学生年龄：{{myAge+1}}&lt;/h2&gt;
    &lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Student&#39;,
  data() {
    return {
      msg: &#39;我是一个尚硅谷的学生&#39;,
      // props中的属性优先级高于data中的属性
      // 注意：接收到的属性尽量不要修改！如果非要修改，在data中定义一个其他名称的变量，如：myAge: this.age
      myAge: this.age
    }
  },

  methods: {
    updateAge() {
      this.myAge++
    }
  },

  // 1. 第一种方式（只接收）
  // props:[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]

  // 2. 第二种方式（限制类型）
  /* props:{
        name:String,
        age:Number,
        sex:String
    } */

  // 3. 第三种方式（限制类型、限制必要性、指定默认值）
  props: {
    name: {
      type: String, // name的类型是字符串
      required: true // name是必要的
    },
    age: {
      type: Number,
      default: 99 // 默认值，如果不传入age为默认值
    },
    sex: {
      type: String,
      required: true
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>注意：</p>
              <p>1）props中的属性优先级高于data中的属性</p>
              <p>2）接收到的属性尽量不要修改！如果非要修改，在data中定义一个其他名称的变量，如：myAge: this.age</p>
              <p>3）props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告</p>
            </li>
          </ol>
          <h5 id="2-7-2-2-slot">2.7.2.2 插槽 slot</h5>
          <blockquote>
            <p>作用：让父组件可以向子组件指定位置插入html结构</p>
          </blockquote>
          <h6 id="2-7-2-2-1-">2.7.2.2.1 默认插槽</h6>
          <ol>
            <li>
              <p>父组件 App.vue：在子组件标签中写本应在子组件vue文件中写的内容</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Category title=&quot;美食&quot;&gt;
      &lt;!-- 在父组件中写的子组件标签，里面如果再写内容，需要在子组件vue文件中配置&lt;slot&gt;指定插入位置 --&gt;
      &lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt /&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏&quot;&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;电影&quot;&gt;
      &lt;video controls src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt;
    &lt;/Category&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Category from &#39;./components/Category&#39;
export default {
  name: &#39;App&#39;,
  components: { Category },
  data() {
    return {
      foods: [&#39;火锅&#39;, &#39;烧烤&#39;, &#39;小龙虾&#39;, &#39;牛排&#39;],
      games: [&#39;红色警戒&#39;, &#39;穿越火线&#39;, &#39;劲舞团&#39;, &#39;超级玛丽&#39;],
      films: [&#39;《教父》&#39;, &#39;《拆弹专家》&#39;, &#39;《你好，李焕英》&#39;, &#39;《尚硅谷》&#39;]
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.container {
  display: flex;
  justify-content: space-around;
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>子组件 Category.vue：用<code>&lt;slot&gt;</code>标签指定插入内容的位置</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;category&quot;&gt;
    &lt;h3&gt;{{title}}分类&lt;/h3&gt;
    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;
    &lt;slot&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Category&#39;,
  props: [&#39;title&#39;]
}
&lt;/script&gt;

&lt;style scoped&gt;
.category {
  background-color: skyblue;
  width: 200px;
  height: 300px;
}
h3 {
  text-align: center;
  background-color: orange;
}
video {
  width: 100%;
}
img {
  width: 100%;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h6 id="2-7-2-2-2-name">2.7.2.2.2 具名插槽 name</h6>
          <ol>
            <li>
              <p>父组件 App.vue：在子组件标签里写的内容标签，带上 <code>slot=&quot;xxx&quot;</code> 的属性</p>
              <ul>
                <li>注意：在里面可以再用<code>&lt;template&gt;</code>包裹多内容标签，用 <code>v-slot:xxx</code> 指定名称</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Category title=&quot;美食&quot; &gt;
      &lt;img slot=&quot;center&quot; src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;
      &lt;a slot=&quot;footer&quot; href=&quot;http://www.atguigu.com&quot;&gt;更多美食&lt;/a&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏&quot; &gt;
      &lt;ul slot=&quot;center&quot;&gt;
        &lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
      &lt;/ul&gt;
      &lt;!-- 多内容写法1 --&gt;
      &lt;div class=&quot;foot&quot; slot=&quot;footer&quot;&gt;
        &lt;a href=&quot;http://www.atguigu.com&quot;&gt;单机游戏&lt;/a&gt;
        &lt;a href=&quot;http://www.atguigu.com&quot;&gt;网络游戏&lt;/a&gt;
      &lt;/div&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;电影&quot;&gt;
      &lt;video slot=&quot;center&quot; controls src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt;
      &lt;!-- 多内容写法2：可再用&lt;template&gt;包裹多内容标签，用 v-slot:xxx 指定名称 --&gt;
      &lt;template v-slot:footer&gt;
        &lt;div class=&quot;foot&quot;&gt;
          &lt;a href=&quot;http://www.atguigu.com&quot;&gt;经典&lt;/a&gt;
          &lt;a href=&quot;http://www.atguigu.com&quot;&gt;热门&lt;/a&gt;
          &lt;a href=&quot;http://www.atguigu.com&quot;&gt;推荐&lt;/a&gt;
        &lt;/div&gt;
        &lt;h4&gt;欢迎前来观影&lt;/h4&gt;
      &lt;/template&gt;
    &lt;/Category&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Category from &#39;./components/Category&#39;
  export default {
    name:&#39;App&#39;,
    components:{ Category },
    data() {
      return {
        foods:[&#39;火锅&#39;,&#39;烧烤&#39;,&#39;小龙虾&#39;,&#39;牛排&#39;],
        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;],
        films:[&#39;《教父》&#39;,&#39;《拆弹专家》&#39;,&#39;《你好，李焕英》&#39;,&#39;《尚硅谷》&#39;]
      }
    },
  }
&lt;/script&gt;

&lt;style scoped&gt;
  .container,.foot{
    display: flex;
    justify-content: space-around;
  }
  h4{
    text-align: center;
  }
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>子组件 Category.vue：在<code>&lt;slot&gt;</code>标签中指定 <code>name=&quot;xxx&quot;</code>，区别插入内容的位置</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;category&quot;&gt;
    &lt;h3&gt;{{title}}分类&lt;/h3&gt;
    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;
    &lt;slot name=&quot;center&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现1&lt;/slot&gt;
    &lt;slot name=&quot;footer&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现2&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name:&#39;Category&#39;,
    props:[&#39;title&#39;]
  }
&lt;/script&gt;

&lt;style scoped&gt;
  .category{
    background-color: skyblue;
    width: 200px;
    height: 300px;
  }
  h3{
    text-align: center;
    background-color: orange;
  }
  video{
    width: 100%;
  }
  img{
    width: 100%;
  }
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h6 id="2-7-2-2-3-scope">2.7.2.2.3 作用域插槽 scope</h6>
          <ol>
            <li><p>核心：数据在子组件，根据数据生成的结构在父组件</p></li>
            <li>
              <p>父组件 App.vue：在子组件标签中用<code>&lt;template&gt;</code>包裹内容，并指定 <code>scope</code></p>
              <p>1）方式1：<code>scope=&quot;自定义名称&quot;</code>，如 atguigu，用 atguigu.xxx 或 atguigu.yyy 显示数据</p>
              <p>2）方式2：<code>scope</code> 或 <code>slot-scope=&quot;{xxx}&quot;</code>，解构赋值，直接用xxx显示数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Category title=&quot;游戏&quot;&gt;
      &lt;!--方法1：自定义名称随便写，不影响任何元素，只是临时使用 --&gt;
      &lt;template scope=&quot;atguigu&quot;&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;(g,index) in atguigu.games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏2&quot;&gt;
      &lt;!--方法2--&gt;
      &lt;template scope=&quot;{games}&quot;&gt;
        &lt;ol&gt;
          &lt;li style=&quot;color:red&quot; v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/template&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏3&quot;&gt;
      &lt;!--方法2--&gt;
      &lt;template slot-scope=&quot;{games}&quot;&gt;
        &lt;h4 v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/h4&gt;
      &lt;/template&gt;
    &lt;/Category&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Category from &#39;./components/Category&#39;
export default {
  name: &#39;App&#39;,
  components: { Category }
}
&lt;/script&gt;

&lt;style scoped&gt;
.container,
.foot {
  display: flex;
  justify-content: space-around;
}
h4 {
  text-align: center;
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>子组件 Category.vue：在<code>&lt;slot&gt;</code>中定义 <code>:xxx=&quot;data1&quot;, yyy=&quot;data2&quot;</code>，指定作用域和数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;category&quot;&gt;
    &lt;h3&gt;{{title}}分类&lt;/h3&gt;
    &lt;!--指定作用域、数据--&gt;
    &lt;slot :games=&quot;games&quot; msg=&quot;hello&quot;&gt;我是默认的一些内容&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Category&#39;,  
  props: [&#39;title&#39;],    // 可以承接不同对应的title
  data() {
    return {
      games: [&#39;红色警戒&#39;, &#39;穿越火线&#39;, &#39;劲舞团&#39;, &#39;超级玛丽&#39;]
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.category {
  background-color: skyblue;
  width: 200px;
  height: 300px;
}
h3 {
  text-align: center;
  background-color: orange;
}
video {
  width: 100%;
}
img {
  width: 100%;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-7-3-">2.7.3 子传父</h4>
          <h5 id="2-7-3-1-props-">2.7.3.1 props配置</h5>
          <ol>
            <li><p>原理：父组件给子组件传递一个函数，用“<code>：传递参数名=&quot;funcionName&quot;</code>”绑定，在子组件中用<code>this.funcionName()</code>将参数传递给父组件</p></li>
            <li>
              <p>父组件：App.vue</p>
              <p>1）语法：<code>&lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt;</code></p>
              <p>2）需要在父组件中定义数据todos、函数checkTodo、deleteTodo</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;div class=&quot;todo-container&quot;&gt;
      &lt;div class=&quot;todo-wrap&quot;&gt;
        &lt;!-- 传参：addTodo(在MyHeader中配置props)，传入函数addTodo --&gt;
        &lt;!-- MyHeader功能：添加ToDo --&gt;
        &lt;MyHeader :addTodo=&quot;addTodo&quot; /&gt;
        &lt;!-- MyList功能：勾选、删除ToDo --&gt;
        &lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt;
        &lt;!-- MyFooter功能：全选、清除已完成ToDo --&gt;
        &lt;MyFooter :todos=&quot;todos&quot; :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 这里之所以没引入MyItem，是因为MyList中已经引入了
import MyHeader from &#39;./components/MyHeader&#39;
import MyList from &#39;./components/MyList&#39;
import MyFooter from &#39;./components/MyFooter.vue&#39;

export default {
  name: &#39;App&#39;,
  components: { MyHeader, MyList, MyFooter },
  data() {
    return {
      //由于todos是MyHeader组件和MyFooter组件都在使用，所以放在App中（状态提升）
      todos: [
        { id: &#39;001&#39;, title: &#39;抽烟&#39;, done: true },
        { id: &#39;002&#39;, title: &#39;喝酒&#39;, done: false },
        { id: &#39;003&#39;, title: &#39;开车&#39;, done: true }
      ]
    }
  },
  methods: {
    // 添加
    addTodo(todoObj) {
      this.todos.unshift(todoObj)
    },
    // 勾选
    checkTodo(id) {
      this.todos.forEach(todo =&gt; {
        if (todo.id === id) todo.done = !todo.done
      })
    },
    // 删除
    deleteTodo(id) {
      // filter不会改变原数组，只是返回新数组，虽然都叫todos，但是已经不一样了，只要保证id不出问题，不会改变原todos
      this.todos = this.todos.filter(todo =&gt; todo.id !== id)
    },
    // 全选
    checkAllTodo(done) {
      this.todos.forEach(todo =&gt; {
        todo.done = done
      })
    },
    // 清除已完成
    clearAllTodo() {
      this.todos = this.todos.filter(todo =&gt; {
        return !todo.done
      })
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>子组件：MyList.vue</p>
              <p>1）接收数据：<code>props: [&#39;todos&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]</code>，接收父组件传递的todoObj数据、checkTodo函数、deleteTodo函数</p>
              <p>2）注意：MyList也是MyItem的父组件，从App.vue接收到的数据可以进一步传递给孙组件</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul class=&quot;todo-main&quot;&gt;
    &lt;!-- 给MyItem传递数据：todoObj、checkTodo、deleteTodo --&gt;
    &lt;MyItem
      v-for=&quot;todoObj in todos&quot;
      :key=&quot;todoObj.id&quot;
      :todo=&quot;todoObj&quot;
      :checkTodo=&quot;checkTodo&quot;
      :deleteTodo=&quot;deleteTodo&quot;
    /&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
import MyItem from &#39;./MyItem&#39;

export default {
  name: &#39;MyList&#39;,
  components: { MyItem },
  //声明接收App传递过来的数据，其中todos是自己用的，checkTodo和deleteTodo是给子组件MyItem用的
  props: [&#39;todos&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]
}
&lt;/script&gt;

&lt;style scoped&gt;
.todo-main {
  margin-left: 0px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding: 0px;
}

.todo-empty {
  height: 40px;
  line-height: 40px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding-left: 5px;
  margin-top: 10px;
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>孙组件：MyItem.vue</p>
              <p>1）接收数据：props: [&#39;todo&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]</p>
              <p>2）注意：这里的todo是todos中的逐条数据</p>
              <p>3）使用父组件的方法：this.传递过来的函数名，将子组件中的参数传给父组件，由父组件进行处理</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;li&gt;
    &lt;label&gt;
      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot; /&gt;
      &lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;
      &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;
      &lt;span&gt;{{todo.title}}&lt;/span&gt;
    &lt;/label&gt;
    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;
  &lt;/li&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;MyItem&#39;,
  // 声明接收todo、checkTodo、deleteTodo
  // 这里的todo接受的是单条数据todoObj
  props: [&#39;todo&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;],
  methods: {
    // 勾选/取消勾选
    handleCheck(id) {
      // 通知父组件App将对应的todo对象的done值取反
      this.checkTodo(id)
    },
    // 删除
    handleDelete(id) {
      if (confirm(&#39;确定删除吗？&#39;)) {
        // 通知父组件App将对应的todo对象删除
        this.deleteTodo(id)
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="2-7-3-2-">2.7.3.2 自定义事件</h5>
          <blockquote>
            <p>适用于子组件传递数据给父组件，事件回调函数留在父组件中。</p>
          </blockquote>
          <ol>
            <li>
              <p>绑定事件：父组件App.vue</p>
              <p>1）方法1：使用<code>@</code>或<code>v-on</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;Student @自定义事件名称=&quot;functionName&quot;/&gt;
</code></pre>
              <p>2）方法2：使用<code>ref</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;Student ref=&quot;ref名称&quot; /&gt;
</code></pre>
              <ul>
                <li>
                  <p>需要在mounted()中绑定事件</p>
                  <pre class="prettyprint linenums:0"><code class="lang-js">this.$refs.ref名称.$on(&#39;自定义事件名称&#39;, this.functionName)
// 也可以绑定一次性事件
this.$refs.ref名称.$once(&#39;自定义事件名称&#39;, this.functionName)
</code></pre>
                </li>
                <li><p>优点：灵活性强，可以实现计时器效果、多重事件效果，而方法一无法实现</p></li>
                <li>回调函数要么配置在methods中，要么用箭头函数，否则this指向会出问题</li>
                <li>用ref绑定自定义事件时，会把@后全部看成自定义事件，包括原生JS中的click，如果想使用原生JS事件，需要加<code>native</code></li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!--App.vue--&gt;
&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;h1&gt;{{msg}}，学生姓名是:{{studentName}}&lt;/h1&gt;
    &lt;School :getSchoolName=&quot;getSchoolName&quot; /&gt;

    &lt;!-- 第1种写法：使用@或v-on --&gt;
    &lt;!-- &lt;Student @atguigu=&quot;getStudentName&quot; @demo=&quot;m1&quot;/&gt; --&gt;
    &lt;!-- 可以只触发一次 --&gt;
    &lt;!-- &lt;Student @atguigu.once=&quot;getStudentName&quot; @demo=&quot;m1&quot;/&gt; --&gt;

    &lt;!-- 第2种写法：使用ref --&gt;
    &lt;!-- 注意：此方法会将@后的事件全部看做自定义事件，如果想绑定原生JS事件（如click），需要加.native --&gt;
    &lt;Student ref=&quot;student&quot; @click.native=&quot;show&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Student from &#39;./components/Student&#39;
import School from &#39;./components/School&#39;

export default {
  name: &#39;App&#39;,
  components: { School, Student },
  data() {
    return {
      msg: &#39;你好啊！&#39;,
      studentName: &#39;&#39;
    }
  },
  methods: {
    getSchoolName(name) {
      console.log(&#39;App收到了学校名：&#39;, name)
    },
    getStudentName(name, ...params) {
      console.log(&#39;App收到了学生名：&#39;, name, params)
      this.studentName = name
    },
    m1() {
      console.log(&#39;demo事件被触发了！&#39;)
    },
    show() {
      alert(123)
    }
  },
  // 第2种写法：使用ref，需要挂载
  mounted() {
    this.$refs.student.$on(&#39;atguigu&#39;, this.getStudentName) //绑定自定义事件
    // this.$refs.student.$once(&#39;atguigu&#39;,this.getStudentName) //绑定自定义事件（一次性）
  }

  // 方法2的优点：灵活性强，可以实现计时器效果、多重事件效果，而方法一无法实现
  /* mounted() {
    setTimeout(() =&gt; {
      this.$refs.student.$on(&#39;atguigu&#39;, this.getStudentName) //绑定自定义事件
    }, 3000)
  } */
}
&lt;/script&gt;

&lt;style scoped&gt;
.app {
  background-color: gray;
  padding: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>触发事件：子组件，<code>this.$emit(&#39;自定义事件名称&#39;, 数据/多参数）</code></p>
            </li>
            <li>
              <p>解绑事件：子组件</p>
              <p>1）解绑单个事件：<code>this.$off(&#39;自定义事件名称&#39;)</code></p>
              <p>2）解绑多个事件：<code>this.$off([&#39;自定义事件名称1&#39;,&#39;自定义事件名称2&#39;])</code></p>
              <p>3）解绑所有自定义事件：<code>this.$off()</code></p>
            </li>
            <li>
              <p>销毁实例：子组件，<code>this.$destroy()</code>，销毁vc实例后，所有绑定在该实例上的事件均被销毁</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--Student.vue--&gt;
&lt;template&gt;
    &lt;div class=&quot;student&quot;&gt;
        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
        &lt;h2&gt;当前求和为：{{number}}&lt;/h2&gt;
        &lt;button @click=&quot;add&quot;&gt;点我number++&lt;/button&gt;
        &lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt;
        &lt;button @click=&quot;unbind&quot;&gt;解绑atguigu事件&lt;/button&gt;
        &lt;button @click=&quot;death&quot;&gt;销毁当前Student组件的实例(vc)&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;Student&#39;,
        data() {
            return {
                name:&#39;张三&#39;,
                sex:&#39;男&#39;,
                number:0
            }
        },
        methods: {
            add(){
                console.log(&#39;add回调被调用了&#39;)
                this.number++
            },
            sendStudentlName(){
                // 触发Student组件实例身上的atguigu事件
                this.$emit(&#39;atguigu&#39;, this.name, 666, 888, 900)
            },
            unbind(){
                this.$off(&#39;atguigu&#39;) //解绑一个自定义事件
                // this.$off([&#39;atguigu&#39;,&#39;demo&#39;]) //解绑多个自定义事件
                // this.$off() //解绑所有的自定义事件
            },
            death(){
                this.$destroy() //销毁了当前Student组件的实例，销毁后所有Student实例的自定义事件全都不奏效。
            }
        },
    }
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
    .student{
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    }
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-8-nexttick">2.8 nextTick</h3>
          <ol>
            <li>
              <p>语法：<code>this.$nextTick(回调函数)</code></p>
            </li>
            <li><p>作用：在下一次 DOM 更新结束后执行其指定的回调</p></li>
            <li><p>场景：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行</p></li>
            <li>
              <p>案例：给todo列表添加“编辑”按钮</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 点击编辑按钮后，输入框才出现，然后才能获取焦点
this.$nextTick(function() {this.$refs.inputTitle.focus()})
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-9-">2.9 过度与动画</h3>
          <h4 id="2-9-1-css-">2.9.1 css自定义动画</h4>
          <ol>
            <li>
              <p>写css样式：</p>
              <p>1）元素进入的样式</p>
              <ul>
                <li><code>v-enter</code>：进入的起点</li>
                <li><code>v-enter-active</code>：进入过程中</li>
                <li><code>v-enter-to</code>：进入的终点</li>
              </ul>
              <p>2）元素离开的样式</p>
              <ul>
                <li><code>v-leave</code>：离开的起点</li>
                <li><code>v-leave-active</code>：离开过程中</li>
                <li><code>v-leave-to</code>：离开的终点</li>
              </ul>
            </li>
            <li>
              <p>用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性</p>
              <ul>
                <li><code>appear</code>属性：一打开页面的时候就有动画效果</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;!-- Vue动画标签 --&gt;
    &lt;!-- appear属性：代表一打开页面的时候就有动画效果 --&gt;
    &lt;transition name=&quot;hello&quot; appear&gt;
      &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Test&#39;,
  data() {
    return {
      isShow: true
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
h1 {
  background-color: orange;
}
/* 进入效果：v-enter-active */
.hello-enter-active {
  animation: atguigu 0.5s linear;
}
/* 离开效果：v-enter-active */
.hello-leave-active {
  animation: atguigu 0.5s linear reverse;
}
@keyframes atguigu {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0px);
  }
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定key值</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;!-- transition-group：可以给多个元素加动画，需要加 key --&gt;
    &lt;transition-group name=&quot;hello&quot; appear&gt;
      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;
      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;
    &lt;/transition-group&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Test&#39;,
  data() {
    return {
      isShow: true
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
h1 {
  background-color: orange;
  /* transition: 0.5s linear; */
}
/* 用过度效果写 */

/* 进入的起点、离开的终点 */
.hello-enter,
.hello-leave-to {
  transform: translateX(-100%);
}
/* 动画：时间、运动效果 */
.hello-enter-active,
.hello-leave-active {
  transition: 0.5s linear;
}
/* 进入的终点、离开的起点 */
.hello-enter-to,
.hello-leave {
  transform: translateX(0);
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="2-9-2-animate-css">2.9.2 animate.css</h4>
          <ol>
            <li>
              <p>第三方动画库：<a href="https://animate.style/">animate.css</a></p>
            </li>
            <li>
              <p>安装：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm install animate.css
</code></pre>
            </li>
            <li>
              <p>使用：在<code>&lt;transition&gt;</code>标签中指定 <code>name=&quot;animate__animated xxx&quot;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
    &lt;transition-group
      appear
      name=&quot;animate__animated animate__bounce&quot;
      enter-active-class=&quot;animate__swing&quot;
      leave-active-class=&quot;animate__backOutUp&quot;
    &gt;
      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;
      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;
    &lt;/transition-group&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// npm上一个非常成型的动画库：animate.css
import &#39;animate.css&#39;
export default {
  name: &#39;Test&#39;,
  data() {
    return {
      isShow: true
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
h1 {
  background-color: orange;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="2-10-todolist">2.10 案例：ToDoList</h3>
          <blockquote>
            <p>第三方库依赖：<code>nanoid</code>，用于生成唯一id</p>
          </blockquote>
          <p><img src="./src/todolist项目说明.png" alt="todolist项目说明" /></p>
          <h4 id="2-10-1-props-">2.10.1 应用：props属性</h4>
          <h5 id="-app-vue">父组件：App.vue</h5>
          <ol>
            <li><p>由3个子组件：<code>MyHeader</code>、<code>MyList</code>、<code>MyFooter</code>构成（其中<code>MyList</code>还嵌套了一层<code>MyItem</code>子组件）</p></li>
            <li><p>使用props属性为子组件传递函数，并接收由子组件发回的参数</p></li>
            <li>
              <p>状态提升：列表数据todos之所以放在父组件App.vue中，是因为子组件<code>MyHeader</code>、<code>MyFooter</code>都在使用</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;div class=&quot;todo-container&quot;&gt;
      &lt;div class=&quot;todo-wrap&quot;&gt;
        &lt;!-- 传参：addTodo(在MyHeader中配置props)，传入函数addTodo --&gt;
        &lt;!-- MyHeader功能：添加ToDo --&gt;
        &lt;MyHeader :addTodo=&quot;addTodo&quot; /&gt;
        &lt;!-- MyList功能：勾选、删除ToDo --&gt;
        &lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt;
        &lt;!-- MyFooter功能：全选、清除已完成ToDo --&gt;
        &lt;MyFooter :todos=&quot;todos&quot; :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 这里之所以没引入MyItem，是因为MyList中已经引入了
import MyHeader from &#39;./components/MyHeader&#39;
import MyList from &#39;./components/MyList&#39;
import MyFooter from &#39;./components/MyFooter.vue&#39;

export default {
  name: &#39;App&#39;,
  components: { MyHeader, MyList, MyFooter },
  data() {
    return {
      //由于todos是MyHeader组件和MyFooter组件都在使用，所以放在App中（状态提升）
      todos: [
        { id: &#39;001&#39;, title: &#39;抽烟&#39;, done: true },
        { id: &#39;002&#39;, title: &#39;喝酒&#39;, done: false },
        { id: &#39;003&#39;, title: &#39;开车&#39;, done: true }
      ]
    }
  },
  methods: {
    // 添加
    addTodo(todoObj) {
      this.todos.unshift(todoObj)
    },
    // 勾选
    checkTodo(id) {
      this.todos.forEach(todo =&gt; {
        if (todo.id === id) todo.done = !todo.done
      })
    },
    // 删除
    deleteTodo(id) {
      // filter不会改变原数组，只是返回新数组，虽然都叫todos，但是已经不一样了，只要保证id不出问题，不会改变原todos
      this.todos = this.todos.filter(todo =&gt; todo.id !== id)
    },
    // 全选
    checkAllTodo(done) {
      this.todos.forEach(todo =&gt; {
        todo.done = done
      })
    },
    // 清除已完成
    clearAllTodo() {
      this.todos = this.todos.filter(todo =&gt; {
        return !todo.done
      })
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
body {
  background: #fff;
}
.btn {
  display: inline-block;
  padding: 4px 12px;
  margin-bottom: 0;
  font-size: 14px;
  line-height: 20px;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  border-radius: 4px;
}
.btn-danger {
  color: #fff;
  background-color: #da4f49;
  border: 1px solid #bd362f;
}
.btn-danger:hover {
  color: #fff;
  background-color: #bd362f;
}
.btn:focus {
  outline: none;
}
.todo-container {
  width: 600px;
  margin: 0 auto;
}
.todo-container .todo-wrap {
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-myheader-vue">子组件：MyHeader.vue</h5>
          <ol>
            <li><p>作用：提供input输入框，根据用户输入内容添加ToDo</p></li>
            <li><p>导入：第三方库nanoid，用于给ToDo对象提供唯一值的id</p></li>
            <li>
              <p>props接收父组件传递过来的addToDo函数：<code>props[&#39;addToDo&#39;]</code></p>
            </li>
            <li>
              <p>add函数：生成todoObj后，用<code>this.addTodo(todoObj)</code>将todoObj传递给父组件App.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;todo-header&quot;&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的任务名称，按回车键确认&quot; v-model=&quot;title&quot; @keyup.enter=&quot;add&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// nanoid是用于生成唯一id的第三方库，使用npm i nanoid安装后导入使用
import { nanoid } from &#39;nanoid&#39;

export default {
  name: &#39;MyHeader&#39;,
  // 接收从父组件App传递过来的addTodo函数
  props: [&#39;addTodo&#39;],
  data() {
    return {
      //收集用户输入的title
      title: &#39;&#39;
    }
  },
  methods: {
    // js原生事件方法获取输入框的值：e.target
    /* add(e){
      console.log(e.target.value)
    }, */

    add() {
      // 校验数据：需要输入非空数据
      if (!this.title.trim()) return alert(&#39;输入不能为空&#39;)
      // 将用户的输入包装成一个todo对象
      const todoObj = { id: nanoid(), title: this.title, done: false }
      // 子传父通信：通知父组件App添加一个todo对象
      this.addTodo(todoObj)
      // 清空输入
      this.title = &#39;&#39;
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.todo-header input {
  width: 560px;
  height: 28px;
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 4px 7px;
}

.todo-header input:focus {
  outline: none;
  border-color: rgba(82, 168, 236, 0.8);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-mylist-vue">子组件：MyList.vue</h5>
          <ol>
            <li><p>作用：中转，里面嵌套孙组件MyItem，遍历App传递过来的<code>todos</code>，形成列表</p></li>
            <li>
              <p>props接受父组件App的数据：<code>props: [&#39;todos&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]</code></p>
              <p>1）todos：数据对象，用于遍历形成列表</p>
              <p>2）checkTodo：勾选/取消勾选函数，要继续传递给孙组件<code>MyItem</code></p>
              <p>3）deleteTodo：删除函数，要继续传递给孙组件<code>MyItem</code></p>
            </li>
            <li>
              <p>props给孙组件<code>MyItem</code>传递数据：</p>
              <p>1）todo：todoObj单条数据</p>
              <p>2）checkTodo：checkTodo函数</p>
              <p>3）deleteTodo：deleteTodo函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul class=&quot;todo-main&quot;&gt;
    &lt;!-- 给MyItem传递数据：todoObj、checkTodo、deleteTodo --&gt;
    &lt;MyItem
      v-for=&quot;todoObj in todos&quot;
      :key=&quot;todoObj.id&quot;
      :todo=&quot;todoObj&quot;
      :checkTodo=&quot;checkTodo&quot;
      :deleteTodo=&quot;deleteTodo&quot;
    /&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
import MyItem from &#39;./MyItem&#39;

export default {
  name: &#39;MyList&#39;,
  components: { MyItem },
  //声明接收App传递过来的数据，其中todos是自己用的，checkTodo和deleteTodo是给子组件MyItem用的
  props: [&#39;todos&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]
}
&lt;/script&gt;

&lt;style scoped&gt;
.todo-main {
  margin-left: 0px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding: 0px;
}

.todo-empty {
  height: 40px;
  line-height: 40px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding-left: 5px;
  margin-top: 10px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-myitem-vue">孙组件：MyItem.vue</h5>
          <ol>
            <li><p>作用：对单条数据todoObj进行勾选、删除操作</p></li>
            <li>
              <p>props接收MyList--&gt;App传递来的数据（层层穿透）：<code>props: [&#39;todo&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]</code></p>
            </li>
            <li><p>handleCheck函数：传递勾选的id，再用<code>this.checkTodo(id)</code>将id传递给父组件App</p></li>
            <li>
              <p>handleDelete函数：传递勾选的id，再用<code>this.deleteTodo(id)</code>将id传递给父组件App</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;li&gt;
    &lt;label&gt;
      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot; /&gt;
      &lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;
      &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;
      &lt;span&gt;{{todo.title}}&lt;/span&gt;
    &lt;/label&gt;
    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;
  &lt;/li&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;MyItem&#39;,
  // 声明接收todo、checkTodo、deleteTodo
  // 这里的todo接受的是单条数据todoObj
  props: [&#39;todo&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;],
  methods: {
    // 勾选/取消勾选
    handleCheck(id) {
      // 通知父组件App将对应的todo对象的done值取反
      this.checkTodo(id)
    },
    // 删除
    handleDelete(id) {
      if (confirm(&#39;确定删除吗？&#39;)) {
        // 通知父组件App将对应的todo对象删除
        this.deleteTodo(id)
      }
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
li {
  list-style: none;
  height: 36px;
  line-height: 36px;
  padding: 0 5px;
  border-bottom: 1px solid #ddd;
}
li label {
  /* float: left; */
  cursor: pointer;
}
li label li input {
  vertical-align: middle;
  margin-right: 6px;
  position: relative;
  top: -1px;
}
li button {
  float: right;
  display: none;
  margin-top: 3px;
}
li:before {
  content: initial;
}
li:last-child {
  border-bottom: none;
}
li:hover {
  background-color: #ddd;
}
li:hover button {
  display: block;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-myfooter-vue">子组件：MyFooter.vue</h5>
          <ol>
            <li><p>作用：底部计数栏、全选/全不选、清除已完成任务</p></li>
            <li>
              <p>props接收父组件App传递来的数据：<code>props: [&#39;todo&#39;, &#39;checkTodo&#39;, &#39;deleteTodo&#39;]</code></p>
            </li>
            <li>
              <p>计算属性isAll：</p>
              <p>1）get()：控制是否全选</p>
              <p>2）set(value)：控制当其被改变时，用<code>this.checkAllTodo(value)</code>通知父组件App将todos中所有done属性标记为用户传递过来的value</p>
            </li>
            <li>
              <p>clearAll函数：点击按钮时，调用<code>this.clearAllTodo()</code>通知父组件App清除已完成todos</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;!-- v-show控制的是diplay，如果total为0，则不展示footer计数栏 --&gt;
  &lt;div class=&quot;todo-footer&quot; v-show=&quot;total&quot;&gt;
    &lt;label&gt;
      &lt;!-- 全选框：方法1：用checkAll函数改变checked状态，比较麻烦 --&gt;
      &lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot;/&gt; --&gt;

      &lt;!-- 全选框：方法2：巧用计算属性isAll，无需再另外声明函数 --&gt;
      &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot; /&gt;
    &lt;/label&gt;
    &lt;span&gt;
      &lt;span&gt;已完成{{doneTotal}}&lt;/span&gt;
      / 全部{{total}}
    &lt;/span&gt;
    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;clearAll&quot;&gt;清除已完成任务&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;MyFooter&#39;,
  props: [&#39;todos&#39;, &#39;checkAllTodo&#39;, &#39;clearAllTodo&#39;],
  computed: {
    // 总数
    total() {
      return this.todos.length
    },
    // 已完成数
    doneTotal() {
      // 用reduce方法做条件统计（有几条数据调用几次），pre是累计器（初始值为0），todo是当前值
      return this.todos.reduce((pre, todo) =&gt; pre + (todo.done ? 1 : 0), 0)
    },
    // 注意：isAll计算属性是由total、doneTotal这两个计算属性动态计算得来的（允许套娃）
    // 控制全选框（bool类型）
    isAll: {
      //全选框是否勾选（如果没有待完成事件时，取消勾选）
      get() {
        return this.doneTotal === this.total &amp;&amp; this.total &gt; 0
      },
      // isAll被修改时set被调用（即checkbox选项框被点击时）
      set(value) {
        // 通知父组件App将todos中所有done属性标记为用户传递过来的value（true或false）
        this.checkAllTodo(value)
      }
    }
  },
  methods: {
    // 全选框：方法1：用checkAll函数改变checked状态，比较麻烦
    /* checkAll(e){
          this.checkAllTodo(e.target.checked)
        } */

    // 清空所有已完成
    clearAll() {
      // 通知父组件App清除所有todos.done为true的数据
      this.clearAllTodo()
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.todo-footer {
  height: 40px;
  line-height: 40px;
  padding-left: 6px;
  margin-top: 5px;
}
.todo-footer label {
  display: inline-block;
  margin-right: 20px;
  cursor: pointer;
}
.todo-footer label input {
  position: relative;
  top: -1px;
  vertical-align: middle;
  margin-right: 5px;
}
.todo-footer button {
  float: right;
  margin-top: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-main-js">入口文件：main.js</h5>
          <ol>
            <li>
              <p>正常写法：</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//引入Vue
import Vue from &#39;vue&#39;
//引入App
import App from &#39;./App.vue&#39;
//关闭Vue的生产提示
Vue.config.productionTip = false

//创建vm
new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-10-2-">2.10.2 应用：本地储存</h4>
          <blockquote>
            <p>需求：将父组件中定义的todos数组改造成从本地储存<code>localStorage</code>中读取、储存</p>
          </blockquote>
          <h5 id="-app-vue">父组件：App.vue</h5>
          <ol>
            <li>
              <p>将data()中的todos数组改为从本地储存localStorage取数据，如果前期无数据，则初始化为空数组<code>[]</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">data() {
  return {
    // 初始化时，如果没有数据，需要将todos设置为一个空数组，否则会变成null
    todos: JSON.parse(localStorage.getItem(&#39;todos&#39;)) || []
  }
},
</code></pre>
            </li>
            <li>
              <p>监视属性watch：监视todos，一旦变化，就会触发localStorage的变化</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 使用watch实现，只要todos变化了，就会触发localStorage的变化
watch: {
  todos: {
    // 必须用深度监视，否则勾选后checked属性不发生变化
    deep: true,
    handler(value) {
      localStorage.setItem(&#39;todos&#39;, JSON.stringify(value))
    }
  }
}
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-10-3-">2.10.3 应用：自定义事件</h4>
          <blockquote>
            <p>需求：将<code>addTodo</code>、<code>checkAllTodo</code>、<code>clearAllTodo</code>函数由props传递改成自定义事件，影响：App、MyHeader、MyFooter</p>
          </blockquote>
          <h5 id="-app-vue">父组件：App.vue</h5>
          <ol>
            <li>
              <p>绑定事件：使用<code>@</code>或<code>v-on</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;div class=&quot;todo-container&quot;&gt;
      &lt;div class=&quot;todo-wrap&quot;&gt;
        &lt;!-- 注意：所有父给子传递函数的地方，都可以改造成自定义事件的模式 --&gt;
        &lt;!-- &lt;MyHeader :addTodo=&quot;addTodo&quot; /&gt; --&gt;
        &lt;MyHeader @addTodo=&quot;addTodo&quot; /&gt;
        &lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt;
        &lt;!-- &lt;MyFooter :todos=&quot;todos&quot; :checkAllTodo=&quot;checkAllTodo&quot; :clearAllTodo=&quot;clearAllTodo&quot; /&gt; --&gt;
        &lt;MyFooter :todos=&quot;todos&quot; @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-myheader-vue">子组件：MyHeader.vue</h5>
          <ol>
            <li><p>无需再使用props接受父组件传递的addTodo函数</p></li>
            <li>
              <p>在add()方法中用 <code>$emit</code> 触发父组件App中的addTodo函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">export default {
  name: &#39;MyHeader&#39;,
  // 无需再接收addTodo
  // props: [&#39;addTodo&#39;],
  data() {
    return {
      title: &#39;&#39;
    }
  },
  methods: {
    add() {
      if (!this.title.trim()) return alert(&#39;输入不能为空&#39;)
      const todoObj = { id: nanoid(), title: this.title, done: false }
      // 子传父通信（旧方法）
      // this.addTodo(todoObj)

      // 触发事件：$emit，通知App组件去添加一个todo对象
      this.$emit(&#39;addTodo&#39;, todoObj, 1, 2, 3)
      this.title = &#39;&#39;
    }
  }
}
</code></pre>
            </li>
          </ol>
          <h5 id="-myfooter-vue">子组件：MyFooter.vue</h5>
          <ol>
            <li><p>无需再使用props接受父组件传递的checkTodo、deleteTodo函数</p></li>
            <li>
              <p>将checkAllTodo、clearAllTodo改造为<code>this.$emit()</code>模式</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;script&gt;
export default {
  name: &#39;MyFooter&#39;,
  props: [&#39;todos&#39;], // 无需再接收checkAllTodo、clearAllTodo
  computed: {
    //总数
    total() {
      return this.todos.length
    },
    doneTotal() {
      return this.todos.reduce((pre, todo) =&gt; pre + (todo.done ? 1 : 0), 0)
    },
    isAll: {
      get() {
        return this.doneTotal === this.total &amp;&amp; this.total &gt; 0
      },
      set(value) {
        // 子传父通信（旧方法）
        // this.checkAllTodo(value)

        // 触发事件：$emit
        this.$emit(&#39;checkAllTodo&#39;, value)
      }
    }
  },
  methods: {
    clearAll() {
      // 子传父通信（旧方法）
      // this.clearAllTodo()

      // 触发事件：$emit
      this.$emit(&#39;clearAllTodo&#39;)
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-10-4-">2.10.4 应用：全局事件总线</h4>
          <blockquote>
            <p>需求：将<code>checkTodo</code>、<code>deleteTodo</code>函数由props属性传递改造成全局事件总线，影响：main.js、App、MyList、MyItem</p>
          </blockquote>
          <h5 id="-main-js">入口文件：main.js</h5>
          <ol>
            <li>
              <p>设置全局事件总线</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//引入Vue
import Vue from &#39;vue&#39;
//引入App
import App from &#39;./App.vue&#39;
//关闭Vue的生产提示
Vue.config.productionTip = false

//创建vm
new Vue({
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    // 设置全局事件总线
    beforeCreate() {
        Vue.prototype.$bus = this
    },
})
</code></pre>
            </li>
          </ol>
          <h5 id="-app-vue">父组件：App.vue</h5>
          <ol>
            <li><p>接收数据：在<code>mounted()</code>中使用<code>$bus.$on</code>挂载事件</p></li>
            <li>
              <p>解绑事件：在beforeDestory()中使用<code>$bus.$off</code>释放事件名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- 使用全局事件总线，绑定checkTodo 和 deleteTodo函数，无需再使用props属性及自定义事件--&gt;
&lt;!--&lt;MyList :todos=&quot;todos&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt;--&gt;
&lt;MyList :todos=&quot;todos&quot; /&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">mounted() {
  this.$bus.$on(&#39;checkTodo&#39;, this.checkTodo)
  this.$bus.$on(&#39;deleteTodo&#39;, this.deleteTodo)
},
beforeDestroy() {
  this.$bus.$off(&#39;checkTodo&#39;)
  this.$bus.$off(&#39;deleteTodo&#39;)
}
</code></pre>
            </li>
          </ol>
          <h5 id="-mylist-vue">子组件：MyList.vue</h5>
          <ol>
            <li><p>无需再用 props 给 MyItem 孙组件传递todo、checkTodo、deleteTodo</p></li>
            <li>
              <p>无需再用 props 接受父组件传递过来的 checkTodo、deleteTodo 函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul class=&quot;todo-main&quot;&gt;
    &lt;!-- 无需再用 props 给 MyItem 孙组件传递todo、checkTodo、deleteTodo --&gt;
    &lt;!-- &lt;MyItem v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :todo=&quot;todoObj&quot; :checkTodo=&quot;checkTodo&quot; :deleteTodo=&quot;deleteTodo&quot; /&gt; --&gt;
    &lt;MyItem v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :todo=&quot;todoObj&quot; /&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
import MyItem from &#39;./MyItem&#39;

export default {
  name: &#39;MyList&#39;,
  components: { MyItem },
  props: [&#39;todos&#39;]    // 无需再接收checkTodo、deleteTodo
}
&lt;/script&gt;

&lt;style scoped&gt;
/*main*/
.todo-main {
  margin-left: 0px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding: 0px;
}

.todo-empty {
  height: 40px;
  line-height: 40px;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding-left: 5px;
  margin-top: 10px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-myitem-vue">孙组件：MyItem.vue</h5>
          <ol>
            <li><p>无需再用 props 接受父组件传递过来的 checkTodo、deleteTodo 函数</p></li>
            <li>
              <p>使用全局事件总线<code>this.$bus.$emit</code>挂载 checkTodo、deleteTodo 函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;script&gt;
export default {
  name: &#39;MyItem&#39;,
  //声明接收todo
  props: [&#39;todo&#39;],
  methods: {
    handleCheck(id) {
      // 子传父通信（旧方法）
      // this.checkTodo(id)

      // 全局事件总线：this.$bus.$emit 挂载函数
      this.$bus.$emit(&#39;checkTodo&#39;, id)
    },
    handleDelete(id) {
      if (confirm(&#39;确定删除吗？&#39;)) {
        // 子传父通信（旧方法）
        // this.deleteTodo(id)

        // 全局事件总线：this.$bus.$emit 挂载函数
        this.$bus.$emit(&#39;deleteTodo&#39;, id)
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-10-5-">2.10.5 应用：消息订阅与发布</h4>
          <blockquote>
            <p>需求：将<code>deleteTodo</code>函数改造成pubsub形式，影响：App、MyItem</p>
          </blockquote>
          <h5 id="-app-vue">父组件：App.vue</h5>
          <ol>
            <li>
              <p>安装并导入<code>pubsub-js</code></p>
            </li>
            <li><p>在<code>mounted()</code>中使用<code>pubsub.subscribe</code>订阅deleteTodo函数</p></li>
            <li>
              <p>在<code>beforeDestroy()</code>中使用<code>pubsub.unsubscribe</code>取消订阅deleteTodo函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div id=&quot;root&quot;&gt;
    &lt;div class=&quot;todo-container&quot;&gt;
      &lt;div class=&quot;todo-wrap&quot;&gt;
        &lt;MyHeader @addTodo=&quot;addTodo&quot; /&gt;
        &lt;MyList :todos=&quot;todos&quot; /&gt;
        &lt;MyFooter :todos=&quot;todos&quot; @checkAllTodo=&quot;checkAllTodo&quot; @clearAllTodo=&quot;clearAllTodo&quot; /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 引入pubsub-js
import pubsub from &#39;pubsub-js&#39;
import MyHeader from &#39;./components/MyHeader&#39;
import MyList from &#39;./components/MyList&#39;
import MyFooter from &#39;./components/MyFooter&#39;

export default {
  name: &#39;App&#39;,
  components: { MyHeader, MyList, MyFooter },
  data() {
    return {
      todos: JSON.parse(localStorage.getItem(&#39;todos&#39;)) || []
    }
  },
  methods: {
    // 添加一个todo
    addTodo(todoObj) {
      this.todos.unshift(todoObj)
    },
    // 勾选or取消勾选一个todo
    checkTodo(id) {
      this.todos.forEach(todo =&gt; {
        if (todo.id === id) todo.done = !todo.done
      })
    },
    // 删除一个todo（注意：由于使用了pubsub库，第一个参数默认是msgName，但如果不用的话会报错，所以用&quot;_&quot;占位）
    deleteTodo(_, id) {
      this.todos = this.todos.filter(todo =&gt; todo.id !== id)
    },
    // 全选or取消全选
    checkAllTodo(done) {
      this.todos.forEach(todo =&gt; {
        todo.done = done
      })
    },
    // 清除所有已经完成的todo
    clearAllTodo() {
      this.todos = this.todos.filter(todo =&gt; {
        return !todo.done
      })
    }
  },
  watch: {
    todos: {
      deep: true,
      handler(value) {
        localStorage.setItem(&#39;todos&#39;, JSON.stringify(value))
      }
    }
  },
  mounted() {
    this.$bus.$on(&#39;checkTodo&#39;, this.checkTodo)
    // 订阅deleteTodo函数
    this.pubId = pubsub.subscribe(&#39;deleteTodo&#39;, this.deleteTodo)
  },
  beforeDestroy() {
    this.$bus.$off(&#39;checkTodo&#39;)
    // 取消订阅deleteTodo函数
    pubsub.unsubscribe(this.pubId)
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-myitem-vue">孙组件：MyItem.vue</h5>
          <ol>
            <li>
              <p>安装并导入<code>pubsub-js</code></p>
            </li>
            <li>
              <p>在<code>method()</code>对应的函数中使用<code>pubsub.publish</code>发布deleteTodo函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;script&gt;
import pubsub from &#39;pubsub-js&#39;
export default {
  name: &#39;MyItem&#39;,
  //声明接收todo
  props: [&#39;todo&#39;],
  methods: {
    //勾选or取消勾选
    handleCheck(id) {
      // 子传父通信（旧方法）：通知App组件将对应的todo对象的done值取反
      // this.checkTodo(id)
      // 全局事件总线：this.$bus.$emit 挂载函数
      this.$bus.$emit(&#39;checkTodo&#39;, id)
    },
    //删除
    handleDelete(id) {
      if (confirm(&#39;确定删除吗？&#39;)) {
        // 子传父通信（旧方法）：通知App组件将对应的todo对象删除
        // this.deleteTodo(id)

        // 全局事件总线：this.$bus.$emit 挂载函数
        // this.$bus.$emit(&#39;deleteTodo&#39;, id)

        // 消息订阅与发布：pubsub.publish
        pubsub.publish(&#39;deleteTodo&#39;, id)
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-10-6-nexttick">2.10.6 应用：nextTick</h4>
          <blockquote>
            <p>需求：为每项todo数据添加“编辑按钮”，输入完毕失去焦点后即编辑完成，影响：App、MyItem</p>
          </blockquote>
          <h5 id="-app-vue">父组件：App.vue</h5>
          <ol>
            <li>
              <p>定义更新数据的函数<code>updateTodo</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">updateTodo(id, title) {
  this.todos.forEach(todo =&gt; {
    if (todo.id === id) todo.title = title
  })
},
</code></pre>
            </li>
            <li>
              <p>使用全局事件总线，在mounted()与beforeDestroy()中挂载、解绑事件</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">mounted() {
  this.$bus.$on(&#39;checkTodo&#39;, this.checkTodo)
  // 挂载updateTodo
  this.$bus.$on(&#39;updateTodo&#39;, this.updateTodo)
  this.pubId = pubsub.subscribe(&#39;deleteTodo&#39;, this.deleteTodo)
},
beforeDestroy() {
  this.$bus.$off(&#39;checkTodo&#39;)
  // 解绑updateTodo
  this.$bus.$off(&#39;updateTodo&#39;)
  pubsub.unsubscribe(this.pubId)
}
</code></pre>
            </li>
            <li>
              <p>添加对应的css样式</p>
              <pre class="prettyprint linenums:0"><code class="lang-css">.btn-edit {
  color: #fff;
  background-color: skyblue;
  border: 1px solid rgb(103, 159, 180);
  margin-right: 5px;
}
</code></pre>
            </li>
          </ol>
          <h5 id="-myitem-vue">孙组件：MyItem.vue</h5>
          <ol>
            <li>
              <p>为todo数据添加<code>isEdit</code>属性（布尔值），根据<code>v-show=&quot;!todo.isEdit&quot;</code>判断是否要显示当前元素</p>
              <p>1）使用<code>bject.prototype.hasOwnProperty</code>判断todo是否有<code>isEdit</code>属性，如果有，则隐藏原有的<code>&lt;span&gt;</code>，并显示输入框<code>&lt;input&gt;</code></p>
              <p>2）如果没有，则用<code>$set</code>为todo添加<code>isEdit</code>为true的属性</p>
            </li>
            <li>
              <p>点击编辑按钮<code>&lt;button&gt;</code>后，隐藏编辑按钮，显示输入框<code>&lt;input&gt;</code>并自动获取焦点，但由于<code>&lt;input&gt;</code>获取焦点的动作需要在DOM更新后完成，此处需要借助<code>this.$nextTick(回调函数)</code></p>
            </li>
            <li>
              <p>在输入框<code>&lt;input&gt;</code>编辑完毕后，鼠标移开失去焦点，认为编辑完毕，页面恢复原样，重新显示<code>&lt;span&gt;</code>和编辑按钮<code>&lt;button&gt;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;li&gt;
    &lt;label&gt;
      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot; /&gt;
      &lt;!-- 添加显示条件v-show，只有处于非编辑状态时，才会显示span --&gt;
      &lt;span v-show=&quot;!todo.isEdit&quot;&gt;{{todo.title}}&lt;/span&gt;
      &lt;!-- 新增编辑输入框input，设置显示条件，定义失去焦点即完成编辑的函数，添加ref --&gt;
      &lt;!-- 注意：这里可以使用$event来传递事件参数 --&gt;
      &lt;input
        type=&quot;text&quot;
        v-show=&quot;todo.isEdit&quot;
        :value=&quot;todo.title&quot;
        @blur=&quot;handleBlur(todo,$event)&quot;
        ref=&quot;inputTitle&quot;
      /&gt;
    &lt;/label&gt;
    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;
    &lt;!-- 新增编辑按钮，设置显示条件，定义点击后编辑函数 --&gt;
    &lt;button v-show=&quot;!todo.isEdit&quot; class=&quot;btn btn-edit&quot; @click=&quot;handleEdit(todo)&quot;&gt;编辑&lt;/button&gt;
  &lt;/li&gt;
&lt;/template&gt;

&lt;script&gt;
import pubsub from &#39;pubsub-js&#39;
export default {
  name: &#39;MyItem&#39;,
  props: [&#39;todo&#39;],
  methods: {
    handleCheck(id) {
      this.$bus.$emit(&#39;checkTodo&#39;, id)
    },
    handleDelete(id) {
      if (confirm(&#39;确定删除吗？&#39;)) {
        pubsub.publish(&#39;deleteTodo&#39;, id)
      }
    },

    // 编辑
    handleEdit(todo) {
      // 先判断todo身上是否已经有isEdit属性
      // Object.prototype.hasOwnProperty()返回一个布尔值，指示对象自身属性中是否具有指定的属性
      // if (todo.hasOwnProperty(&#39;isEdit&#39;)) {   // 这样写ESlint会报错
      if (Object.prototype.hasOwnProperty.call(todo, &#39;isEdit&#39;)) {
        todo.isEdit = true
      } else {
        // 注意：需要用$set给todos追加属性，才能是响应式的
        this.$set(todo, &#39;isEdit&#39;, true)
      }
      // 让input框获取焦点，$nextTick中的回调函数会在DOM节点更新后执行（用定时器setTimeout也能实现）
      this.$nextTick(function() {
        // 如果不加$nextTick,Vue会等handleEdit中的所有代码执行完毕后再渲染模板，而此时input框还没出来，所以无法获取焦点
        this.$refs.inputTitle.focus()
      })
    },

    //失去焦点回调（真正执行修改逻辑）
    handleBlur(todo, e) {
      // 注意：这里之所以不用$set，是因为肯定是先点击handleEdit才能是handleBlur，必然已经有isEdit属性
      todo.isEdit = false
      if (!e.target.value.trim()) return alert(&#39;输入不能为空！&#39;)
      this.$bus.$emit(&#39;updateTodo&#39;, todo.id, e.target.value)
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="2-10-7-">2.10.7 应用：动画效果</h4>
          <blockquote>
            <p>需求：为todo数据项添加进入效果，影响：MyList</p>
          </blockquote>
          <h5 id="-mylist-vue">子组件：MyList.vue</h5>
          <ol>
            <li>
              <p>多个元素需要过度，用<code>&lt;transition-group&gt;</code>包裹要过度的元素，配置name属性，且每个元素都要指定key值</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul class=&quot;todo-main&quot;&gt;
    &lt;!-- 包裹MyItem --&gt;
    &lt;transition-group name=&quot;todo&quot; appear&gt;
      &lt;MyItem v-for=&quot;todoObj in todos&quot; :key=&quot;todoObj.id&quot; :todo=&quot;todoObj&quot; /&gt;
    &lt;/transition-group&gt;
  &lt;/ul&gt;
&lt;/template&gt;
</code></pre>
            </li>
            <li>
              <p>编写css动画样式</p>
              <pre class="prettyprint linenums:0"><code class="lang-css">.todo-enter-active {
  animation: atguigu 0.5s linear;
}

.todo-leave-active {
  animation: atguigu 0.5s linear reverse;
}

@keyframes atguigu {
  from {
    transform: translateX(100%);
  }
  to {
    transform: translateX(0px);
  }
}
</code></pre>
            </li>
          </ol>
          <hr />
          <h2 id="-3-vue-">第3章 Vue配置代理</h2>
          <blockquote>
            <p>配置代理服务器：服务器之间通信不受同源策略限制，只有浏览器和服务器之间通信受限</p>
          </blockquote>
          <h3 id="3-1-vue-config-js">3.1 <a href="https://cli.vuejs.org/zh/config/#devserver-proxy">vue.config.js</a></h3>
          <blockquote>
            <p>修改vue.config.js后要重启</p>
          </blockquote>
          <h4 id="3-1-1-1">3.1.1 配置方法1</h4>
          <ol>
            <li>
              <p>语法：<code>devServer:{ proxy:&quot;代理目标服务器URL&quot; }</code></p>
            </li>
            <li><p>优点：配置简单，请求资源时直接发给前端（<code>8080</code>）即可</p></li>
            <li><p>缺点：不能配置多个代理，不能灵活的控制请求是否走代理</p></li>
            <li>
              <p>注意：当请求了前端不存在的资源时，请求才会转发给服务器 ，否则会优先匹配public文件夹中的静态资源</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">module.exports = {
  pages: {
    index: {
      //入口
      entry: &#39;src/main.js&#39;,
    },
  },
  lintOnSave: false, //关闭语法检查

  // 开启代理服务器（方式一）：只能控制单个服务器，且只有public文件夹中找不到资源时才会请求代理服务器
  devServer: {
    proxy: &#39;http://localhost:5000&#39;
  },
</code></pre>
            </li>
          </ol>
          <h4 id="3-2-2-2">3.2.2 配置方法2</h4>
          <ol>
            <li>
              <p>语法：<code>devServer: { proxy: { &#39;/address&#39;: { 参数... }, } }</code></p>
            </li>
            <li>
              <p>参数：</p>
              <p>1）<code>/address</code>：请求资源的前缀，匹配所有以address开头的请求路径</p>
              <p>2）<code>target</code>：代理目标服务器URL</p>
              <p>3）<code>pathRewrite</code>：用于重写路径，否则请求服务器URL中会带有/address，路径错误；如：pathRewrite: { &#39;^/address&#39;: &#39;&#39; }</p>
              <p>4）<code>ws</code>: true；用于支持websocket</p>
              <p>5）<code>changeOrigin</code>：布尔值，用于控制请求头中的host值</p>
              <ul>
                <li>ture(默认)：谎称与服务器同源URL</li>
                <li>false：真实URL</li>
              </ul>
            </li>
            <li><p>优点：可以配置多个代理，且可以灵活的控制请求是否走代理</p></li>
            <li>
              <p>缺点：配置略微繁琐，请求资源时必须加前缀</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">module.exports = {
  pages: {
    index: {
      //入口
      entry: &#39;src/main.js&#39;,
    },
  },
  lintOnSave: false, //关闭语法检查

  //开启代理服务器（方式二）
  devServer: {
    proxy: {
      &#39;/atguigu&#39;: {
        target: &#39;http://localhost:5000&#39;,
        pathRewrite: { &#39;^/atguigu&#39;: &#39;&#39; }, // 重写路径，不然后端服务器路径错误
        // ws: true, //用于支持websocket
        // changeOrigin: true //用于控制请求头中的host值，如果为false则如实回答，如果是ture(默认)则谎称与服务器同源
      },
      &#39;/demo&#39;: {
        target: &#39;http://localhost:5001&#39;,
        pathRewrite: { &#39;^/demo&#39;: &#39;&#39; },
        // ws: true, //用于支持websocket
        // changeOrigin: true //用于控制请求头中的host值
      },
    },
  },
}
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="3-2-ajax-">3.2 发送Ajax请求</h3>
          <ol>
            <li>
              <p>发送ajax请求的方法</p>
              <p>1）XHR</p>
              <p>2）jQuery</p>
              <p>3）axios：推荐</p>
              <p>4）fetch：兼容性不好</p>
              <p>5）vue-resource：vue插件，用Vue.use(...)</p>
            </li>
            <li>
              <p>安装：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i axios
</code></pre>
            </li>
            <li>
              <p>解决跨域问题的方法</p>
              <p>1）CORS：后端开发人员添加响应头</p>
              <p>2）jsonp：只有GET请求</p>
              <p>3）配置代理服务器：服务器之间通信不受同源策略限制，只有浏览器和服务器之间通信受限</p>
            </li>
            <li>
              <p>前端axios请求写法：父组件App.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;getStudents&quot;&gt;获取学生信息&lt;/button&gt;
    &lt;button @click=&quot;getCars&quot;&gt;获取汽车信息&lt;/button&gt;
  &lt;/div&gt;
  &lt;!-- 
    开启代理服务器：devServer.proxy（需要在vue.config.js中配置）
    官方文档：https://cli.vuejs.org/zh/config/#devserver-proxy
  --&gt;
&lt;/template&gt;

&lt;script&gt;
import axios from &#39;axios&#39;
export default {
  name: &#39;App&#39;,
  methods: {
    getStudents() {
      axios.get(&#39;http://localhost:8080/atguigu/students&#39;).then(
        response =&gt; {
          console.log(&#39;请求成功了&#39;, response.data)
        },
        error =&gt; {
          console.log(&#39;请求失败了&#39;, error.message)
        }
      )
    },
    getCars() {
      axios.get(&#39;http://localhost:8080/demo/cars&#39;).then(
        response =&gt; {
          console.log(&#39;请求成功了&#39;, response.data)
        },
        error =&gt; {
          console.log(&#39;请求失败了&#39;, error.message)
        }
      )
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="3-3-github-">3.3 案例：Github用户搜索</h3>
          <blockquote>
            <p>使用bootstrap框架搭建，需要在index.html中引入css样式</p>
            <p>API地址：<a href="https://api.github.com/search/users?q=username">https://api.github.com/search/users?q=username</a></p>
          </blockquote>
          <h4 id="3-3-1-axios">3.3.1 使用Axios</h4>
          <ol>
            <li>
              <p>子组件：Search.vue，搜索框</p>
              <p>1）全局事件总线：<code>$bus.$emit</code>挂载 updateListData，传递 <code>{ isLoading: true, errMsg: &#39;&#39;, users: [], isFirst: false }</code></p>
              <p>2）axios发送GET请求</p>
              <ul>
                <li>成功：<code>$bus.$emit</code>挂载 updateListData，传递 <code>{ isLoading: false, errMsg: &#39;&#39;, users: response.data.items }</code></li>
                <li>失败：<code>$bus.$emit</code>挂载 updateListData，传递 <code>{ isLoading: false, errMsg: error.message, users: [] }</code></li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;section class=&quot;jumbotron&quot;&gt;
    &lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;
    &lt;div&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot; v-model=&quot;keyWord&quot; /&gt;&amp;nbsp;
      &lt;button @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
import axios from &#39;axios&#39;
export default {
  name: &#39;Search&#39;,
  data() {
    return {
      keyWord: &#39;&#39;
    }
  },
  methods: {
    searchUsers() {
      // 请求前更新List的数据：正在加载、取消欢迎词
      this.$bus.$emit(&#39;updateListData&#39;, { isLoading: true, errMsg: &#39;&#39;, users: [], isFirst: false })
      // 模板字符串
      axios.get(`https://api.github.com/search/users?q=${this.keyWord}`).then(
        response =&gt; {
          console.log(&#39;请求成功了&#39;)
          //请求成功后更新List的数据
          this.$bus.$emit(&#39;updateListData&#39;, { isLoading: false, errMsg: &#39;&#39;, users: response.data.items })
        },
        error =&gt; {
          //请求后更新List的数据
          this.$bus.$emit(&#39;updateListData&#39;, { isLoading: false, errMsg: error.message, users: [] })
        }
      )
    }
  }
}
&lt;/script&gt;

</code></pre>
            </li>
            <li>
              <p>子组件：List.vue，初始化时显示欢迎词，展示搜索结果</p>
              <p>1）data()中创建<code>info</code>对象：包含isFirst用于控制欢迎词，以及承接Search.vue传递过来的<code>updateListData</code>数据</p>
              <ul>
                <li>isFirst：true，是否初次展示</li>
                <li>isLoading：false，是否加载中</li>
                <li>errMsg：错误信息</li>
                <li>users：[]，用户数组</li>
              </ul>
              <p>2）全局事件总线<code>$bus.$on</code>，接受Search.vue传递过来的<code>updateListData</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;!-- 展示用户列表 --&gt;
    &lt;div v-show=&quot;info.users.length&quot; class=&quot;card&quot; v-for=&quot;user in info.users&quot; :key=&quot;user.login&quot;&gt;
      &lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt;
        &lt;img :src=&quot;user.avatar_url&quot; style=&quot;width: 100px&quot; /&gt;
      &lt;/a&gt;
      &lt;p class=&quot;card-text&quot;&gt;{{user.login}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;!-- 展示欢迎词 --&gt;
    &lt;h1 v-show=&quot;info.isFirst&quot;&gt;欢迎使用！&lt;/h1&gt;
    &lt;!-- 展示加载中 --&gt;
    &lt;h1 v-show=&quot;info.isLoading&quot;&gt;加载中....&lt;/h1&gt;
    &lt;!-- 展示错误信息 --&gt;
    &lt;h1 v-show=&quot;info.errMsg&quot;&gt;{{info.errMsg}}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;List&#39;,
  data() {
    return {
      info: {
        isFirst: true, //是否初次展示
        isLoading: false, //是否加载中
        errMsg: &#39;&#39;, //错误信息
        users: []
      }
    }
  },
  mounted() {
    this.$bus.$on(&#39;updateListData&#39;, dataObj =&gt; {
      // 扩展运算符：可以展开对象，如果属性重名，以后面的为主
      this.info = { ...this.info, ...dataObj }
    })
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.album {
  min-height: 50rem;
  padding-top: 3rem;
  padding-bottom: 3rem;
  background-color: #f7f7f7;
}

.card {
  float: left;
  width: 33.333%;
  padding: 0.75rem;
  margin-bottom: 2rem;
  border: 1px solid #efefef;
  text-align: center;
}

.card &gt; img {
  margin-bottom: 0.75rem;
  border-radius: 100px;
}

.card-text {
  font-size: 85%;
}
&lt;/style&gt;
</code></pre>
            </li>
            <li>
              <p>父组件：App.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;!-- 注意：由于index.html中已有&lt;div id=&quot;app&quot;&gt;，所以要避免重名 --&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Search /&gt;
    &lt;List /&gt;
  &lt;/div&gt;
  &lt;!-- 注意：本项目用到了bootstrap，需要放在public/css/bootstrap.css，然后再index.html中引入 --&gt;
&lt;/template&gt;

&lt;script&gt;
import Search from &#39;./components/Search&#39;
import List from &#39;./components/List&#39;
export default {
  name: &#39;App&#39;,
  components: { Search, List }
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>入口文件：main.js</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//引入Vue
import Vue from &#39;vue&#39;
//引入App
import App from &#39;./App.vue&#39;
//关闭Vue的生产提示
Vue.config.productionTip = false

//创建vm
new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
  // 全局事件总线
  beforeCreate() {
    Vue.prototype.$bus = this
  },
})
</code></pre>
            </li>
          </ol>
          <h4 id="3-3-2-vue-resource">3.3.2 使用vue-resource</h4>
          <ol>
            <li>
              <p>子组件：Search.vue，将<code>axios</code>替换为<code>this.$http</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;section class=&quot;jumbotron&quot;&gt;
    &lt;h3 class=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;
    &lt;div&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot; v-model=&quot;keyWord&quot; /&gt;&amp;nbsp;
      &lt;button @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Search&#39;,
  data() {
    return {
      keyWord: &#39;&#39;
    }
  },
  methods: {
    searchUsers() {
      this.$bus.$emit(&#39;updateListData&#39;, { isLoading: true, errMsg: &#39;&#39;, users: [], isFirst: false })
      // axios.get(`https://api.github.com/search/users?q=${this.keyWord}`).then(
      this.$http.get(`https://api.github.com/search/users?q=${this.keyWord}`).then(
        response =&gt; {
          console.log(&#39;请求成功了&#39;)
          this.$bus.$emit(&#39;updateListData&#39;, { isLoading: false, errMsg: &#39;&#39;, users: response.data.items })
        },
        error =&gt; {
          this.$bus.$emit(&#39;updateListData&#39;, { isLoading: false, errMsg: error.message, users: [] })
        }
      )
    }
  }
}
&lt;/script&gt;

</code></pre>
            </li>
            <li>
              <p>入口文件：main.js</p>
              <p>1）引入插件：<code>import vueResource from &#39;vue-resource&#39;</code></p>
              <p>2）使用插件：<code>Vue.use(vueResource)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
//引入插件
import vueResource from &#39;vue-resource&#39;
Vue.config.productionTip = false
//使用插件
Vue.use(vueResource)

new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
  beforeCreate() {
    Vue.prototype.$bus = this
  },
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h2 id="-4-vuex">第4章 Vuex</h2>
          <blockquote>
            <p><a href="https://github.com/vuejs/vuex">Vuex</a>：在Vue中实现集中式状态（数据）管理的一个Vue插件，适用于任意组件间通信。</p>
          </blockquote>
          <h3 id="4-1-vuex-">4.1 Vuex简介</h3>
          <ol>
            <li>
              <p>安装：</p>
              <p>1）vue2中，要用vuex3版本</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i vuex@3
</code></pre>
              <p>2）vue3中，要用vuex4版本</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i vuex@4
</code></pre>
            </li>
            <li><p>应用场景：多个组件需要共享数据时</p></li>
            <li>
              <p>工作流：</p>
              <p><img src="./src/vuex.png" alt="vuex" /></p>
            </li>
          </ol>
          <hr />
          <h3 id="4-2-">4.2 搭建环境</h3>
          <ol>
            <li>
              <p><code>store/index.js</code>：用于创建Vuex中最为核心的store</p>
              <p>1）引入</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 该文件用于创建Vuex中最为核心的store
import Vue from &#39;vue&#39;
// 引入Vuex
import Vuex from &#39;vuex&#39;
// 应用Vuex插件
Vue.use(Vuex)
</code></pre>
              <p>2）准备</p>
              <ul>
                <li><code>actions</code>对象（服务员）：用于响应组件中的动作</li>
                <li><code>mutations</code>对象（后厨）：用于操作数据（state）</li>
                <li><code>state</code>对象（菜）：用于存储数据</li>
                <li><code>getters</code>对象：用于将state中的数据进行加工</li>
              </ul>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 准备actions：用于响应组件中的动作
const actions = {...}
// 准备mutations：用于操作数据（state）
const mutations = {...}
// 准备state：用于存储数据
const state = {...}
//准备getters：用于将state中的数据进行加工
const getters = {...}
</code></pre>
              <p>3）暴露<code>store</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 创建并暴露store
export default new Vuex.Store({
    actions,
    mutations,
    state,
    getters
})
</code></pre>
            </li>
            <li>
              <p><code>main.js</code>：入口文件</p>
              <p>1）引入<code>vue-resource</code>插件</p>
              <p>2）引入<code>store</code>：如果store文件夹下只有index.js，可以将<code>.store/index.js</code>简写为<code>./store</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
// 引入插件
import vueResource from &#39;vue-resource&#39;
// 引入store（如果store文件夹下只有index.js，可以简写为./store）
import store from &#39;./store&#39;

Vue.config.productionTip = false
// 使用插件
Vue.use(vueResource)

// 创建vm
new Vue({
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    // 挂载store，用于管理vuex中的三个对象
    store,
    beforeCreate() {
        Vue.prototype.$bus = this
    }
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="4-3-api">4.3 核心API</h3>
          <h4 id="4-3-1-store">4.3.1 $store</h4>
          <blockquote>
            <p>子组件 components.vue 使用<code>$store</code>访问Vuex中的对象和方法</p>
          </blockquote>
          <ol>
            <li>
              <p><code>$store.state.xxx</code>：调用<code>state</code>对象中的数据</p>
            </li>
            <li>
              <p><code>$store.dispatch</code>方法：调用<code>actions</code>对象中定义的函数</p>
            </li>
            <li>
              <p><code>$store.commit</code>方法：跳过actions，直接调用<code>mutations</code>对象中定义的函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;
&lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
&lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;
&lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">methods: {
  increment() {
    // 使用commit方法，绕过actions，直接调用mutations中的函数
    this.$store.commit(&#39;JIA&#39;, this.n)
  },
  decrement() {
    this.$store.commit(&#39;JIAN&#39;, this.n)
  },
  incrementOdd() {
    // 使用dispatch方法，通过actions，调用mutations中的函数
    this.$store.dispatch(&#39;jiaOdd&#39;, this.n)
  },
  incrementWait() {
    this.$store.dispatch(&#39;jiaWait&#39;, this.n)
  }
},
</code></pre>
            </li>
          </ol>
          <h4 id="4-3-2-actions">4.3.2 actions</h4>
          <blockquote>
            <p><code>actions</code>对象：用于响应组件中的动作，可以包含异步代码（定时器，ajax等）</p>
          </blockquote>
          <ol>
            <li>
              <p>context：</p>
              <p>1）在action里面定义的函数第一个参数默认是<code>context</code>，如<code>function(context,value)</code>，相当于迷你版的store</p>
              <p>2）context上面有<code>commit</code>、<code>dispatch</code>、<code>state</code>、<code>getters</code>、<code>rootGetters</code>、<code>rootState</code>等</p>
            </li>
            <li><p>state：在<code>context</code>上可使用<code>state</code>属性访问数据</p></li>
            <li>
              <p>commit：在<code>context</code>上可使用<code>commit</code>方法调用<code>mutations</code>对象中定义的函数，如<code>context.commit(functionName, value)</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const actions = {
  jiaOdd(context, value) {
    console.log(&#39;actions中的jiaOdd被调用了&#39;)
    if (context.state.sum % 2) {
      context.commit(&#39;JIA&#39;, value)
    }
  },
  jiaWait(context, value) {
    console.log(&#39;actions中的jiaWait被调用了&#39;)
    setTimeout(() =&gt; {
      context.commit(&#39;JIA&#39;, value)
    }, 500)
  },
}
</code></pre>
            </li>
            <li>
              <p>dispatch：在<code>context</code>上可使用<code>dispatch</code>方法，用于actions中的函数嵌套（接力），如果一个函数逻辑太复杂，可以分很多函数写</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const actions = {
  func1(context, value) {
    console.log(&#39;处理了100行代码...&#39;)
    // dispatch，让func2继续处理
    context.dispatch(&#39;func2&#39;, value)
  },
  func2(context, value) {
    console.log(&#39;处理了100行代码...&#39;)
    // dispatch，让func3继续处理
    context.dispatch(&#39;func3&#39;, value)
  },
  func3(context, value) {
    console.log(&#39;处理了100行代码...&#39;)
    // dispatch，让func4继续处理
    context.dispatch(&#39;func4&#39;, value)
  },
}
</code></pre>
            </li>
          </ol>
          <h4 id="4-3-3-mutations">4.3.3 mutations</h4>
          <blockquote>
            <p><code>mutations</code>对象：用于操作数据（state），可以用开发者工具调试</p>
          </blockquote>
          <ol>
            <li>
              <p>里面定义的函数第一个参数默认是<code>state</code>，第二个参数是接受子组件传递过来的参数，可以命名为<code>value</code></p>
            </li>
            <li>
              <p>不要在mutations里发送ajax请求，不能写异步代码，只能单纯的操作<code>state</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const mutations = {
  JIA(state, value) {
    console.log(&#39;mutations中的JIA被调用了&#39;)
    state.sum += value
  },
  JIAN(state, value) {
    console.log(&#39;mutations中的JIAN被调用了&#39;)
    state.sum -= value
  },
}
</code></pre>
            </li>
          </ol>
          <h4 id="4-3-4-state">4.3.4 state</h4>
          <blockquote>
            <p><code>state</code>对象：用于存储数据，类似于data()的功能</p>
          </blockquote>
          <ol>
            <li>
              <p>Vuex文件 store/index.js：定义state</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const state = {
  sum:0, //当前的和
  school:&#39;尚硅谷&#39;,
  subject:&#39;前端&#39;
}
</code></pre>
            </li>
            <li>
              <p>子组件 Count.vue：通过<code>$store.state.xxx</code>访问数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h1&gt;当前求和为：{{$store.state.sum}}&lt;/h1&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="4-3-5-getters">4.3.5 getters</h4>
          <blockquote>
            <p><code>gettes对象</code>：用于将state中的数据进行加工，包含多个用于返回数据的函数，可接受<code>state</code>参数，类似于computed计算属性</p>
          </blockquote>
          <ol>
            <li>
              <p>Vuex文件 store/index.js：定义getters</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const getters = {
    bigSum(state){
        return state.sum * 10
    }
}
</code></pre>
            </li>
            <li>
              <p>子组件 Count.vue：通过<code>$store.getters.xxx</code>访问其中的函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h3&gt;当前求和放大10倍为：{{$store.getters.bigSum}}&lt;/h3&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="4-3-6-mapstate-mapgetters">4.3.6 mapState/mapGetters</h4>
          <blockquote>
            <p>用于简化子组件从store中读取<code>state</code>数据和<code>getters</code>方法，令插值语法更加简洁，效果等同于computed计算属性</p>
          </blockquote>
          <ol>
            <li>
              <p><code>mapState</code>：生成计算属性，从state中读取数据</p>
              <p>1）对象写法：可以自定义名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapState({he:&#39;sum&#39;,xuexiao:&#39;school&#39;,xueke:&#39;subject&#39;})
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 等同于以下写法
computed:{
    sum(){
        return this.$store.state.sum
    },
    school(){
        return this.$store.state.school
    },
    subject(){
        return this.$store.state.subject
    },
}
</code></pre>
              <p>2）数组写法：使用state中定义好的名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
</code></pre>
            </li>
            <li>
              <p><code>mapGetters</code>：生成计算属性，从getters中读取数据</p>
              <p>1）对象写法：可以自定义名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapGetters({bigSum:&#39;bigSum&#39;})
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 等同于以下写法
computed: {
  bigSum() {
    return this.$store.getters.bigSum
  },
}
</code></pre>
              <p>2）数组写法：使用state中定义好的名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapGetters([&#39;bigSum&#39;])
</code></pre>
            </li>
            <li>
              <p>子组件 Count.vue</p>
              <p>1）引入<code>mapState</code>和<code>mapGetters</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import {mapState,mapGetters} from &#39;vuex&#39;
</code></pre>
              <p>2）在计算属性<code>computed</code>中定义<code>mapState</code>和<code>mapGetters</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">computed:{
    // mapState：生成计算属性，从state中读取数据
    // 对象写法：可以自定义名称
    // ...mapState({he:&#39;sum&#39;,xuexiao:&#39;school&#39;,xueke:&#39;subject&#39;}),
    // 数组写法：使用state中定义好的名称
    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),

    // mapGetters：生成计算属性，从getters中读取数据
    // 对象写法：可以自定义名称
    // ...mapGetters({bigSum:&#39;bigSum&#39;})
    // 数组写法：使用state中定义好的名称
    ...mapGetters([&#39;bigSum&#39;])
},
</code></pre>
              <p>3）插值语法渲染元素</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- &lt;h1&gt;当前求和为：{{$store.state.sum}}&lt;/h1&gt; --&gt;
&lt;h1&gt;当前求和为：{{sum}}&lt;/h1&gt;
&lt;!-- &lt;h3&gt;当前求和放大10倍为：{{$store.geters.bigSum}}&lt;/h3&gt; --&gt;
&lt;h3&gt;当前求和放大10倍为：{{bigSum}}&lt;/h3&gt;
&lt;!-- &lt;h3&gt;我在{{$store.school}}，学习{{$store.subject}}&lt;/h3&gt; --&gt;
&lt;h3&gt;我在{{school}}，学习{{subject}}&lt;/h3&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="4-3-7-mapmutations-mapactions">4.3.7 mapMutations/mapActions</h4>
          <blockquote>
            <p>用于简化子组件从store中读取<code>mutations</code>和<code>actions</code>方法，令插值语法更加简洁，效果等同于methods事件处理</p>
          </blockquote>
          <ol>
            <li>
              <p><code>mapMutations</code>：生成对应的方法，方法中会调用<code>commit</code>去联系<code>mutations</code>【注意：需要传参的话，要在插值语法中传递，否则默认传递<code>event</code>】</p>
              <p>1）对象写法：名称与插值语法中使用的名称一致</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapMutations({increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;}),
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 等同于以下写法
methods: {
  increment() {
    this.$store.commit(&#39;JIA&#39;, this.n)
  },
  decrement() {
    this.$store.commit(&#39;JIAN&#39;, this.n)
  },
}
</code></pre>
              <p>2）数组写法：插值语法中的函数名需要与数组中的名称保持一致，即increment改为JIA、decrement改为JIAN</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),
</code></pre>
            </li>
            <li>
              <p><code>mapActions</code>：生成对应的方法，方法中会调用<code>dispatch</code>去联系<code>actions</code>【注意：需要传参的话，要在插值语法中传递，否则默认传递<code>event</code>】</p>
              <p>1）对象写法：名称与插值语法中使用的名称一致</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapActions({ incrementOdd: &#39;jiaOdd&#39;, incrementWait: &#39;jiaWait&#39; })
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 等同于以下写法
methods: {
  incrementOdd() {
    this.$store.dispatch(&#39;jiaOdd&#39;, this.n)
  },
  incrementWait() {
    this.$store.dispatch(&#39;jiaWait&#39;, this.n)
  },
}
</code></pre>
              <p>2）数组写法：插值语法中的函数名需要与数组中的名称保持一致，即incrementOdd改为jiaOdd、incrementWait改为jiaWait</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
</code></pre>
            </li>
            <li>
              <p>子组件 Count.vue</p>
              <p>1）引入<code>mapMutations</code>和<code>mapActions</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import { mapState, mapGetters, mapMutations, mapActions } from &#39;vuex&#39;
</code></pre>
              <p>2）在事件处理<code>methods()</code>中定义<code>mapMutations</code>和<code>mapActions</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">methods: {
  // mapMutations：生成对应的方法，方法中会调用commit去联系mutations
  // 对象写法
  ...mapMutations({ increment: &#39;JIA&#39;, decrement: &#39;JIAN&#39; }),
  // 数组写法
  // ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),

  //mapActions：生成对应的方法，方法中会调用dispatch去联系actions
  // 对象写法
  ...mapActions({ incrementOdd: &#39;jiaOdd&#39;, incrementWait: &#39;jiaWait&#39; })
  // 数组写法
  // ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
},
</code></pre>
              <p>3）插值语法渲染元素：需要传递参数！</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;
&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;
&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;
&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="4-4-">4.4 多组件共享</h3>
          <blockquote>
            <p>多个子组件都可以通过<code>store</code>访问与调用Vuex文件：index.js中的数据和方法。</p>
          </blockquote>
          <ol>
            <li>
              <p>Vuex文件：store/index.js</p>
              <p>1）在 <code>mutations</code> 中添加 <code>ADD_PERSONS</code> 函数</p>
              <p>2）在 <code>state</code> 中添加 <code>personList</code> 数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const mutations = {
  ......
  // 添加add_person函数，接受子组件中传递过来的数据，存入state中的personList
  ADD_PERSON(state, value) {
    console.log(&#39;mutations中的ADD_PERSON被调用了&#39;)
    state.personList.unshift(value)
  },
}

const state = {
  ......
  // 新增personList数据
  personList: [{ id: &#39;001&#39;, name: &#39;张三&#39; }],
}
</code></pre>
            </li>
            <li>
              <p>新增子组件：Person.vue</p>
              <p>1）需求：输入名字，点击按钮新增人员</p>
              <p>2）引入<code>nanoid</code>插件</p>
              <p>3）在<code>computed</code>中引入<code>state</code>里的<code>personList</code>和<code>sum</code>数据</p>
              <p>4）在<code>method</code>中使用<code>commit</code>调用<code>mutations</code>中的<code>ADD_PERSONS</code>函数</p>
              <p>5）插值语法渲染，引入<code>sum</code>、<code>personList</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;人员列表&lt;/h1&gt;
    &lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：{{sum}}&lt;/h3&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot; /&gt;
    &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;{{p.name}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { nanoid } from &#39;nanoid&#39;
export default {
  name: &#39;Person&#39;,
  data() {
    return {
      name: &#39;&#39;
    }
  },
  computed: {
    // 引入state里的personList和sum数据
    personList() {
      return this.$store.state.personList
    },
    sum() {
      return this.$store.state.sum
    }
  },
  methods: {
    // 使用commit调用mutations中的ADD_PERSONS函数
    add() {
      const personObj = { id: nanoid(), name: this.name }
      this.$store.commit(&#39;ADD_PERSON&#39;, personObj)
      this.name = &#39;&#39;
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>原子组件：Count.vue</p>
              <p>1）在<code>mapState</code>中引入新增的<code>personList</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">computed: {
  ...mapState([&#39;sum&#39;, &#39;school&#39;, &#39;subject&#39;, &#39;personList&#39;]),
},
</code></pre>
              <p>2）插值语法渲染，引入新增的<code>personList</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：{{personList.length}}&lt;/h3&gt;
</code></pre>
            </li>
            <li>
              <p>父组件：App.vue</p>
              <p>1）新增组件结构<code>&lt;Person/&gt;</code></p>
              <p>2）引入Person.vue子组件</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;Count/&gt;
        &lt;hr&gt;
        &lt;Person/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Count from &#39;./components/Count&#39;
    import Person from &#39;./components/Person&#39;

    export default {
        name:&#39;App&#39;,
        components:{Count,Person},
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="4-5-">4.5 模块化编码</h3>
          <blockquote>
            <p>将Vuex文件拆分成多个功能模块，让代码更好维护，让多种数据分类更加明确。</p>
            <ul>
              <li>state：<code>this.$store.state.自定义模块名.数据名</code> 或 <code>...mapState(&#39;自定义模块名&#39;,[&#39;数据名1&#39;,&#39;数据名2&#39;,...])</code></li>
              <li>getters：<code>this.$store.getters[&#39;自定义模块名/函数名&#39;]</code> 或 <code>...mapGetters(&#39;自定义模块名&#39;,[&#39;函数名1&#39;,&#39;函数名2&#39;,...])</code></li>
              <li>mutations：<code>this.$store.commit(&#39;自定义模块名/函数名&#39;, 数据)</code> 或 <code>...mapMutations(&#39;自定义模块名&#39;,[&#39;函数名1&#39;,&#39;函数名2&#39;,...])</code></li>
              <li>actions：<code>this.$store.dispatch(&#39;自定义模块名/函数名&#39;, 数据)</code> 或 <code>...mapActions(&#39;自定义模块名&#39;,[&#39;函数名1&#39;,&#39;函数名2&#39;,...])</code></li>
            </ul>
          </blockquote>
          <ol>
            <li>
              <p>Vuex汇总文件：store/index.js</p>
              <p>1）将各组件的actions、mutations、state、getters拆分成不同js模块文件</p>
              <p>2）导入各个模块文件</p>
              <p>3）暴露模块，可自定义名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
// 导入各个模块文件
import countOptions from &#39;./count&#39;
import personOptions from &#39;./person&#39;
Vue.use(Vuex)

export default new Vuex.Store({
  // 暴露模块，可自定义名称
  modules: {
    countAbout: countOptions,
    personAbout: personOptions,
  },
})
</code></pre>
            </li>
            <li>
              <p>Vuex模块文件：count.js、person.js</p>
              <p>1）默认暴露actions、mutations、state、getters等配置项</p>
              <p>2）<code>namespaced</code>：命名空间，可以自定义模块名称，默认为false，开启命名空间：<code>namespaced: true</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">export default {
  // 命名空间：可以自定义模块名称，默认为false
  namespaced: true,
  actions: {
    ......
  },
  mutations: {
    ......
  },
  state: {
    ......
  },
  getters: {
    ......
  },
}
</code></pre>
            </li>
            <li>
              <p>子组件：Count.vue、Person.vue（personAbout、countAbout是自定义的模块名称）</p>
              <p>1）开启命名空间后，组件中读取<code>state</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
</code></pre>
              <p>2）开启命名空间后，组件中读取<code>getters</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//方式一：自己直接读取
this.$store.getters[&#39;personAbout/firstPersonName&#39;]
//方式二：借助mapGetters读取：
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
</code></pre>
              <p>3）开启命名空间后，组件中使用<code>dispatch</code>，调用<code>actions</code>中的函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//方式一：自己直接dispatch
this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)
//方式二：借助mapActions：
...mapActions(&#39;countAbout&#39;,{incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;})
</code></pre>
              <p>4）开启命名空间后，组件中使用<code>commit</code>，调用<code>mutations</code>中的函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//方式一：自己直接commit
this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)
//方式二：借助mapMutations：
...mapMutations(&#39;countAbout&#39;,{increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;}),
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="4-6-">4.6 求和案例</h3>
          <h4 id="4-6-1-vue-">4.6.1 纯Vue版</h4>
          <h5 id="-main-js">入口文件 main.js</h5>
          <ol>
            <li>
              <p>使用 <code>vueResorce</code> 插件</p>
            </li>
            <li>
              <p>挂载全局事件总线</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import vueResource from &#39;vue-resource&#39;
Vue.config.productionTip = false
Vue.use(vueResource)

//创建vm
new Vue({
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    beforeCreate() {
        Vue.prototype.$bus = this
    }
})
</code></pre>
            </li>
          </ol>
          <h5 id="-count-vue">子组件 Count.vue</h5>
          <ol>
            <li><p>设置选择框<code>&lt;select&gt;</code>，让用户选择数字<code>n</code>，注意在绑定的时候需要用<code>v-model.number</code>确保是数值类型的数据</p></li>
            <li>
              <p>设置increment、decrement、incrementOdd、incrementWait函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;当前求和为：{{sum}}&lt;/h1&gt;
    &lt;!-- 注意：将n设置为number格式，不然就是字符串拼接了（或者在value前加冒号） --&gt;
    &lt;select v-model.number=&quot;n&quot;&gt;
      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/select&gt;
    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
    &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;
    &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Count&#39;,
  data() {
    return {
      n: 1, //用户选择的数字
      sum: 0 //当前的和
    }
  },
  methods: {
    increment() {
      this.sum += this.n
    },
    decrement() {
      this.sum -= this.n
    },
    incrementOdd() {
      if (this.sum % 2) {
        this.sum += this.n
      }
    },
    incrementWait() {
      setTimeout(() =&gt; {
        this.sum += this.n
      }, 500)
    }
  }
}
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
button {
  margin-left: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-app-vue">父组件 App.vue</h5>
          <ol>
            <li>
              <p>正常书写：</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;Count/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Count from &#39;./components/Count&#39;
    export default {
        name:&#39;App&#39;,
        components:{Count},
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="4-6-2-vuex-">4.6.2 Vuex原始版</h4>
          <blockquote>
            <p>仅使用store、actions、mutations、state基础API</p>
          </blockquote>
          <h5 id="vuex-index-js">Vuex文件 index.js</h5>
          <ol>
            <li>
              <p>引入并使用 <code>Vuex</code></p>
            </li>
            <li>
              <p>准备<code>actions</code>：用于响应组件中的动作</p>
              <p>1）<code>jiaOdd(context, value)</code>函数：对应子组件中的<code>incrementOdd</code>函数</p>
              <p>2）<code>jiaWait(context, value)</code>函数：对应子组件中的<code>incrementWait</code>函数</p>
            </li>
            <li>
              <p>准备<code>mutations</code>：用于操作数据（state）</p>
              <p>1）<code>JIA(state, value)</code>函数：对应子组件中的<code>increment</code>函数</p>
              <p>2）<code>JIAN(state, value)</code>函数：对应子组件中的<code>decrement</code>函数</p>
            </li>
            <li>
              <p>准备<code>state</code>：用于存储数据</p>
              <p>1）<code>sum</code>：当前的和</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 该文件用于创建Vuex中最为核心的store
import Vue from &#39;vue&#39;
// 引入Vuex
import Vuex from &#39;vuex&#39;
// 应用Vuex插件
Vue.use(Vuex)

// 准备actions：用于响应组件中的动作
// 里面定义的函数第一个参数默认是context，相当于迷你版的store，上面有commit、state等方法和数据
const actions = {
  jiaOdd(context, value) {
    console.log(&#39;actions中的jiaOdd被调用了&#39;)
    if (context.state.sum % 2) {
      context.commit(&#39;JIA&#39;, value)
    }
  },
  jiaWait(context, value) {
    console.log(&#39;actions中的jiaWait被调用了&#39;)
    setTimeout(() =&gt; {
      context.commit(&#39;JIA&#39;, value)
    }, 500)
  },
}

// 准备mutations：用于操作数据（state）
const mutations = {
  JIA(state, value) {
    console.log(&#39;mutations中的JIA被调用了&#39;)
    state.sum += value
  },
  JIAN(state, value) {
    console.log(&#39;mutations中的JIAN被调用了&#39;)
    state.sum -= value
  },
}

// 准备state：用于存储数据
const state = {
  sum: 0, //当前的和
}

// 创建并暴露store
export default new Vuex.Store({
  actions,
  mutations,
  state,
})

</code></pre>
            </li>
          </ol>
          <h5 id="-main-js">入口文件 main.js</h5>
          <ol>
            <li>
              <p>引入并挂载store</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import vueResource from &#39;vue-resource&#39;
//引入store（如果store文件夹下只有index.js，可以简写为./store）
import store from &#39;./store&#39;

Vue.config.productionTip = false
Vue.use(vueResource)

new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
  // 挂载store，用于管理vuex中的三个对象
  store,
  beforeCreate() {
    Vue.prototype.$bus = this
  },
})
</code></pre>
            </li>
          </ol>
          <h5 id="-count-vue">子组件 Count.vue</h5>
          <ol>
            <li>
              <p>将原先data()中的sum改为读取state中的sum：<code>$store.state.sum</code></p>
            </li>
            <li><p>使用<code>dispatch</code>方法，令incrementOdd、incrementWait函数通过<code>actions</code>调用<code>mutations</code>中的JIA、JIAN函数</p></li>
            <li>
              <p>使用<code>commit</code>方法，令increment、decrement函数绕过<code>actions</code>，直接调用<code>mutations</code>中的JIA、JIAN函数</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 将原先data()中的sum改为读取state中的sum --&gt; 
    &lt;h1&gt;当前求和为：{{$store.state.sum}}&lt;/h1&gt;
    &lt;select v-model.number=&quot;n&quot;&gt;
      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/select&gt;
    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
    &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;
    &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Count&#39;,
  data() {
    return {
      n: 1 //用户选择的数字
    }
  },
  methods: {
    increment() {
      // 使用commit方法，绕过actions，直接调用mutations中的函数
      this.$store.commit(&#39;JIA&#39;, this.n)
    },
    decrement() {
      this.$store.commit(&#39;JIAN&#39;, this.n)
    },
    incrementOdd() {
      // 使用dispatch方法，通过actions，调用mutations中的函数
      this.$store.dispatch(&#39;jiaOdd&#39;, this.n)
    },
    incrementWait() {
      this.$store.dispatch(&#39;jiaWait&#39;, this.n)
    }
  },
  mounted() {
    console.log(&#39;Count&#39;, this)
  }
}
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
button {
  margin-left: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-app-vue">父组件 App.vue</h5>
          <ol>
            <li>
              <p>正常书写</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;Count/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Count from &#39;./components/Count&#39;
    export default {
        name:&#39;App&#39;,
        components:{Count},
        mounted() {
            // console.log(&#39;App&#39;,this)
        },
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="4-6-3-vuex-">4.6.3 Vuex拓展版</h4>
          <blockquote>
            <p>使用getters、mapState、mapGetters、mapMutations、mapActions拓展API</p>
          </blockquote>
          <h5 id="vuex-index-js">Vuex文件 index.js</h5>
          <ol>
            <li>
              <p>定义并导出getters</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)

// 准备actions：用于响应组件中的动作
const actions = {
  jiaOdd(context, value) {
    console.log(&#39;actions中的jiaOdd被调用了&#39;)
    if (context.state.sum % 2) {
      context.commit(&#39;JIA&#39;, value)
    }
  },
  jiaWait(context, value) {
    console.log(&#39;actions中的jiaWait被调用了&#39;)
    setTimeout(() =&gt; {
      context.commit(&#39;JIA&#39;, value)
    }, 500)
  },
}
// 准备mutations：用于操作数据（state）
const mutations = {
  JIA(state, value) {
    console.log(&#39;mutations中的JIA被调用了&#39;)
    state.sum += value
  },
  JIAN(state, value) {
    console.log(&#39;mutations中的JIAN被调用了&#39;)
    state.sum -= value
  },
}
// 准备state：用于存储数据
const state = {
  sum: 0, //当前的和
  school: &#39;尚硅谷&#39;,
  subject: &#39;前端&#39;,
}
// 准备getters：用于将state中的数据进行加工
const getters = {
  bigSum(state) {
    return state.sum * 10
  },
}

// 创建并暴露store
export default new Vuex.Store({
  actions,
  mutations,
  state,
  getters,
})
</code></pre>
            </li>
          </ol>
          <h5 id="-main-js">入口文件 main.js</h5>
          <ol>
            <li>
              <p>正常书写</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import vueResource from &#39;vue-resource&#39;
import store from &#39;./store&#39;

Vue.config.productionTip = false
Vue.use(vueResource)

new Vue({
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    store,
    beforeCreate() {
        Vue.prototype.$bus = this
    }
})
</code></pre>
            </li>
          </ol>
          <h5 id="-count-vue">子组件 Count.vue</h5>
          <ol>
            <li><p>从vuex引入：mapState, mapGetters, mapMutations, mapActions</p></li>
            <li><p>改造methods和computed中的函数</p></li>
            <li><p>更改模板字符串</p></li>
            <li>
              <p>使用mapMutations、mapActions的函数勿忘传参</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 更改模板字符串--&gt;
    &lt;h1&gt;当前求和为：{{sum}}&lt;/h1&gt;
    &lt;h3&gt;当前求和放大10倍为：{{bigSum}}&lt;/h3&gt;
    &lt;h3&gt;我在{{school}}，学习{{subject}}&lt;/h3&gt;
    &lt;select v-model.number=&quot;n&quot;&gt;
      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/select&gt;
    &lt;!-- 勿忘传参--&gt;
    &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;
    &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;
    &lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState, mapGetters, mapMutations, mapActions } from &#39;vuex&#39;
export default {
  name: &#39;Count&#39;,
  data() {
    return {
      n: 1 //用户选择的数字
    }
  },
  computed: {
    // 借助mapState生成计算属性，从state中读取数据
    // 对象写法
    // ...mapState({he:&#39;sum&#39;,xuexiao:&#39;school&#39;,xueke:&#39;subject&#39;}),
    // 数组写法
    ...mapState([&#39;sum&#39;, &#39;school&#39;, &#39;subject&#39;]),

    //借助mapGetters生成计算属性，从getters中读取数据
    // 对象写法
    // ...mapGetters({bigSum:&#39;bigSum&#39;})
    // 数组写法
    ...mapGetters([&#39;bigSum&#39;])
  },
  methods: {
    // 借助mapMutations生成对应的方法，方法中会调用commit去联系mutations
    // 对象写法
    ...mapMutations({ increment: &#39;JIA&#39;, decrement: &#39;JIAN&#39; }),
    // 数组写法
    // ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),

    // 借助mapActions生成对应的方法，方法中会调用dispatch去联系actions
    // 对象写法
    ...mapActions({ incrementOdd: &#39;jiaOdd&#39;, incrementWait: &#39;jiaWait&#39; })
    // 数组写法
    // ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
  },
  mounted() {
    const x = mapState({ he: &#39;sum&#39;, xuexiao: &#39;school&#39;, xueke: &#39;subject&#39; })
    console.log(x)
  }
}
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
button {
  margin-left: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-app-vue">父组件 App.vue</h5>
          <ol>
            <li>
              <p>正常书写</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;Count/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Count from &#39;./components/Count&#39;
    export default {
        name:&#39;App&#39;,
        components:{Count},
        mounted() {
            // console.log(&#39;App&#39;,this)
        },
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="4-6-3-vuex-">4.6.3 Vuex模块版</h4>
          <h5 id="vuex-index-js">Vuex汇总文件 index.js</h5>
          <ol>
            <li><p>将各组件的actions、mutations、state、getters拆分成不同js模块文件</p></li>
            <li><p>导入各个模块文件</p></li>
            <li>
              <p>暴露模块，可自定义名称</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
// 导入各个模块文件
import countOptions from &#39;./count&#39;
import personOptions from &#39;./person&#39;
Vue.use(Vuex)

export default new Vuex.Store({
  // 暴露模块，可自定义名称
  modules: {
    countAbout: countOptions,
    personAbout: personOptions,
  },
})
</code></pre>
            </li>
          </ol>
          <h5 id="vuex-count-js">Vuex模块文件 count.js</h5>
          <ol>
            <li>
              <p>开启命名空间：<code>namespaced: true</code></p>
            </li>
            <li>
              <p>定义actions、mutations、state、getters配置</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//求和相关的配置
export default {
  // 命名空间：可以自定义模块名称，默认为false
  namespaced: true,
  actions: {
    jiaOdd(context, value) {
      console.log(&#39;actions中的jiaOdd被调用了&#39;)
      if (context.state.sum % 2) {
        context.commit(&#39;JIA&#39;, value)
      }
    },
    jiaWait(context, value) {
      console.log(&#39;actions中的jiaWait被调用了&#39;)
      setTimeout(() =&gt; {
        context.commit(&#39;JIA&#39;, value)
      }, 500)
    },
  },
  mutations: {
    JIA(state, value) {
      console.log(&#39;mutations中的JIA被调用了&#39;)
      state.sum += value
    },
    JIAN(state, value) {
      console.log(&#39;mutations中的JIAN被调用了&#39;)
      state.sum -= value
    },
  },
  state: {
    sum: 0,
    school: &#39;尚硅谷&#39;,
    subject: &#39;前端&#39;,
  },
  getters: {
    bigSum(state) {
      return state.sum * 10
    },
  },
}
</code></pre>
            </li>
          </ol>
          <h5 id="vuex-person-js">Vuex模块文件 person.js</h5>
          <ol>
            <li><p>导入axios、nanoid插件</p></li>
            <li>
              <p>开启命名空间：<code>namespaced: true</code></p>
            </li>
            <li><p>定义actions、mutations、state、getters配置</p></li>
            <li>
              <p>在actions发送axios请求</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">//人员管理相关的配置
import axios from &#39;axios&#39;
import { nanoid } from &#39;nanoid&#39;
export default {
  // 命名空间：可以自定义模块名称，默认为false
  namespaced: true,
  actions: {
    addPersonWang(context, value) {
      if (value.name.indexOf(&#39;王&#39;) === 0) {
        context.commit(&#39;ADD_PERSON&#39;, value)
      } else {
        alert(&#39;添加的人必须姓王！&#39;)
      }
    },
    addPersonServer(context) {
      axios.get(&#39;https://api.uixsj.cn/hitokoto/get?type=social&#39;).then(
        (response) =&gt; {
          context.commit(&#39;ADD_PERSON&#39;, { id: nanoid(), name: response.data })
        },
        (error) =&gt; {
          alert(error.message)
        }
      )
    },
  },
  mutations: {
    ADD_PERSON(state, value) {
      console.log(&#39;mutations中的ADD_PERSON被调用了&#39;)
      state.personList.unshift(value)
    },
  },
  state: {
    personList: [{ id: &#39;001&#39;, name: &#39;张三&#39; }],
  },
  getters: {
    firstPersonName(state) {
      return state.personList[0].name
    },
  },
}
</code></pre>
            </li>
          </ol>
          <h5 id="-main-js">入口文件 main.js</h5>
          <ol>
            <li>
              <p>正常书写</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import vueResource from &#39;vue-resource&#39;
import store from &#39;./store&#39;

Vue.config.productionTip = false
Vue.use(vueResource)

new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
  store,
  beforeCreate() {
    Vue.prototype.$bus = this
  },
})
</code></pre>
            </li>
          </ol>
          <h5 id="-count-vue">子组件 Count.vue</h5>
          <ol>
            <li>
              <p>在计算属性<code>computed</code>中配置<code>mapState</code>、<code>mapGetters</code></p>
            </li>
            <li>
              <p>在事件处理<code>methods</code>中配置<code>mapMutations</code>、<code>mapActions</code></p>
            </li>
            <li><p>插值语法渲染，若使用<code>mapMutations</code>、<code>mapActions</code>中的函数，勿忘传递参数</p></li>
            <li>
              <p>跨模块：调用了<code>personAbout</code>模块中的<code>personList</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;当前求和为：{{sum}}&lt;/h1&gt;
    &lt;h3&gt;当前求和放大10倍为：{{bigSum}}&lt;/h3&gt;
    &lt;h3&gt;我在{{school}}，学习{{subject}}&lt;/h3&gt;
    &lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：{{personList.length}}&lt;/h3&gt;
    &lt;select v-model.number=&quot;n&quot;&gt;
      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/select&gt;
    &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;
    &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;
    &lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapState, mapGetters, mapMutations, mapActions } from &#39;vuex&#39;
export default {
  name: &#39;Count&#39;,
  data() {
    return {
      n: 1
    }
  },
  computed: {
    // 开启命名空间后，可以使用自定义的模块名称导入其中的方法
    ...mapState(&#39;countAbout&#39;, [&#39;sum&#39;, &#39;school&#39;, &#39;subject&#39;]),
    ...mapState(&#39;personAbout&#39;, [&#39;personList&#39;]),
    ...mapGetters(&#39;countAbout&#39;, [&#39;bigSum&#39;])
  },
  methods: {
    ...mapMutations(&#39;countAbout&#39;, { increment: &#39;JIA&#39;, decrement: &#39;JIAN&#39; }),
    ...mapActions(&#39;countAbout&#39;, { incrementOdd: &#39;jiaOdd&#39;, incrementWait: &#39;jiaWait&#39; })
  },
  mounted() {
    console.log(this.$store)
  }
}
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
button {
  margin-left: 5px;
}
&lt;/style&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-person-vue">子组件 Person.vue</h5>
          <ol>
            <li><p>导入nanoid插件</p></li>
            <li>
              <p>不使用<code>mapState</code>、<code>mapGetters</code>、<code>mapMutations</code>、<code>mapActions</code>，直接调用store中的方法和数据</p>
              <p>1）state：<code>this.$store.state.自定义模块名称.数据名</code></p>
              <p>2）getters：<code>this.$store.getters[&#39;自定义模块名称/函数名&#39;]</code></p>
              <p>3）mutations：<code>this.$store.commit(&#39;自定义模块名称/函数名&#39;, 要传递的数据)</code></p>
              <p>4）actions：<code>this.$store.dispatch(&#39;自定义模块名称/函数名&#39;, 要传递的数据)</code></p>
            </li>
            <li>
              <p>跨模块：调用了<code>countAbout</code>中的<code>sum</code>数据</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;人员列表&lt;/h1&gt;
    &lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：{{sum}}&lt;/h3&gt;
    &lt;h3&gt;列表中第一个人的名字是：{{firstPersonName}}&lt;/h3&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot; /&gt;
    &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;
    &lt;button @click=&quot;addWang&quot;&gt;添加一个姓王的人&lt;/button&gt;
    &lt;button @click=&quot;addPersonServer&quot;&gt;添加一个人，名字随机&lt;/button&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;{{p.name}}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { nanoid } from &#39;nanoid&#39;
export default {
  name: &#39;Person&#39;,
  data() {
    return {
      name: &#39;&#39;
    }
  },
  computed: {
    personList() {
      // 不使用mapState时，要用.personAbout指定模块
      return this.$store.state.personAbout.personList
    },
    sum() {
      return this.$store.state.countAbout.sum
    },
    firstPersonName() {
      // 不使用mapGetters时，要用[&#39;personAbout/xxx&#39;]指定模块
      return this.$store.getters[&#39;personAbout/firstPersonName&#39;]
    }
  },
  methods: {
    add() {
      const personObj = { id: nanoid(), name: this.name }
      // 不使用mapMutations时，要用personAbout/指定模块
      this.$store.commit(&#39;personAbout/ADD_PERSON&#39;, personObj)
      this.name = &#39;&#39;
    },
    addWang() {
      const personObj = { id: nanoid(), name: this.name }
      this.$store.dispatch(&#39;personAbout/addPersonWang&#39;, personObj)
      this.name = &#39;&#39;
    },
    addPersonServer() {
      this.$store.dispatch(&#39;personAbout/addPersonServer&#39;)
    }
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h5 id="-app-vue">父组件 App.vue</h5>
          <ol>
            <li>
              <p>导入各个模块</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;Count/&gt;
        &lt;hr&gt;
        &lt;Person/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Count from &#39;./components/Count&#39;
    import Person from &#39;./components/Person&#39;

    export default {
        name:&#39;App&#39;,
        components:{Count,Person},
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h2 id="-5-vue-router-">第5章 Vue-router路由</h2>
          <h3 id="5-1-">5.1 路由简介</h3>
          <ol>
            <li>
              <p><code>vue-router</code>：是 vue 的一个插件库，专门用来实现 SPA 应用</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i vue-router
</code></pre>
            </li>
            <li>
              <p>SPA 应用：</p>
              <p>1）单页 Web 应用（single page web application，SPA）</p>
              <p>2）整个应用只有一个完整的页面</p>
              <p>3）点击页面中的导航链接不会刷新页面，只会做页面的局部更新</p>
              <p>4）数据需要通过 ajax 请求获取</p>
            </li>
            <li><p>路由的定义：一个路由就是一组映射关系(key-value)，key为路径, value是<code>function</code>或<code>component</code>，多个路由需要路由器(router)进行管理</p></li>
            <li>
              <p>后端路由：node.js</p>
              <p>1）value 是 function, 用于处理客户端提交的请求</p>
              <p>2）工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数来处理请求, 返回响应数据</p>
            </li>
            <li>
              <p>前端路由：vue</p>
              <p>1）value 是 component，用于展示页面内容</p>
              <p>2）工作过程：当浏览器的路径改变时, 对应的组件就会显示</p>
            </li>
          </ol>
          <hr />
          <h3 id="5-2-">5.2 基本使用</h3>
          <h4 id="-router-index-js">路由配置 router/index.js</h4>
          <ol>
            <li><p>引入子组件</p></li>
            <li>
              <p>创建并暴露路由器：<code>export default new VueRouter({ routers:[] })</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 该文件专门用于创建整个应用的路由器
import VueRouter from &#39;vue-router&#39;
//引入组件
import About from &#39;../components/About&#39;
import Home from &#39;../components/Home&#39;

//创建并暴露一个路由器
export default new VueRouter({
  routes: [
    {
      path: &#39;/about&#39;,
      component: About,
    },
    {
      path: &#39;/home&#39;,
      component: Home,
    },
  ],
})
</code></pre>
            </li>
          </ol>
          <h4 id="-main-js">入口文件 main.js</h4>
          <ol>
            <li>
              <p>导入并应用插件：<code>Vue.use(VueRouter)</code></p>
            </li>
            <li>
              <p>创建路由器：<code>router: router</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
//引入VueRouter
import VueRouter from &#39;vue-router&#39;
//引入路由器
import router from &#39;./router&#39;

Vue.config.productionTip = false
//应用插件
Vue.use(VueRouter)

//创建vm
new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
  // 创建路由器
  router: router,
})
</code></pre>
            </li>
          </ol>
          <h4 id="-about-home-vue">一般组件 About、Home.vue</h4>
          <ol>
            <li>
              <p>正常书写</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;h2&gt;我是About的内容&lt;/h2&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;About&#39;
    }
&lt;/script&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;h2&gt;我是Home的内容&lt;/h2&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;Home&#39;
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="-app-vue">父组件 App.vue</h4>
          <ol>
            <li>
              <p>原始html：使用<code>&lt;a&gt;</code>标签实现页面的跳转</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt;
&lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt;
</code></pre>
            </li>
            <li>
              <p>Vue：借助<code>&lt;router-link&gt;</code>标签实现路由的切换（<code>active-class</code>可配置高亮样式）</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;
</code></pre>
            </li>
            <li>
              <p>指定展示位置：<code>&lt;router-view&gt;</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
            </li>
            <li>
              <p>完整代码：style没写，因为已经在<code>public/index.html</code>主页中引入了bootstrap.css样式</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;
        &lt;div class=&quot;page-header&quot;&gt;
          &lt;h2&gt;Vue Router Demo&lt;/h2&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;
        &lt;div class=&quot;list-group&quot;&gt;
          &lt;!-- 原始html中使用a标签实现页面的跳转 --&gt;
          &lt;!-- &lt;a class=&quot;list-group-item active&quot; href=&quot;./about.html&quot;&gt;About&lt;/a&gt; --&gt;
          &lt;!-- &lt;a class=&quot;list-group-item&quot; href=&quot;./home.html&quot;&gt;Home&lt;/a&gt; --&gt;

          &lt;!-- Vue中借助router-link标签实现路由的切换 --&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;col-xs-6&quot;&gt;
        &lt;div class=&quot;panel&quot;&gt;
          &lt;div class=&quot;panel-body&quot;&gt;
            &lt;!-- 指定组件的呈现位置 --&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;App&#39;
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-3-">5.3 嵌套路由（多级路由）</h3>
          <blockquote>
            <ol>
              <li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹</li>
              <li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载</li>
              <li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息</li>
              <li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到</li>
            </ol>
          </blockquote>
          <h4 id="-router-index-js">路由配置 router/index.js</h4>
          <ol>
            <li><p>从<code>pages</code>文件夹导入路由组件</p></li>
            <li>
              <p>使用<code>children</code>配置项</p>
              <p>1）一级路由，路径加&#39;/&#39;</p>
              <p>2）二级以上路由，路径不加&#39;/&#39;</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 该文件专门用于创建整个应用的路由器
import VueRouter from &#39;vue-router&#39;
//引入组件
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
import News from &#39;../pages/News&#39;
import Message from &#39;../pages/Message&#39;

//创建并暴露一个路由器
export default new VueRouter({
  routes: [
    {
      path: &#39;/about&#39;,
      component: About,
    },
    {
      // 一级路由，路径加&#39;/&#39;
      path: &#39;/home&#39;,
      component: Home,
      children: [
        {
          // 二级路由，路径不加&#39;/&#39;
          path: &#39;news&#39;,
          component: News,
        },
        {
          path: &#39;message&#39;,
          component: Message,
        },
      ],
    },
  ],
})
</code></pre>
            </li>
          </ol>
          <h4 id="-about-home-news-message-vue">路由组件 About/Home/News/Message.vue</h4>
          <ol>
            <li>
              <p>跳转：要带上一级路由的地址，否则无效（可以用命名路由简化）</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
            </li>
            <li>
              <p>一级路由组件：About.vue、Home.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;h2&gt;我是About的内容&lt;/h2&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;About&#39;
}
&lt;/script&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Home组件内容&lt;/h2&gt;
    &lt;div&gt;
      &lt;ul class=&quot;nav nav-tabs&quot;&gt;
        &lt;li&gt;
          &lt;!-- 跳转必须写完整路径 --&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Home&#39;
}
&lt;/script&gt;
</code></pre>
            </li>
            <li>
              <p>二级路由组件：News.vue、Message.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;/message1&quot;&gt;message001&lt;/a&gt;&amp;nbsp;&amp;nbsp;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;/message2&quot;&gt;message002&lt;/a&gt;&amp;nbsp;&amp;nbsp;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;/message/3&quot;&gt;message003&lt;/a&gt;&amp;nbsp;&amp;nbsp;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Message&#39;
}
&lt;/script&gt;
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul&gt;
    &lt;li&gt;news001&lt;/li&gt;
    &lt;li&gt;news002&lt;/li&gt;
    &lt;li&gt;news003&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;News&#39;
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="-banner-vue">一般组件 Banner.vue</h4>
          <ol>
            <li>
              <p>正常书写</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;
    &lt;div class=&quot;page-header&quot;&gt;
      &lt;h2&gt;Vue Router Demo&lt;/h2&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Banner&#39;
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="-app-vue">父组件 App.vue</h4>
          <ol>
            <li>
              <p>导入一般组件Banner.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;!-- 一般组件 Banner --&gt;
      &lt;Banner /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt;
        &lt;div class=&quot;list-group&quot;&gt;
          &lt;!-- Vue中借助router-link标签实现路由的切换 --&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;col-xs-6&quot;&gt;
        &lt;div class=&quot;panel&quot;&gt;
          &lt;div class=&quot;panel-body&quot;&gt;
            &lt;!-- 指定组件的呈现位置 --&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Banner from &#39;./components/Banner&#39;
export default {
  name: &#39;App&#39;,
  components: { Banner }
}
&lt;/script&gt;

</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-4-query-">5.4 query参数</h3>
          <blockquote>
            <p>父路由组件给子路由组件传递数据，使用<code>&lt;router-link :to=&quot;{key:value,...}&quot;&gt;</code>传参，并用<code>$router.query.xxx</code>接收参数</p>
          </blockquote>
          <ol>
            <li>
              <p>传递参数：</p>
              <p>1）方法1：字符串写法：<code>?key1=value1&amp;key2=value2</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
</code></pre>
              <p>2）方法2：对象写法（推荐）</p>
              <pre class="prettyprint linenums:0"><code class="lang-html">&lt;router-link
  :to=&quot;{
    path:&#39;/home/message/detail&#39;,
    query:{
        id:666,
        title:m.&#39;你好&#39;
    }
}&quot;
&gt;{{m.title}}&lt;/router-link&gt;
</code></pre>
            </li>
            <li>
              <p>接收参数：<code>$route.query.xxx</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-js">$route.query.id
$route.query.title
</code></pre>
            </li>
            <li>
              <p>案例：二级路由组件Message.vue下，设置三级路由组件Detail.vue，并向其传递数据</p>
              <p>1）路由配置：router/index.js</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">......
//创建并暴露一个路由器
export default new VueRouter({
  routes: [
    {
      path: &#39;/about&#39;,
      component: About,
    },
    {
      path: &#39;/home&#39;,
      component: Home,
      children: [
        {
          path: &#39;news&#39;,
          component: News,
        },
        {
          path: &#39;message&#39;,
          component: Message,
          children: [
            {
              path: &#39;detail&#39;,
              component: Detail,
            },
          ],
        },
      ],
    },
  ],
})
</code></pre>
              <p>2）二级路由组件：pages/Message.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;
        &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;
        &lt;router-link
          :to=&quot;{
                    path:&#39;/home/message/detail&#39;,
                    query:{
                        id:m.id,
                        title:m.title
                    }
                }&quot;
        &gt;{{m.title}}&lt;/router-link&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;hr /&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Message&#39;,
  data() {
    return {
      messageList: [
        { id: &#39;001&#39;, title: &#39;消息001&#39; },
        { id: &#39;002&#39;, title: &#39;消息002&#39; },
        { id: &#39;003&#39;, title: &#39;消息003&#39; }
      ]
    }
  }
}
&lt;/script&gt;
</code></pre>
              <p>3）三级路由组件：pages/Detail.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;ul&gt;
        &lt;li&gt;消息编号：{{$route.query.id}}&lt;/li&gt;
        &lt;li&gt;消息标题：{{$route.query.title}}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;Detail&#39;,
        mounted() {
            console.log(this.$route)
        },
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-5-">5.5 命名路由</h3>
          <blockquote>
            <p>可以简化路由的跳转，在路由配置文件index.js中设置<code>name</code>属性，并在<code>&lt;router-link :to=&quot;{name:&#39;xxx&#39;,...}&quot;&gt;</code>中配置命名</p>
          </blockquote>
          <ol>
            <li>
              <p>路由配置文件：router/index.js</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">......
{
  path: &#39;/demo&#39;,
  component: Demo,
  children: [
    {
      path: &#39;test&#39;,
      component: Test,
      children: [
        {
          name: &#39;hello&#39;, //给路由命名
          path: &#39;welcome&#39;,
          component: Hello,
        },
      ],
    },
  ],
},
</code></pre>
            </li>
            <li>
              <p>简化跳转：</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{name:&#39;hello&#39;}&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
    :to=&quot;{
        name:&#39;hello&#39;,
        query:{
           id:666,
            title:&#39;你好&#39;
        }
    }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-6-params-">5.6 params参数</h3>
          <blockquote>
            <p>父路由组件给子路由组件传递数据，在index.js中用占位符<code>:</code>声明接收params参数，用<code>&lt;router-link :to=&quot;/url/value1/value2/...&quot;&gt;</code>传参，并用<code>$router.params.xxx</code>接收参数</p>
          </blockquote>
          <ol>
            <li>
              <p>路由配置：router/index.js</p>
              <p>1）命名路由：设置<code>name</code></p>
              <p>2）在<code>path</code>中使用占位符（<code>:</code>）声明接受<code>params</code>参数</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">{
  path: &#39;/home&#39;,
  component: Home,
  children: [
    {
      path: &#39;news&#39;,
      component: News,
    },
    {
      component: Message,
      children: [
        {
          name: &#39;xiangqing&#39;,
          path: &#39;detail/:id/:title&#39;, //使用占位符声明接收params参数
          component: Detail,
        },
      ],
    },
  ],
},
</code></pre>
            </li>
            <li>
              <p>传递参数：二级路由组件 Message.vue</p>
              <p>1）方法1：字符串写法：<code>/url/value1/value2/...</code></p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
</code></pre>
              <p>2）方法2：对象写法，不能使用path配置项，必须使用name配置！</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
    :to=&quot;{
        name:&#39;xiangqing&#39;,
        params:{
           id:666,
            title:&#39;你好&#39;
        }
    }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
            </li>
            <li>
              <p>接收参数：三级路由组件 Detail.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">$route.params.id
$route.params.title
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul&gt;
    &lt;li&gt;消息编号：{{$route.query.id}}&lt;/li&gt;
    &lt;li&gt;消息标题：{{$route.query.title}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Detail&#39;,
  mounted() {
    console.log(this.$route)
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h3 id="5-7-props-">5.7 props配置</h3>
          <blockquote>
            <p>让路由组件更方便的收到参数，在路由配置文件index.js中添加 <code>props</code> 配置项，并在接收数据的路由组件Detail.vue中配置<code>props</code></p>
          </blockquote>
          <ol>
            <li>
              <p><code>props</code>值为对象：该对象中所有的<code>key-value</code>的组合最终都会通过props传给Detail组件（缺点：静态数据）</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">props:{a:900,b:&#39;hello&#39;}
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--Detail.vue--&gt;
&lt;li&gt;a:{{a}}&lt;/li&gt;
&lt;li&gt;b:{{b}}&lt;/li&gt;
...
props: [&#39;a&#39;, b&#39;]
</code></pre>
            </li>
            <li>
              <p><code>props</code>值为布尔值：值为true，则把路由收到的所有<code>params</code>参数通过props传给Detail组件（缺点：无法传递<code>query</code>参数）</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">path:&#39;detail/:id/:title&#39;,
props:true
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--Detail.vue--&gt;
&lt;li&gt;消息编号：{{id}}&lt;/li&gt;
&lt;li&gt;消息标题：{{title}}&lt;/li&gt;
...
props: [&#39;id&#39;, &#39;title&#39;]
</code></pre>
            </li>
            <li>
              <p><code>props</code>值为函数：该函数返回的对象中每一组<code>key-value</code>都会通过props传给Detail组件</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">path:&#39;detail&#39;,
props($route){
    return {
        id: $route.query.id,
        title: $route.query.title,
        a: 1,
        b: &#39;hello&#39;
    }
}
</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--Detail.vue--&gt;
&lt;li&gt;消息编号：{{id}}&lt;/li&gt;
&lt;li&gt;消息标题：{{title}}&lt;/li&gt;
&lt;li&gt;a:{{a}}&lt;/li&gt;
&lt;li&gt;b:{{b}}&lt;/li&gt;
......
props: [&#39;id&#39;, &#39;title&#39;, &#39;a&#39;, &#39;b&#39;]
</code></pre>
            </li>
            <li>
              <p>案例：</p>
              <p>1）路由配置文件：router/index.js</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">{
  name: &#39;xiangqing&#39;,
  path: &#39;detail&#39;,
  component: Detail,
  props($route) {
    return {
      id: $route.query.id,
      title: $route.query.title,
      a: 1,
      b: &#39;hello&#39;,
    }
  },
},
</code></pre>
              <p>2）路由组件：Detail.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;ul&gt;
    &lt;li&gt;消息编号：{{id}}&lt;/li&gt;
    &lt;li&gt;消息标题：{{title}}&lt;/li&gt;
    &lt;li&gt;a:{{a}}&lt;/li&gt;
    &lt;li&gt;b:{{b}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Detail&#39;,
  props: [&#39;id&#39;, &#39;title&#39;, &#39;a&#39;, &#39;b&#39;],
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-8-">5.8 历史记录</h3>
          <blockquote>
            <p><code>&lt;router-link&gt;</code>的<code>replace</code>属性：控制路由跳转时操作浏览器历史记录的模式</p>
          </blockquote>
          <ol>
            <li>
              <p>历史记录的写入方式：</p>
              <p>1）<code>push</code>：追加历史记录（默认）</p>
              <p>2）<code>replace</code>：替换当前记录（相当于无痕浏览，无法后退，只能退到push模式的历史记录上）</p>
            </li>
            <li>
              <p>开启<code>replace</code>模式：</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;!--简写--&gt;
&lt;router-link replace ...&gt;News&lt;/router-link&gt;
&lt;!--完整--&gt;
&lt;router-link :replace=&quot;true&quot; ...&gt;News&lt;/router-link&gt;
</code></pre>
            </li>
            <li>
              <p>案例：在父组件App.vue中，更改About、Home路由组件为repalce属性，效果：点击跳转后，浏览器无法后退到使用replace的记录</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;router-link repalce class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
&lt;router-link repalce class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-9-">5.9 编程式路由导航</h3>
          <blockquote>
            <p>不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活（<code>&lt;router-link&gt;</code>最终会转为<code>&lt;a&gt;</code>，使用<code>&lt;button&gt;</code>时便无法再用<code>&lt;router-link&gt;</code>了）</p>
          </blockquote>
          <h4 id="5-9-1-push-">5.9.1 push模式</h4>
          <ol>
            <li><p>定义：通过在<code>methods</code>中定义函数，使用<code>$router.push</code>方法实现路由跳转，参数配置与<code>&lt;router-link&gt;</code>相同</p></li>
            <li><p>特点：浏览器会记录下历史记录，可以通过后退按钮退回到当前页面</p></li>
            <li>
              <p>案例：二级路由组件 Message.vue，添加按钮，实现push模式跳转到三极路由组件 Detail.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;
                &lt;!-- 定义pushShow函数（可传参），通过push模式进行路由跳转 --&gt;
                &lt;button @click=&quot;pushShow(m)&quot;&gt;push查看&lt;/button&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr&gt;
        &lt;!-- 展示子路由组件Detail.vue --&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  ......
  methods: {
    pushShow(m) {
      this.$router.push({
        name: &#39;xiangqing&#39;,
        query: {
          id: m.id,
          title: m.title
        }
      })
    },
  ......
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="5-9-2-replace-">5.9.2 replace模式</h4>
          <ol>
            <li><p>定义：通过在<code>methods</code>中定义函数，使用<code>$router.repalce</code>方法实现路由跳转，参数配置与<code>&lt;router-link&gt;</code>相同</p></li>
            <li><p>特点：浏览器不会记录下历史记录，无法通过后退按钮退回到当前页面</p></li>
            <li>
              <p>案例：二级路由组件 Message.vue，添加按钮，实现replace模式跳转到三极路由组件 Detail.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;
                &lt;!-- 定义replaceShow函数（可传参），通过repalce模式进行路由跳转 --&gt;
                &lt;button @click=&quot;replaceShow(m)&quot;&gt;replace查看&lt;/button&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;hr&gt;
        &lt;!-- 展示子路由组件Detail.vue --&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  ......
  methods: {
    replaceShow(m) {
      this.$router.replace({
        name: &#39;xiangqing&#39;,
        query: {
          id: m.id,
          title: m.title
        }
      })
    }
  ......
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h4 id="5-9-3-">5.9.3 前进与后退</h4>
          <ol>
            <li>
              <p><code>$router.forward()</code>：前进，相当于浏览器前进按钮</p>
            </li>
            <li>
              <p><code>$router.back()</code>：后退，相当于浏览器后退按钮</p>
            </li>
            <li>
              <p><code>$router.go(n)</code>：可前进可后退，传入数字，正数代表前进n页，负数代表后退n页</p>
            </li>
            <li>
              <p>案例：在Banner.vue中添加前进、后退、go按钮</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
    &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt;
        &lt;div class=&quot;page-header&quot;&gt;
            &lt;h2&gt;Vue Router Demo&lt;/h2&gt;
            &lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt;
            &lt;button @click=&quot;forward&quot;&gt;前进&lt;/button&gt;
            &lt;button @click=&quot;test&quot;&gt;测试一下go&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name:&#39;Banner&#39;,
        methods: {
            back(){
                this.$router.back()
            },
            forward(){
                this.$router.forward()
            },
            test(){
                this.$router.go(3)
            }
        },
    }
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-10-">5.10 缓存路由组件</h3>
          <blockquote>
            <p><code>&lt;keep-alive include=&quot;xxx&quot;&gt;</code>：让不展示的路由组件保持挂载，不被销毁。（应用：当切换回页面时，之前输入的内容可以保存）</p>
          </blockquote>
          <ol>
            <li>
              <p>使用<code>&lt;keep-alive&gt;</code>包裹父级路由组件中的<code>&lt;router-view&gt;</code>展示位置，并用<code>include</code>指定需要保留的子级路由组件名称（由<code>name</code>定义的）</p>
              <p>1）缓存多个子路由组件：</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;keep-alive include=&quot;[&#39;xxx&#39;,&#39;xxxx&#39;]&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
              <p>2）缓存单个子路由组件：</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;keep-alive include=&quot;xxx&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
              <p>3）注意：如果不指定<code>include</code>，默认缓存所有在该位置展示的子组件</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;keep-alive&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
            </li>
            <li>
              <p>案例：在一级路由组件Home.vue中，缓存二级路由组件News、Message.vue</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Home组件内容&lt;/h2&gt;
    &lt;div&gt;
      &lt;ul class=&quot;nav nav-tabs&quot;&gt;
        &lt;li&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;!-- 缓存多个路由组件 --&gt;
      &lt;keep-alive :include=&quot;[&#39;News&#39;,&#39;Message&#39;]&quot;&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
      &lt;/keep-alive&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;Home&#39;
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <h3 id="5-11-">5.11 路由生命周期函数</h3>
          <blockquote>
            <p>路由组件所独有的两个钩子<code>activated</code>、<code>deactivated</code>，用于捕获路由组件的激活状态。</p>
          </blockquote>
          <ol>
            <li><p>应用场景：即缓存路由组件，又在切换到其他路由组件时停止上个路由组件的动作。</p></li>
            <li>
              <p>案例：在 News.vue 组件中使用定时器添加一个不断闪烁的标题，切换到其他组件时定时器停止运行</p>
              <p>1）<code>activated()</code>：配置定时器</p>
              <p>2）<code>deactivated()</code>：清除定时器</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;li :style=&quot;{opacity}&quot;&gt;欢迎学习Vue&lt;/li&gt;
......
&lt;script&gt;
export default {
  name: &#39;News&#39;,
  data() {
    return {
      opacity: 1
    }
  },
  activated() {
    console.log(&#39;News组件被激活了&#39;)
    this.timer = setInterval(() =&gt; {
      console.log(&#39;@&#39;)
      this.opacity -= 0.01
      if (this.opacity &lt;= 0) this.opacity = 1
    }, 16)
  },
  deactivated() {
    console.log(&#39;News组件失活了&#39;)
    clearInterval(this.timer)
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-12-">5.12 路由守卫</h3>
          <blockquote>
            <p>对路由进行权限控制，需要在路由配置文件<code>index.js</code>中对每个路由项中设置<code>meta:{isAuth: bool,...}</code>，辅助判断是否需要鉴权</p>
          </blockquote>
          <h4 id="5-12-1-">5.12.1 全局路由守卫</h4>
          <ol>
            <li>
              <p>全局前置路由守卫：初始化的时候被调用、每次路由切换之前被调用</p>
              <p>1）语法：<code>router.beforeEach((to, from, next)=&gt;{})</code></p>
              <p>2）参数：</p>
              <ul>
                <li><code>to</code>：要去的地址</li>
                <li><code>from</code>：来源地址</li>
                <li><code>next</code>：放行函数</li>
              </ul>
            </li>
            <li>
              <p>全局后置路由守卫：初始化的时候被调用、每次路由切换之后被调用</p>
              <p>1）语法：<code>router.afterEach((to, from))=&gt;{})</code></p>
              <p>2）参数：</p>
              <ul>
                <li><code>to</code>：要去的地址</li>
                <li><code>from</code>：来源地址</li>
              </ul>
            </li>
            <li>
              <p>案例：如果在localStorage中的school名称不为atguigu，则无法访问二、三级路由组件News、Message、Detail</p>
              <p>1）实例化<code>VueRouter</code>，并为每个路由项设置<code>meta</code>对象</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">......
const router = new VueRouter({
  routes: [
    {
      name: &#39;guanyu&#39;,
      path: &#39;/about&#39;,
      component: About,
      meta: { title: &#39;关于&#39; },
    },
    {
      name: &#39;zhuye&#39;,
      path: &#39;/home&#39;,
      component: Home,
      meta: { title: &#39;主页&#39; },
      children: [
        {
          name: &#39;xinwen&#39;,
          path: &#39;news&#39;,
          component: News,
          // meta对象：专门允许程序员放自定义属性的地方
          // isAuth：是否需要授权
          meta: { isAuth: true, title: &#39;新闻&#39; },
        },
        {
          name: &#39;xiaoxi&#39;,
          path: &#39;message&#39;,
          component: Message,
          meta: { isAuth: true, title: &#39;消息&#39; },
          children: [
            {
              name: &#39;xiangqing&#39;,
              path: &#39;detail&#39;,
              component: Detail,
              meta: { isAuth: true, title: &#39;详情&#39; },
                }
              },
            },
          ],
        },
      ],
    },
  ],
})
......
</code></pre>
              <p>2）设置全局前置路由守卫：用于鉴定访问权限</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">router.beforeEach((to, from, next) =&gt; {
  console.log(&#39;前置路由守卫&#39;, to, from)
  if (to.meta.isAuth) {
    //判断是否需要鉴定权限
    if (localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;) {
      next()
    } else {
      alert(&#39;学校名不对，无权限查看！&#39;)
    }
  } else {
    next()
  }
})
</code></pre>
              <p>3）设置全局后置路由守卫：如果访问成功，则修改页面标题</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">router.afterEach((to, from) =&gt; {
  console.log(&#39;后置路由守卫&#39;, to, from)
  // 更换页面标题
  document.title = to.meta.title || &#39;硅谷系统&#39;
})
</code></pre>
              <p>4）导出路由</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">export default router
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="5-12-2-">5.12.2 独享路由守卫</h4>
          <ol>
            <li>
              <p>独享路由守卫：单独针对某一个路由，可以和全局后置路由守卫相配合</p>
              <p>1）语法：<code>beforeEnter: (to, from, next)=&gt;{}</code></p>
              <p>2）参数：</p>
              <ul>
                <li><code>to</code>：要去的地址</li>
                <li><code>from</code>：来源地址</li>
                <li><code>next</code>：放行函数</li>
              </ul>
            </li>
            <li>
              <p>案例：针对News路由组件，如果localStorage中储存的school名称不为atguigu，则无法访问</p>
              <p>1）直接在路由设置文件router/index.js中对news路由配置项进行修改即可</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">......
{
  name: &#39;xinwen&#39;,
  path: &#39;news&#39;,
  component: News,
  meta: { isAuth: true, title: &#39;新闻&#39; },
  // 独享路由守卫
  beforeEnter: (to, from, next) =&gt; {
    console.log(&#39;独享路由守卫&#39;, to, from)
    if (to.meta.isAuth) {
      //判断是否需要鉴权
      if (localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;) {
        next()
      } else {
        alert(&#39;学校名不对，无权限查看！&#39;)
      }
    } else {
      next()
    }
  },
},
......
</code></pre>
              <p>2）导出路由</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">export default router
</code></pre>
            </li>
          </ol>
          <hr />
          <h4 id="5-12-3-">5.12.3 组件内守卫</h4>
          <ol>
            <li>
              <p>进入守卫：通过路由规则，进入该组件时被调用</p>
              <p>1）语法：<code>beforeRouteEnter(to, from, next){}</code></p>
              <p>2）参数：</p>
              <ul>
                <li><code>to</code>：要去的地址</li>
                <li><code>from</code>：来源地址</li>
                <li><code>next</code>：放行函数</li>
              </ul>
            </li>
            <li>
              <p>离开守卫：通过路由规则，离开该组件时被调用</p>
              <p>1）语法：<code>beforeRouteLeave(to, from, next){}</code></p>
              <p>2）参数：</p>
              <ul>
                <li><code>to</code>：要去的地址</li>
                <li><code>from</code>：来源地址</li>
                <li><code>next</code>：放行函数</li>
              </ul>
            </li>
            <li><p>注意：必须是通过路由规则进入/离开组件时才会起作用，如果不是通过路由规则（如直接引入并渲染在页面），则会失效</p></li>
            <li>
              <p>案例：为About.vue路由组件添加组件内守卫</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;h2&gt;我是About的内容&lt;/h2&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;About&#39;,
  // 进入守卫：通过路由规则，进入该组件时被调用
  beforeRouteEnter(to, from, next) {
    console.log(&#39;About--beforeRouteEnter&#39;, to, from)
    if (to.meta.isAuth) {
      //判断是否需要鉴权
      if (localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;) {
        next()
      } else {
        alert(&#39;学校名不对，无权限查看！&#39;)
      }
    } else {
      next()
    }
  },

  // 离开守卫：通过路由规则，离开该组件时被调用
  beforeRouteLeave(to, from, next) {
    console.log(&#39;About--beforeRouteLeave&#39;, to, from)
    next()
  }
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-13-">5.13 路由器的两种工作模式</h3>
          <blockquote>
            <ul>
              <li>
                <p>hash值：URL中井号（<code>#</code>）后面的内容就是hash值，如：<code>localhost:8080/about/#/news/big/123</code></p>
              </li>
              <li><p>hash值不会包含在http请求中，即hash值不会带给服务器，上述URL中服务器接收到的地址不会带<code>#</code>后面的参数</p></li>
            </ul>
          </blockquote>
          <h4 id="5-13-1-hash-">5.13.1 hash模式</h4>
          <ol>
            <li>
              <p>开启方法：在路由配置文件router/index.js中设置，如果不设置默认为<code>hash</code>模式</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const router = new VueRouter({
  mode: &#39;hash&#39;,
  routes: [...]
  ],
})
</code></pre>
            </li>
            <li><p>URL地址中永远带着<code>#</code>号，不美观</p></li>
            <li><p>若将地址通过第三方手机app分享，如果app校验严格，则地址会被标记为不合法</p></li>
            <li><p>兼容性较好</p></li>
            <li><p>刷新页面时，不会产生404错误</p></li>
          </ol>
          <h4 id="5-13-2-history-">5.13.2 history模式</h4>
          <ol>
            <li>
              <p>开启方法：在路由配置文件router/index.js中设置</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const router = new VueRouter({
  mode: &#39;history&#39;,
  routes: [...]
  ],
})
</code></pre>
            </li>
            <li><p>URL地址干净美观</p></li>
            <li><p>兼容性和hash模式相比略差</p></li>
            <li>
              <p>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。npm插件：<code>connect-history-api-fallback</code></p>
              <p>1）安装：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i connect-history-api-fallback
</code></pre>
              <p>2）express服务器部署：</p>
              <pre class="prettyprint linenums:0"><code class="lang-js">const express = require(&#39;express&#39;)
// 引入history相关插件
const history = require(&#39;connect-history-api-fallback&#39;)

const app = express()
// 全局中间件：挂载history相关插件
app.use(history())
// 托管静态资源
app.use(express.static(__dirname + &#39;/static&#39;))
// 配置GET请求等等
app.get(...)
......
// 启动服务器
app.listen(8080, (err) =&gt; {
  if(!err) console.log(&#39;服务器成功启动了!&#39;)
})
</code></pre>
            </li>
          </ol>
          <hr />
          <h3 id="5-14-ui-">5.14 UI组件库</h3>
          <h4 id="5-14-1-ui-">5.14.1 移动端UI组件库</h4>
          <ol>
            <li>Vant：<a href="https://youzan.github.io/vant">https://youzan.github.io/vant</a></li>
            <li>Cube UI：<a href="https://didi.github.io/cube-ui">https://didi.github.io/cube-ui</a></li>
            <li>Mint UI：<a href="http://mint-ui.github.io">http://mint-ui.github.io</a></li>
          </ol>
          <h4 id="5-14-2-pc-ui-">5.14.2 PC端UI组件库</h4>
          <ol>
            <li>Element UI：<a href="https://element.eleme.cn">https://element.eleme.cn</a></li>
            <li>IView UI：<a href="https://www.iviewui.com">https://www.iviewui.com</a></li>
          </ol>
          <h4 id="5-14-3-element-">5.14.3 使用Element组件库</h4>
          <ol>
            <li>
              <p>安装：</p>
              <pre class="prettyprint linenums:0"><code class="lang-cmd">npm i element-ui
</code></pre>
            </li>
            <li>
              <p>入口文件 main.js：ElementUI组件库</p>
              <p>1）完整引入：不推荐，格式太大</p>
              <p>
                2）按需引入：推荐，借助<a href="https://github.com/ElementUI/babel-plugin-component"><code>babel-plugin-component</code></a
                >按需引入
              </p>
              <pre class="prettyprint linenums:0"><code class="lang-js">// babel.config.js
module.exports = {
  presets: [
    &#39;@vue/cli-plugin-babel/preset&#39;,
    // 注意：这里和官网写的不一样
    [&#39;@babel/preset-env&#39;, { modules: false }],
  ],
  plugins: [
    [
      &#39;component&#39;,
      {
        libraryName: &#39;element-ui&#39;,
        styleLibraryName: &#39;theme-chalk&#39;,
      },
    ],
  ],
}

</code></pre>
              <pre class="prettyprint linenums:0"><code class="lang-js">// 引入Vue
import Vue from &#39;vue&#39;
// 引入App
import App from &#39;./App.vue&#39;

// 完整引入
// 引入ElementUI组件库
// import ElementUI from &#39;element-ui&#39;;

// 引入ElementUI全部样式
// import &#39;element-ui/lib/theme-chalk/index.css&#39;;

// 按需引入
import { Button, Row, DatePicker } from &#39;element-ui&#39;

// 关闭Vue的生产提示
Vue.config.productionTip = false

// 应用ElementUI
// Vue.use(ElementUI);

// 自定义组件名称
Vue.component(&#39;atguigu-button&#39;, Button)
Vue.component(&#39;atguigu-row&#39;, Row)
Vue.component(&#39;atguigu-date-picker&#39;, DatePicker)

//创建vm
new Vue({
  el: &#39;#app&#39;,
  render: (h) =&gt; h(App),
})
</code></pre>
            </li>
            <li>
              <p>父组件 App.vue：直接使用定义好的组件</p>
              <pre class="prettyprint linenums:0"><code class="lang-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button&gt;原生的按钮&lt;/button&gt;
    &lt;input type=&quot;text&quot; /&gt;
    &lt;atguigu-row&gt;
      &lt;atguigu-button&gt;默认按钮&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;primary&quot;&gt;主要按钮&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;success&quot;&gt;成功按钮&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;info&quot;&gt;信息按钮&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;warning&quot;&gt;警告按钮&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;danger&quot;&gt;危险按钮&lt;/atguigu-button&gt;
    &lt;/atguigu-row&gt;
    &lt;atguigu-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot;&gt;&lt;/atguigu-date-picker&gt;
    &lt;atguigu-row&gt;
      &lt;atguigu-button icon=&quot;el-icon-search&quot; circle&gt;&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;primary&quot; icon=&quot;el-icon-s-check&quot; circle&gt;&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle&gt;&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;info&quot; icon=&quot;el-icon-message&quot; circle&gt;&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle&gt;&lt;/atguigu-button&gt;
      &lt;atguigu-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/atguigu-button&gt;
    &lt;/atguigu-row&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &#39;App&#39;
}
&lt;/script&gt;
</code></pre>
            </li>
          </ol>
          <hr />
        </article>
      </div>
    </div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<script type="text/javascript">
  // <!--
  $(document).ready(function () {
    var css_conf = eval(markdown_panel_style)
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts)
    setTimeout(function () {
      $('#tree').ztree_toc(conf)
    }, 100)
  })
  //-->
</script>
